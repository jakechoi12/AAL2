<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AAL - All About Logistics</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üöö</text></svg>">
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <!-- Google Maps API -->
    <!-- API ÌÇ§Îäî ÌôòÍ≤Ω Î≥ÄÏàòÏóêÏÑú Î°úÎìúÌï©ÎãàÎã§ -->
    <script>
        // Google Maps API ÌÇ§Î•º Î∞±ÏóîÎìúÏóêÏÑú Í∞ÄÏ†∏ÏòµÎãàÎã§
        let googleMapsApiKey = null;
        // Ï†ÑÏó≠ Î≥ÄÏàò ÏÑ†Ïñ∏ (body scriptÏóêÏÑúÎèÑ ÏÇ¨Ïö©)
        window.isMapInitialized = false;
        window.intersectionObserver = null;
        
        // checkAndInitMap Ìï®ÏàòÎ•º Î®ºÏ†Ä ÏÑ†Ïñ∏ (initMapsAPIÏóêÏÑú Ìò∏Ï∂úÎêòÎØÄÎ°ú)
        // Ïã§Ï†ú Íµ¨ÌòÑÏùÄ body scriptÏóêÏÑú Ïù¥Î£®Ïñ¥ÏßÄÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî ÏÑ†Ïñ∏Îßå Ìï®
        function checkAndInitMap() {
            // body scriptÏùò checkAndInitMapÏù¥ Ï†ïÏùòÎêòÏñ¥ ÏûàÏúºÎ©¥ Ìò∏Ï∂ú
            // ÏïÑÏßÅ Ï†ïÏùòÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ ÎÇòÏ§ëÏóê Ïû¨ÏãúÎèÑ
            if (typeof window.checkAndInitMap === 'function') {
                window.checkAndInitMap();
            } else {
                // body scriptÍ∞Ä Î°úÎìúÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞
                setTimeout(checkAndInitMap, 100);
            }
        }
        
        // head scriptÏóêÏÑúÎèÑ windowÏóê Î∞îÏù∏Îî© (body scriptÍ∞Ä Î°úÎìúÎêòÍ∏∞ Ï†ÑÏóê Ìò∏Ï∂úÎê† Ïàò ÏûàÏùå)
        window.checkAndInitMap = checkAndInitMap;
        
        // Google Maps API Î°úÎìú ÏôÑÎ£å ÏΩúÎ∞±
        function initMapsAPI() {
            if (typeof google !== 'undefined' && google.maps) {
                checkAndInitMap();
            }
        }
        
        // API ÌÇ§Î•º Í∞ÄÏ†∏ÏôÄÏÑú Google Maps APIÎ•º Î°úÎìúÌï©ÎãàÎã§
        async function loadGoogleMapsAPI() {
            try {
                const response = await fetch('/api/config/google-maps-key');
                if (!response.ok) {
                    throw new Error('Failed to fetch Google Maps API key');
                }
                const data = await response.json();
                googleMapsApiKey = data.apiKey;
                window.GOOGLE_MAPS_API_KEY = googleMapsApiKey;
                
                // API ÌÇ§Î•º Í∞ÄÏ†∏Ïò® ÌõÑ Google Maps API Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${googleMapsApiKey}&libraries=visualization&callback=initMapsAPI&loading=async`;
                script.async = true;
                script.defer = true;
                script.onerror = () => console.error('Failed to load Google Maps API');
                document.head.appendChild(script);
            } catch (error) {
                console.error('Error loading Google Maps API key:', error);
            }
        }
        
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú API ÌÇ§ Í∞ÄÏ†∏Ïò§Í∏∞
        loadGoogleMapsAPI();
    </script>
    <!-- External CSS Files -->
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/components/header.css">
    <link rel="stylesheet" href="css/components/buttons.css">
    <link rel="stylesheet" href="css/components/charts.css">
    <link rel="stylesheet" href="css/components/cards.css">
    <link rel="stylesheet" href="css/components/modals.css">
    <link rel="stylesheet" href="css/sections/hero.css">
    <link rel="stylesheet" href="css/sections/market.css">
    <link rel="stylesheet" href="css/sections/tools.css">
    <link rel="stylesheet" href="css/sections/war-room.css">
    <link rel="stylesheet" href="css/sections/news.css">
    <!-- Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
</head>
<body>

    <!-- Header -->
    <header>
        <div class="logo">
            AAL<span>.</span>
            <div class="full-name">All About Logistics</div>
        </div>
        <nav>
            <ul>
                <li><a href="#market" class="active">Market Data</a></li>
                <li><a href="#war-room">War Room</a></li>
                <li><a href="#tools-apps">Tools</a></li>
                <li><a href="#news">Logistics News</a></li>
                <li><a href="#">Report & Insight</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <!-- Hero Section -->
        <section class="container hero">
            <h1>All Insights,<br><span>All About Logistics.</span></h1>
            <p>Í≤ΩÏ†ú ÏßÄÌëú, Î¨ºÎ•ò Îâ¥Ïä§, Í∑∏Î¶¨Í≥† Ïã§Î¨¥ Í≥ÑÏÇ∞Í∏∞ÍπåÏßÄ.<br>
            Î¨ºÎ•ò Ï†ÑÎ¨∏Í∞ÄÎ•º ÏúÑÌïú Îã® ÌïòÎÇòÏùò ÌÜµÌï© ÌîåÎû´Ìèº.</p>
        </section>

        <!-- Market Section -->
        <section id="market" class="container section-padding">
            <div class="section-header reveal">
                <h2 class="section-title">Market Data</h2>
                <span class="section-subtitle">LIVE INDICES & ANALYTICS</span>
            </div>

            <div class="market-controller reveal">
                <div class="tab-container">
                    <button class="tab-btn active" onclick="switchTab('economy')">Economy</button>
                    <button class="tab-btn" onclick="switchTab('logistics')">Logistics</button>
                </div>
            </div>

            <!-- Economy Panel (FX Focus) -->
            <div id="economy-panel" class="market-content active reveal">
                <div class="product-grid">
                    <aside class="product-sidebar">
                        <h3>Financial Products</h3>
                        <ul class="product-menu">
                            <li class="selected" onclick="switchProduct('exchange-rate')">Exchange Rate <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('interest-rates')">Interest Rates</li>
                            <li onclick="switchProduct('inflation')">Inflation (Î¨ºÍ∞Ä)</li>
                            <li onclick="switchProduct('gdp')">Ï£ºÏöî ÏßÄÌëú</li>
                            <li onclick="switchProduct('trade')">ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ</li>
                            <li onclick="switchProduct('gdp-growth')">Economy Growth Rate</li>
                            <li onclick="switchProduct('employment')">Í≥†Ïö© ÌÜµÍ≥Ñ</li>
                            <li>Commodities</li>
                            <li>Global Stocks</li>
                        </ul>
                    </aside>

                    <main class="tool-workspace">
                        <div class="tool-header">
                            <div>
                                <span style="font-size: 0.8rem; font-weight: 600; color: var(--accent-color); text-transform: uppercase;">Economy / Exchange Rate</span>
                                <h2>Exchange Rate</h2>
                                <p>Ï£ºÏöî ÌÜµÌôî Ïã§ÏãúÍ∞Ñ ÌôòÏú® Î∞è Î≥ÄÎèôÏÑ± Î∂ÑÏÑù</p>
                            </div>
                            <div class="live-badge"><div class="live-dot"></div> Live Market</div>
                        </div>

                        <!-- 1. GRAPH CONTROLS (New) -->
                        <div class="chart-controls">
                            <!-- Date Range & Period -->
                            <div class="filter-group">
                                <span class="filter-label">Period</span>
                                <input type="date" class="date-input" value="2023-11-01">
                                <span style="color:var(--text-sub)">~</span>
                                <input type="date" class="date-input" value="2024-05-20">
                                <div class="period-btns">
                                    <button class="period-btn">1W</button>
                                    <button class="period-btn">1M</button>
                                    <button class="period-btn active">3M</button>
                                    <button class="period-btn">1Y</button>
                                </div>
                            </div>
                            <!-- Currency Toggles -->
                            <div class="filter-group">
                                <span class="filter-label">Compare</span>
                                <div class="currency-chips">
                                    <button class="chip active" data-curr="USD" onclick="toggleCurrency('USD')">
                                        <div class="chip-dot"></div>USD
                                    </button>
                                    <button class="chip" data-curr="EUR" onclick="toggleCurrency('EUR')">
                                        <div class="chip-dot"></div>EUR
                                    </button>
                                    <button class="chip" data-curr="JPY" onclick="toggleCurrency('JPY')">
                                        <div class="chip-dot"></div>JPY
                                    </button>
                                    <button class="chip" data-curr="CNY" onclick="toggleCurrency('CNY')">
                                        <div class="chip-dot"></div>CNY
                                    </button>
                                    <button class="chip" data-curr="GBP" onclick="toggleCurrency('GBP')">
                                        <div class="chip-dot"></div>GBP
                                    </button>
                                    <button class="chip" data-curr="CHF" onclick="toggleCurrency('CHF')">
                                        <div class="chip-dot"></div>CHF
                                    </button>
                                    <button class="chip" data-curr="HKD" onclick="toggleCurrency('HKD')">
                                        <div class="chip-dot"></div>HKD
                                    </button>
                                    <button class="chip" data-curr="CAD" onclick="toggleCurrency('CAD')">
                                        <div class="chip-dot"></div>CAD
                                    </button>
                                    <button class="chip" data-curr="RUB" onclick="toggleCurrency('RUB')">
                                        <div class="chip-dot"></div>RUB
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Chart Header (Yahoo Finance Style) -->
                        <div class="chart-header" id="chart-header">
                            <div class="chart-title-section">
                                <h2 class="chart-main-title" id="chart-main-title">USD/KRW</h2>
                                <div class="chart-main-value" id="chart-main-value">-</div>
                                <div class="chart-change" id="chart-change">
                                    <span class="change-value" id="change-value">-</span>
                                    <span class="change-percent" id="change-percent">(-)</span>
                                </div>
                            </div>
                            <div class="chart-stats" id="chart-stats">
                                <div class="stat-item">
                                    <span class="stat-label">HIGH</span>
                                    <span class="stat-value" id="stat-high">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">LOW</span>
                                    <span class="stat-value" id="stat-low">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">AVERAGE</span>
                                    <span class="stat-value" id="stat-average">-</span>
                                </div>
                            </div>
                        </div>

                        <!-- 2. INTERACTIVE CHART (New) -->
                        <div class="chart-area" id="chart-container">
                            <svg class="chart-svg" viewBox="0 0 1200 400" preserveAspectRatio="none">
                                <!-- Grid Lines -->
                                <line x1="0" y1="350" x2="1200" y2="350" class="chart-grid-line" />
                                <line x1="0" y1="280" x2="1200" y2="280" class="chart-grid-line" />
                                <line x1="0" y1="210" x2="1200" y2="210" class="chart-grid-line" />
                                <line x1="0" y1="140" x2="1200" y2="140" class="chart-grid-line" />
                                <line x1="0" y1="70" x2="1200" y2="70" class="chart-grid-line" />
                                
                                <!-- Y-axis labels (generated via JS) -->
                                <g id="y-axis-labels"></g>
                                
                                <!-- Paths will be generated via JS -->
                                <path id="path-USD" class="chart-path visible" stroke="var(--c-usd)" d="" />
                                <path id="path-EUR" class="chart-path visible" stroke="var(--c-eur)" d="" />
                                <path id="path-JPY" class="chart-path visible" stroke="var(--c-jpy)" d="" />
                                <path id="path-CNY" class="chart-path visible" stroke="var(--c-cny)" d="" />
                                <path id="path-GBP" class="chart-path visible" stroke="var(--c-gbp)" d="" />
                                <path id="path-CHF" class="chart-path visible" stroke="var(--c-chf)" d="" />
                                <path id="path-HKD" class="chart-path visible" stroke="var(--c-hkd)" d="" />
                                <path id="path-CAD" class="chart-path visible" stroke="var(--c-cad)" d="" />
                                <path id="path-RUB" class="chart-path visible" stroke="var(--c-rub)" d="" />

                                <!-- X-axis labels (generated via JS) -->
                                <g id="x-axis-labels"></g>
                            </svg>
                        </div>
                        <!-- Tooltip is intentionally OUTSIDE chart container to avoid clipping by overflow/transform -->
                        <div class="chart-tooltip" id="chart-tooltip">
                            <div class="chart-tooltip-date" id="tooltip-date"></div>
                            <div id="tooltip-content"></div>
                        </div>

                        <!-- 3. CALCULATOR (Updated) -->
                        <div class="converter-box">
                            <div class="input-group">
                                <label>Amount</label>
                                <div class="input-wrapper">
                                    <input type="number" value="1" id="amount-from">
                                    <select class="currency-select" id="curr-from">
                                        <option value="USD">USD</option>
                                        <option value="EUR">EUR</option>
                                        <option value="JPY">JPY</option>
                                        <option value="CNY">CNY</option>
                                        <option value="GBP">GBP</option>
                                        <option value="CHF">CHF</option>
                                        <option value="HKD">HKD</option>
                                        <option value="CAD">CAD</option>
                                        <option value="RUB">RUB</option>
                                    </select>
                                </div>
                            </div>
                            <button class="swap-btn"><i class="fas fa-exchange-alt"></i></button>
                            <div class="input-group">
                                <label>Converted (KRW)</label>
                                <div class="input-wrapper">
                                    <input type="text" value="1,342.50" id="amount-to" readonly>
                                    <select class="currency-select">
                                        <option>KRW</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- 4. Currency Rates Table (New) -->
                        <div class="currency-rates-table">
                            <div class="currency-rates-header">
                                <h3>Ï£ºÏöî ÌÜµÌôîÎ≥Ñ ÌòÑÏû¨ ÌôòÏú®</h3>
                                <span style="font-size: 0.8rem; color: var(--text-sub);">KRW Í∏∞Ï§Ä</span>
                            </div>
                            <div class="currency-rates-grid" id="currency-rates-grid">
                                <!-- ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îê® -->
                            </div>
                        </div>

                    </main>
                </div>
            </div>

            <!-- Inflation Panel -->
            <div id="inflation-panel" class="market-content reveal" style="display: none;">
                <div class="product-grid">
                    <aside class="product-sidebar">
                        <h3>Financial Products</h3>
                        <ul class="product-menu">
                            <li onclick="switchProduct('exchange-rate')">Exchange Rate <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('interest-rates')">Interest Rates</li>
                            <li class="selected" onclick="switchProduct('inflation')">Inflation (Î¨ºÍ∞Ä) <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('gdp')">Ï£ºÏöî ÏßÄÌëú</li>
                            <li onclick="switchProduct('trade')">ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ</li>
                            <li onclick="switchProduct('gdp-growth')">Economy Growth Rate</li>
                            <li onclick="switchProduct('employment')">Í≥†Ïö© ÌÜµÍ≥Ñ</li>
                            <li>Commodities</li>
                            <li>Global Stocks</li>
                        </ul>
                    </aside>

                    <main class="tool-workspace">
                        <div class="tool-header">
                            <div>
                                <span style="font-size: 0.8rem; font-weight: 600; color: var(--accent-color); text-transform: uppercase;">Economy / Inflation</span>
                                <h2>Inflation (Î¨ºÍ∞Ä)</h2>
                                <p>ÏÜåÎπÑÏûêÎ¨ºÍ∞ÄÏßÄÏàò(CPI) Ï∂îÏù¥ Î∞è Ïù∏ÌîåÎ†àÏù¥ÏÖòÏú® Î∂ÑÏÑù</p>
                            </div>
                            <div class="live-badge"><div class="live-dot"></div> Live Market</div>
                        </div>

                        <div class="chart-controls">
                            <div class="filter-group">
                                <span class="filter-label">Period</span>
                                <input type="date" class="date-input inflation-date-input" id="inflation-start-date">
                                <span style="color:var(--text-sub)">~</span>
                                <input type="date" class="date-input inflation-date-input" id="inflation-end-date">
                                <div class="period-btns inflation-cycle-btns">
                                    <button class="period-btn inflation-cycle-btn active" data-cycle="M" title="Monthly: Monthly data">Monthly</button>
                                    <button class="period-btn inflation-cycle-btn" data-cycle="Q" title="Quarterly: Quarterly data">Quarterly</button>
                                </div>
                            </div>
                            <div class="filter-group">
                                <span class="filter-label">Ìï≠Î™©</span>
                                <div class="currency-chips">
                                    <button class="chip active" data-item="CPI_TOTAL" onclick="toggleInflationItem('CPI_TOTAL')">
                                        <div class="chip-dot"></div>Ï¥ùÏßÄÏàò
                                    </button>
                                    <button class="chip" data-item="CPI_FRESH" onclick="toggleInflationItem('CPI_FRESH')">
                                        <div class="chip-dot"></div>Ïã†ÏÑ†ÏãùÌíà
                                    </button>
                                    <button class="chip" data-item="CPI_INDUSTRIAL" onclick="toggleInflationItem('CPI_INDUSTRIAL')">
                                        <div class="chip-dot"></div>Í≥µÏóÖÏ†úÌíà
                                    </button>
                                </div>
                            </div>
                            <div class="filter-group">
                                <span class="filter-label">Íµ≠Í∞Ä ÎπÑÍµê</span>
                                <div class="country-chips" id="inflation-country-chips">
                                    <!-- ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ± -->
                                </div>
                            </div>
                        </div>

                        <div class="chart-header" id="inflation-chart-header">
                            <div class="chart-title-section">
                                <h2 class="chart-main-title" id="inflation-chart-main-title">ÏÜåÎπÑÏûêÎ¨ºÍ∞ÄÏßÄÏàò</h2>
                                <div class="chart-main-value" id="inflation-chart-main-value">-</div>
                                <div class="chart-change" id="inflation-chart-change">
                                    <span class="change-value" id="inflation-change-value">-</span>
                                    <span class="change-percent" id="inflation-change-percent">(-)</span>
                                </div>
                            </div>
                            <div class="chart-stats" id="inflation-chart-stats">
                                <div class="stat-item">
                                    <span class="stat-label">High</span>
                                    <span class="stat-value" id="inflation-stat-high">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Low</span>
                                    <span class="stat-value" id="inflation-stat-low">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Average</span>
                                    <span class="stat-value" id="inflation-stat-average">-</span>
                                </div>
                            </div>
                        </div>

                        <div class="chart-area" id="inflation-chart-container">
                            <svg class="chart-svg" id="inflation-chart-svg" viewBox="0 0 1200 400" preserveAspectRatio="none">
                                <line x1="0" y1="350" x2="1200" y2="350" class="chart-grid-line" />
                                <line x1="0" y1="280" x2="1200" y2="280" class="chart-grid-line" />
                                <line x1="0" y1="210" x2="1200" y2="210" class="chart-grid-line" />
                                <line x1="0" y1="140" x2="1200" y2="140" class="chart-grid-line" />
                                <line x1="0" y1="70" x2="1200" y2="70" class="chart-grid-line" />
                                <g id="inflation-y-axis-labels"></g>
                                <path id="path-inflation-CPI_TOTAL" class="chart-path visible" stroke="var(--c-cpi-total)" d="" />
                                <path id="path-inflation-CPI_FRESH" class="chart-path" stroke="var(--c-cpi-fresh)" d="" />
                                <path id="path-inflation-CPI_INDUSTRIAL" class="chart-path" stroke="var(--c-cpi-industrial)" d="" />
                                <g id="inflation-bar-chart"></g>
                                <g id="inflation-data-points"></g>
                                <g id="inflation-x-axis-labels"></g>
                            </svg>
                        </div>
                        <div class="chart-tooltip" id="inflation-chart-tooltip">
                            <div class="chart-tooltip-date" id="inflation-tooltip-date"></div>
                            <div id="inflation-tooltip-content"></div>
                        </div>
                    </main>
                </div>
            </div>

            <!-- GDP Panel -->
            <div id="gdp-panel" class="market-content reveal" style="display: none;">
                <div class="product-grid">
                    <aside class="product-sidebar" style="position: relative;">
                        <h3>Financial Products</h3>
                        <ul class="product-menu">
                            <li onclick="switchProduct('exchange-rate')">Exchange Rate <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('interest-rates')">Interest Rates</li>
                            <li onclick="switchProduct('inflation')">Inflation (Î¨ºÍ∞Ä)</li>
                            <li class="selected" onclick="switchProduct('gdp')">Ï£ºÏöî ÏßÄÌëú <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('trade')">ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ</li>
                            <li onclick="switchProduct('gdp-growth')">Economy Growth Rate</li>
                            <li onclick="switchProduct('employment')">Í≥†Ïö© ÌÜµÍ≥Ñ</li>
                            <li>Commodities</li>
                            <li>Global Stocks</li>
                        </ul>
                        
                        <!-- Flyout ÏÑúÎ∏åÎ©îÎâ¥ -->
                        <div id="gdp-submenu" class="gdp-flyout-menu">
                            <div class="gdp-submenu-header">
                                <h3>Ï£ºÏöî ÏßÄÌëú</h3>
                            </div>
                            <div class="gdp-submenu-items">
                                <div class="gdp-submenu-item">
                                    <button class="gdp-submenu-btn" data-indicator="10101" onclick="selectGDPFromSubmenu('10101')">
                                        <span class="submenu-item-name">Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞</span>
                                    </button>
                                </div>
                                <div class="gdp-submenu-item">
                                    <button class="gdp-submenu-btn" data-indicator="10102" onclick="selectGDPFromSubmenu('10102')">
                                        <span class="submenu-item-name">Íµ≠ÎØºÏ¥ùÏÜåÎìù</span>
                                    </button>
                                </div>
                                <div class="gdp-submenu-item">
                                    <button class="gdp-submenu-btn" data-indicator="10106" onclick="selectGDPFromSubmenu('10106')">
                                        <span class="submenu-item-name">1Ïù∏Îãπ Íµ≠ÎØºÏ¥ùÏÜåÎìù</span>
                                    </button>
                                </div>
                                <div class="gdp-submenu-item">
                                    <button class="gdp-submenu-btn" data-indicator="10107" onclick="selectGDPFromSubmenu('10107')">
                                        <span class="submenu-item-name">1Ïù∏Îãπ Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </aside>

                    <main class="tool-workspace">
                        <div class="tool-header">
                            <div>
                                <span style="font-size: 0.8rem; font-weight: 600; color: var(--accent-color); text-transform: uppercase;">Economy / Ï£ºÏöî ÏßÄÌëú</span>
                                <h2>Ï£ºÏöî ÏßÄÌëú</h2>
                                <p>Íµ≠ÎØºÍ≥ÑÏ†ï Ï£ºÏöî ÏßÄÌëú Ï∂îÏù¥ Î∂ÑÏÑù</p>
                            </div>
                            <div class="live-badge"><div class="live-dot"></div> Live Market</div>
                        </div>

                        <div class="chart-controls">
                            <div class="filter-group">
                                <span class="filter-label">Period</span>
                                <input type="number" class="date-input gdp-date-input" id="gdp-start-date" placeholder="ÏãúÏûë Ïó∞ÎèÑ" inputmode="numeric">
                                <span style="color:var(--text-sub)">~</span>
                                <input type="number" class="date-input gdp-date-input" id="gdp-end-date" placeholder="Ï¢ÖÎ£å Ïó∞ÎèÑ" inputmode="numeric">
                            </div>
                            <div class="filter-group">
                                <span class="filter-label">Currency</span>
                                <div class="currency-buttons gdp-panel-currency">
                                    <button class="currency-btn active" id="gdp-currency-krw" data-currency="KRW" onclick="switchGDPCurrencyInPanel('KRW')">KRW</button>
                                    <button class="currency-btn" id="gdp-currency-usd" data-currency="USD" onclick="switchGDPCurrencyInPanel('USD')">USD</button>
                                </div>
                            </div>
                        </div>

                        <div class="chart-header" id="gdp-chart-header">
                            <div class="chart-title-section">
                                <h2 class="chart-main-title" id="gdp-chart-main-title">Ï£ºÏöî ÏßÄÌëú</h2>
                                <div class="chart-main-value" id="gdp-chart-main-value">-</div>
                                <div class="chart-change" id="gdp-chart-change">
                                    <span class="change-value" id="gdp-change-value">-</span>
                                    <span class="change-percent" id="gdp-change-percent">(-)</span>
                                </div>
                            </div>
                        </div>

                        <div class="chart-area" id="gdp-chart-container">
                            <svg class="chart-svg" id="gdp-chart-svg" viewBox="0 0 1200 400" preserveAspectRatio="none">
                                <line x1="0" y1="350" x2="1200" y2="350" class="chart-grid-line" />
                                <line x1="0" y1="280" x2="1200" y2="280" class="chart-grid-line" />
                                <line x1="0" y1="210" x2="1200" y2="210" class="chart-grid-line" />
                                <line x1="0" y1="140" x2="1200" y2="140" class="chart-grid-line" />
                                <line x1="0" y1="70" x2="1200" y2="70" class="chart-grid-line" />
                                <g id="gdp-y-axis-labels"></g>
                                <!-- GDP(200Y101) is rendered as annual bars; line paths are unused -->
                                <path id="path-gdp-unused" class="chart-path" stroke="var(--c-gdp-total)" d="" />
                                <g id="gdp-bar-chart"></g>
                                <g id="gdp-data-points"></g>
                                <g id="gdp-x-axis-labels"></g>
                            </svg>
                        </div>
                        <div class="chart-tooltip" id="gdp-chart-tooltip">
                            <div class="chart-tooltip-date" id="gdp-tooltip-date"></div>
                            <div id="gdp-tooltip-content"></div>
                        </div>
                    </main>
                </div>
            </div>

            <!-- Interest Rates Panel -->
            <div id="interest-rates-panel" class="market-content reveal" style="display: none;">
                <div class="product-grid">
                    <aside class="product-sidebar">
                        <h3>Financial Products</h3>
                        <ul class="product-menu">
                            <li onclick="switchProduct('exchange-rate')">Exchange Rate <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li class="selected" onclick="switchProduct('interest-rates')">Interest Rates <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('inflation')">Inflation (Î¨ºÍ∞Ä)</li>
                            <li onclick="switchProduct('gdp')">Ï£ºÏöî ÏßÄÌëú</li>
                            <li onclick="switchProduct('trade')">ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ</li>
                            <li onclick="switchProduct('gdp-growth')">Economy Growth Rate</li>
                            <li onclick="switchProduct('employment')">Í≥†Ïö© ÌÜµÍ≥Ñ</li>
                            <li>Commodities</li>
                            <li>Global Stocks</li>
                        </ul>
                    </aside>

                    <main class="tool-workspace">
                        <div class="tool-header">
                            <div>
                                <span style="font-size: 0.8rem; font-weight: 600; color: var(--accent-color); text-transform: uppercase;">Economy / Interest Rates</span>
                                <h2>Interest Rates</h2>
                                <p>Ï£ºÏöîÍµ≠ Í∏∞Ï§ÄÍ∏àÎ¶¨ Î≥ÄÎèô Ï∂îÏù¥ Î∂ÑÏÑù</p>
                            </div>
                            <div class="live-badge"><div class="live-dot"></div> Live Market</div>
                        </div>

                        <!-- 1. GRAPH CONTROLS -->
                        <div class="chart-controls">
                            <!-- Date Range & Cycle Selection -->
                            <div class="filter-group">
                                <span class="filter-label">Period</span>
                                <input type="month" class="date-input interest-date-input" id="interest-start-date" value="2023-11">
                                <span style="color:var(--text-sub)">~</span>
                                <input type="month" class="date-input interest-date-input" id="interest-end-date" value="2024-05">
                                <div class="period-btns interest-cycle-btns">
                                    <button class="period-btn interest-cycle-btn active" data-cycle="M" title="Monthly: Monthly data">Monthly</button>
                                    <button class="period-btn interest-cycle-btn" data-cycle="Q" title="Quarterly: Quarterly data">Quarterly</button>
                                </div>
                            </div>
                            <!-- Country Selection Chips -->
                            <div class="filter-group">
                                <span class="filter-label">Compare</span>
                                <div class="country-chips" id="interest-country-chips">
                                    <!-- ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ± -->
                                </div>
                            </div>
                        </div>

                        <!-- Chart Header (Yahoo Finance Style) -->
                        <div class="chart-header" id="interest-chart-header">
                            <div class="chart-title-section">
                                <h2 class="chart-main-title" id="interest-chart-main-title">Interest Rate</h2>
                                <div class="chart-main-value" id="interest-chart-main-value">-</div>
                                <div class="chart-change" id="interest-chart-change">
                                    <span class="change-value" id="interest-change-value">-</span>
                                    <span class="change-percent" id="interest-change-percent">(-)</span>
                                </div>
                            </div>
                            <div class="chart-stats" id="interest-chart-stats">
                                <div class="stat-item">
                                    <span class="stat-label">High</span>
                                    <span class="stat-value" id="interest-stat-high">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Low</span>
                                    <span class="stat-value" id="interest-stat-low">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Average</span>
                                    <span class="stat-value" id="interest-stat-average">-</span>
                                </div>
                            </div>
                        </div>

                        <!-- 2. INTERACTIVE CHART -->
                        <div class="chart-area" id="interest-chart-container">
                            <svg class="chart-svg" id="interest-chart-svg" viewBox="0 0 1200 400" preserveAspectRatio="none">
                                <!-- Grid Lines -->
                                <line x1="0" y1="350" x2="1200" y2="350" class="chart-grid-line" />
                                <line x1="0" y1="280" x2="1200" y2="280" class="chart-grid-line" />
                                <line x1="0" y1="210" x2="1200" y2="210" class="chart-grid-line" />
                                <line x1="0" y1="140" x2="1200" y2="140" class="chart-grid-line" />
                                <line x1="0" y1="70" x2="1200" y2="70" class="chart-grid-line" />
                                
                                <!-- Y-axis labels (generated via JS) -->
                                <g id="interest-y-axis-labels"></g>
                                
                                <!-- Bar chart (for single unit periods) -->
                                <g id="interest-bar-chart"></g>
                                
                                <!-- Line chart paths (for multiple countries) -->
                                <!-- ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±: path-interest-[COUNTRY_CODE] -->
                                
                                <!-- Data points (for line chart) -->
                                <g id="interest-data-points"></g>

                                <!-- X-axis labels (generated via JS) -->
                                <g id="interest-x-axis-labels"></g>
                            </svg>
                        </div>
                        <!-- Tooltip -->
                        <div class="chart-tooltip" id="interest-chart-tooltip">
                            <div class="chart-tooltip-date" id="interest-tooltip-date"></div>
                            <div id="interest-tooltip-content"></div>
                        </div>
                    </main>
                </div>
            </div>

            <!-- Trade Statistics Panel -->
            <div id="trade-panel" class="market-content reveal" style="display: none;">
                <div class="product-grid">
                    <aside class="product-sidebar">
                        <h3>Financial Products</h3>
                        <ul class="product-menu">
                            <li onclick="switchProduct('exchange-rate')">Exchange Rate <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('interest-rates')">Interest Rates</li>
                            <li onclick="switchProduct('inflation')">Inflation (Î¨ºÍ∞Ä)</li>
                            <li onclick="switchProduct('gdp')">Ï£ºÏöî ÏßÄÌëú</li>
                            <li class="selected" onclick="switchProduct('trade')">ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('employment')">Í≥†Ïö© ÌÜµÍ≥Ñ</li>
                            <li>Commodities</li>
                            <li>Global Stocks</li>
                        </ul>
                    </aside>

                    <main class="tool-workspace">
                        <div class="tool-header">
                            <div>
                                <span style="font-size: 0.8rem; font-weight: 600; color: var(--accent-color); text-transform: uppercase;">Economy / ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ</span>
                                <h2>ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ</h2>
                                <p>ÌïúÍµ≠ ÏàòÏ∂úÏûÖ Í∏àÏï° Î∞è Î¨¥Ïó≠ÏàòÏßÄ Ï∂îÏù¥ Î∂ÑÏÑù</p>
                            </div>
                            <div class="live-badge"><div class="live-dot"></div> Live Market</div>
                        </div>

                        <!-- Chart Controls -->
                        <div class="chart-controls">
                            <div class="filter-group">
                                <span class="filter-label">Period</span>
                                <input type="date" class="date-input trade-date-input" id="trade-start-date">
                                <span style="color:var(--text-sub)">~</span>
                                <input type="date" class="date-input trade-date-input" id="trade-end-date">
                                <div class="period-btns trade-cycle-btns">
                                    <button class="period-btn trade-cycle-btn active" data-cycle="M" title="Monthly (ÏõîÍ∞Ñ): ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞">ÏõîÎ≥Ñ</button>
                                    <button class="period-btn trade-cycle-btn" data-cycle="Q" title="Quarterly (Î∂ÑÍ∏∞Î≥Ñ): Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞">Î∂ÑÍ∏∞Î≥Ñ</button>
                                </div>
                                <span class="filter-label" style="margin-left: 1.5rem; display: inline-flex; align-items: center;">Indicators</span>
                                <div class="chip-group" style="margin-left: 0.5rem; display: inline-flex;">
                                    <button class="chip active" id="chip-trade-export" data-indicator="EXPORT" onclick="toggleTradeIndicator('EXPORT')">
                                        <div class="chip-dot"></div>ÏàòÏ∂ú
                                    </button>
                                    <button class="chip active" id="chip-trade-import" data-indicator="IMPORT" onclick="toggleTradeIndicator('IMPORT')">
                                        <div class="chip-dot"></div>ÏàòÏûÖ
                                    </button>
                                    <button class="chip" id="chip-trade-balance" data-indicator="BALANCE" onclick="toggleTradeIndicator('BALANCE')">
                                        <div class="chip-dot"></div>Î¨¥Ïó≠ÏàòÏßÄ
                                    </button>
                                </div>
                            </div>
                            <div class="filter-group">
                                <span class="filter-label">Country</span>
                                <div class="country-chips" id="trade-country-chips">
                                    <!-- ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ± -->
                                </div>
                            </div>
                        </div>

                        <!-- Chart Header -->
                        <div class="chart-header" id="trade-chart-header">
                            <div class="chart-title-section">
                                <h2 class="chart-main-title" id="trade-chart-main-title">ÏàòÏ∂úÏûÖÏã§Ï†Å</h2>
                            </div>
                        </div>

                        <!-- Interactive Chart -->
                        <div class="chart-area" id="trade-chart-container">
                            <svg class="chart-svg" id="trade-chart-svg" viewBox="0 0 1200 400" preserveAspectRatio="none">
                                <!-- Grid Lines -->
                                <line x1="0" y1="350" x2="1200" y2="350" class="chart-grid-line" />
                                <line x1="0" y1="280" x2="1200" y2="280" class="chart-grid-line" />
                                <line x1="0" y1="210" x2="1200" y2="210" class="chart-grid-line" />
                                <line x1="0" y1="140" x2="1200" y2="140" class="chart-grid-line" />
                                <line x1="0" y1="70" x2="1200" y2="70" class="chart-grid-line" />
                                
                                <!-- Y-axis labels - Left (Í∏àÏï°) -->
                                <g id="trade-y-axis-labels"></g>
                                
                                <!-- Y-axis labels - Right (Ï¶ùÍ∞êÎ•†) -->
                                <g id="trade-y-axis-labels-right"></g>
                                
                                <!-- Bar chart groups (ÏàòÏ∂ú/ÏàòÏûÖ Í∏àÏï°) -->
                                <g id="trade-bars-group"></g>
                                
                                <!-- Line chart paths (Ï¶ùÍ∞êÎ•†) -->
                                <path id="path-trade-export-growth" class="chart-path visible" stroke="var(--c-trade-growth-export)" d="" />
                                <path id="path-trade-import-growth" class="chart-path visible" stroke="var(--c-trade-growth-import)" d="" />
                                
                                <!-- Trade Balance Line (Î¨¥Ïó≠ÏàòÏßÄ) -->
                                <path id="path-trade-balance" class="chart-path visible" stroke="var(--c-trade-balance-surplus)" d="" style="display: none;" />
                                
                                <!-- Data points (for line chart) -->
                                <g id="trade-data-points"></g>

                                <!-- X-axis labels (generated via JS) -->
                                <g id="trade-x-axis-labels"></g>
                            </svg>
                        </div>
                        <!-- Tooltip -->
                        <div class="chart-tooltip" id="trade-chart-tooltip">
                            <div class="chart-tooltip-date" id="trade-tooltip-date"></div>
                            <div id="trade-tooltip-content"></div>
                        </div>
                    </main>
                </div>
            </div>

            <!-- Employment Statistics Panel -->
            <div id="employment-panel" class="market-content reveal" style="display: none;">
                <div class="product-grid">
                    <aside class="product-sidebar">
                        <h3>Financial Products</h3>
                        <ul class="product-menu">
                            <li onclick="switchProduct('exchange-rate')">Exchange Rate <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('interest-rates')">Interest Rates</li>
                            <li onclick="switchProduct('inflation')">Inflation (Î¨ºÍ∞Ä)</li>
                            <li onclick="switchProduct('gdp')">Ï£ºÏöî ÏßÄÌëú</li>
                            <li onclick="switchProduct('trade')">ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ</li>
                            <li class="selected" onclick="switchProduct('employment')">Í≥†Ïö© ÌÜµÍ≥Ñ <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li>Commodities</li>
                            <li>Global Stocks</li>
                        </ul>
                    </aside>

                    <main class="tool-workspace">
                        <div class="tool-header">
                            <div>
                                <span style="font-size: 0.8rem; font-weight: 600; color: var(--accent-color); text-transform: uppercase;">Economy / Í≥†Ïö© ÌÜµÍ≥Ñ</span>
                                <h2>Í≥†Ïö© ÌÜµÍ≥Ñ</h2>
                                <p>Ïã§ÏóÖÎ•†, Í≥†Ïö©Î•†, Ï∑®ÏóÖÏûê Ïàò Îì± ÎÖ∏ÎèôÏãúÏû• ÎèôÌñ• Î∂ÑÏÑù</p>
                            </div>
                            <div class="live-badge"><div class="live-dot"></div> Live Market</div>
                        </div>

                        <!-- Chart Controls -->
                        <div class="chart-controls">
                            <div class="filter-group">
                                <span class="filter-label">Period</span>
                                <input type="date" class="date-input employment-date-input" id="employment-start-date">
                                <span style="color:var(--text-sub)">~</span>
                                <input type="date" class="date-input employment-date-input" id="employment-end-date">
                                <div class="period-btns employment-cycle-btns">
                                    <button class="period-btn employment-cycle-btn active" data-cycle="M" title="Monthly (ÏõîÍ∞Ñ): ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞">ÏõîÎ≥Ñ</button>
                                    <button class="period-btn employment-cycle-btn" data-cycle="Q" title="Quarterly (Î∂ÑÍ∏∞Î≥Ñ): Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞">Î∂ÑÍ∏∞Î≥Ñ</button>
                                </div>
                            </div>
                            <div class="filter-group">
                                <span class="filter-label">Indicators</span>
                                <div class="chip-group">
                                    <button class="chip active" id="chip-employment-unemployment" data-indicator="UNEMPLOYMENT_RATE" onclick="toggleEmploymentIndicator('UNEMPLOYMENT_RATE')">
                                        <div class="chip-dot"></div>Ïã§ÏóÖÎ•†
                                    </button>
                                    <button class="chip active" id="chip-employment-employment" data-indicator="EMPLOYMENT_RATE" onclick="toggleEmploymentIndicator('EMPLOYMENT_RATE')">
                                        <div class="chip-dot"></div>Í≥†Ïö©Î•†
                                    </button>
                                    <button class="chip" id="chip-employment-employed" data-indicator="EMPLOYED" onclick="toggleEmploymentIndicator('EMPLOYED')">
                                        <div class="chip-dot"></div>Ï∑®ÏóÖÏûê Ïàò
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Chart Header -->
                        <div class="chart-header" id="employment-chart-header">
                            <div class="chart-title-section">
                                <h2 class="chart-main-title" id="employment-chart-main-title">Ïã§ÏóÖÎ•†</h2>
                                <div class="chart-main-value" id="employment-chart-main-value">-</div>
                                <div class="chart-change" id="employment-chart-change">
                                    <span class="change-value" id="employment-change-value">-</span>
                                    <span class="change-percent" id="employment-change-percent">(-)</span>
                                </div>
                            </div>
                            <div class="chart-stats" id="employment-chart-stats">
                                <div class="stat-item">
                                    <span class="stat-label">ÏµúÍ≥†</span>
                                    <span class="stat-value" id="employment-stat-high">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">ÏµúÏ†Ä</span>
                                    <span class="stat-value" id="employment-stat-low">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">ÌèâÍ∑†</span>
                                    <span class="stat-value" id="employment-stat-average">-</span>
                                </div>
                            </div>
                        </div>

                        <!-- Interactive Chart -->
                        <div class="chart-area" id="employment-chart-container">
                            <svg class="chart-svg" id="employment-chart-svg" viewBox="0 0 1200 400" preserveAspectRatio="none">
                                <!-- Grid Lines -->
                                <line x1="0" y1="350" x2="1200" y2="350" class="chart-grid-line" />
                                <line x1="0" y1="280" x2="1200" y2="280" class="chart-grid-line" />
                                <line x1="0" y1="210" x2="1200" y2="210" class="chart-grid-line" />
                                <line x1="0" y1="140" x2="1200" y2="140" class="chart-grid-line" />
                                <line x1="0" y1="70" x2="1200" y2="70" class="chart-grid-line" />
                                
                                <!-- Y-axis labels (generated via JS) -->
                                <g id="employment-y-axis-labels"></g>
                                
                                <!-- Line chart paths -->
                                <path id="path-employment-unemployment" class="chart-path visible" stroke="var(--c-employment-unemployment)" d="" />
                                <path id="path-employment-employment" class="chart-path visible" stroke="var(--c-employment-employment)" d="" />
                                <path id="path-employment-employed" class="chart-path visible" stroke="var(--c-employment-employed)" d="" />
                                
                                <!-- Data points (for line chart) -->
                                <g id="employment-data-points"></g>

                                <!-- X-axis labels (generated via JS) -->
                                <g id="employment-x-axis-labels"></g>
                            </svg>
                        </div>
                        <!-- Tooltip -->
                        <div class="chart-tooltip" id="employment-chart-tooltip">
                            <div class="chart-tooltip-date" id="employment-tooltip-date"></div>
                            <div id="employment-tooltip-content"></div>
                        </div>
                    </main>
                </div>
            </div>

            <!-- Economy Growth Rate Panel -->
            <div id="gdp-growth-panel" class="market-content reveal" style="display: none;">
                <div class="product-grid">
                    <aside class="product-sidebar">
                        <h3>Financial Products</h3>
                        <ul class="product-menu">
                            <li onclick="switchProduct('exchange-rate')">Exchange Rate <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('interest-rates')">Interest Rates</li>
                            <li onclick="switchProduct('inflation')">Inflation (Î¨ºÍ∞Ä)</li>
                            <li onclick="switchProduct('gdp')">Ï£ºÏöî ÏßÄÌëú</li>
                            <li onclick="switchProduct('trade')">ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ</li>
                            <li class="selected" onclick="switchProduct('gdp-growth')">Economy Growth Rate <i class="fas fa-chevron-right" style="font-size:0.7rem"></i></li>
                            <li onclick="switchProduct('employment')">Í≥†Ïö© ÌÜµÍ≥Ñ</li>
                            <li>Commodities</li>
                            <li>Global Stocks</li>
                        </ul>
                    </aside>

                    <main class="tool-workspace">
                        <div class="tool-header">
                            <div>
                                <span style="font-size: 0.8rem; font-weight: 600; color: var(--accent-color); text-transform: uppercase;">Economy / Economy Growth Rate</span>
                                <h2>Economy Growth Rate</h2>
                                <p>Íµ≠Ï†ú Ï£ºÏöîÍµ≠ Í≤ΩÏ†úÏÑ±Ïû•Î•† Ï∂îÏù¥ Î∂ÑÏÑù</p>
                            </div>
                            <div class="live-badge"><div class="live-dot"></div> Live Market</div>
                        </div>

                        <!-- Chart Controls -->
                        <div class="chart-controls">
                            <div class="filter-group">
                                <span class="filter-label">Period</span>
                                <input type="date" class="date-input gdp-growth-date-input" id="gdp-growth-start-date">
                                <span style="color:var(--text-sub)">~</span>
                                <input type="date" class="date-input gdp-growth-date-input" id="gdp-growth-end-date">
                                <div class="period-btns gdp-growth-cycle-btns">
                                    <button class="period-btn gdp-growth-cycle-btn active" data-cycle="Q" title="Quarterly: Quarterly data">Quarterly</button>
                                </div>
                            </div>
                            <div class="filter-group">
                                <span class="filter-label">Country</span>
                                <div class="country-chips" id="gdp-growth-country-chips">
                                    <!-- ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ± -->
                                </div>
                            </div>
                        </div>

                        <!-- Chart Header -->
                        <div class="chart-header" id="gdp-growth-chart-header">
                            <div class="chart-title-section">
                                <h2 class="chart-main-title" id="gdp-growth-chart-main-title">Economy Growth Rate</h2>
                                <div class="chart-main-value" id="gdp-growth-chart-main-value">-</div>
                            </div>
                            <div class="chart-stats" id="gdp-growth-chart-stats">
                                <div class="stat-item">
                                    <span class="stat-label">High</span>
                                    <span class="stat-value" id="gdp-growth-stat-high">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Low</span>
                                    <span class="stat-value" id="gdp-growth-stat-low">-</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Average</span>
                                    <span class="stat-value" id="gdp-growth-stat-average">-</span>
                                </div>
                            </div>
                        </div>

                        <!-- Interactive Chart -->
                        <div class="chart-area" id="gdp-growth-chart-container">
                            <svg class="chart-svg" id="gdp-growth-chart-svg" viewBox="0 0 1200 400" preserveAspectRatio="none">
                                <!-- Grid Lines -->
                                <line x1="0" y1="350" x2="1200" y2="350" class="chart-grid-line" />
                                <line x1="0" y1="280" x2="1200" y2="280" class="chart-grid-line" />
                                <line x1="0" y1="210" x2="1200" y2="210" class="chart-grid-line" />
                                <line x1="0" y1="140" x2="1200" y2="140" class="chart-grid-line" />
                                <line x1="0" y1="70" x2="1200" y2="70" class="chart-grid-line" />
                                
                                <!-- Y-axis labels (generated via JS) -->
                                <g id="gdp-growth-y-axis-labels"></g>
                                
                                <!-- Line chart paths -->
                                <g id="gdp-growth-paths-group"></g>
                                
                                <!-- Data points (for line chart) -->
                                <g id="gdp-growth-data-points"></g>

                                <!-- X-axis labels (generated via JS) -->
                                <g id="gdp-growth-x-axis-labels"></g>
                            </svg>
                        </div>
                        <!-- Tooltip -->
                        <div class="chart-tooltip" id="gdp-growth-chart-tooltip">
                            <div class="chart-tooltip-date" id="gdp-growth-tooltip-date"></div>
                            <div id="gdp-growth-tooltip-content"></div>
                        </div>
                    </main>
                </div>
            </div>

            <!-- Logistics Panel -->
            <div id="logistics-panel" class="market-content reveal">
                <div class="product-grid">
                    <aside class="product-sidebar">
                        <h3>Logistics Indices</h3>
                        <ul class="product-menu">
                            <li class="selected">SCFI (Shanghai)</li>
                            <li>BDI (Baltic Dry)</li>
                            <li>NCFI (Ningbo)</li>
                        </ul>
                    </aside>
                    <main class="tool-workspace" style="display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; min-height:400px;">
                        <i class="fas fa-ship" style="font-size:3rem; color:#333; margin-bottom:1.5rem;"></i>
                        <h2 style="margin-bottom:0.5rem;">Logistics Indices</h2>
                        <p style="color:var(--text-sub);">Ïö¥ÏûÑ ÏßÄÏàò Îç∞Ïù¥ÌÑ∞Î•º ÌôïÏù∏ÌïòÎ†§Î©¥ Î©îÎâ¥Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
                    </main>
                </div>
            </div>
        </section>

        <!-- Tools Section -->
        <section id="tools-apps" class="container section-padding">
            <div class="section-header reveal">
                <h2 class="section-title">Smart Tools</h2>
                <span class="section-subtitle">FOR LOGISTICS EXPERTS</span>
            </div>
            <div class="tools-grid reveal">
                <div class="tool-app-card">
                    <div class="tool-icon-circle"><i class="fas fa-cubes"></i></div>
                    <div class="tool-content">
                        <h3>CBM Í≥ÑÏÇ∞Í∏∞</h3>
                        <p>Ïª®ÌÖåÏù¥ÎÑà Ï†ÅÏû¨ ÏãúÎÆ¨Î†àÏù¥ÏÖò Î∞è ÏµúÏ†Å ÏàòÎüâ Í≥ÑÏÇ∞</p>
                    </div>
                    <div class="tool-arrow"><i class="fas fa-arrow-right"></i></div>
                </div>
                <div class="tool-app-card">
                    <div class="tool-icon-circle"><i class="fas fa-calculator"></i></div>
                    <div class="tool-content">
                        <h3>Í¥ÄÏÑ∏ Í≥ÑÏÇ∞Í∏∞</h3>
                        <p>HS Code Í∏∞Î∞ò ÏòàÏÉÅ Í¥ÄÏÑ∏ Î∞è Î∂ÄÍ∞ÄÏÑ∏ ÏÇ∞Ï∂ú</p>
                    </div>
                    <div class="tool-arrow"><i class="fas fa-arrow-right"></i></div>
                </div>
                <div class="tool-app-card">
                    <div class="tool-icon-circle"><i class="fas fa-search"></i></div>
                    <div class="tool-content">
                        <h3>HS Code Ï∞æÍ∏∞</h3>
                        <p>ÌíàÎ™©Î™Ö ÏûÖÎ†•ÏúºÎ°ú Ï†ïÌôïÌïú HS Code Í≤ÄÏÉâ</p>
                    </div>
                    <div class="tool-arrow"><i class="fas fa-arrow-right"></i></div>
                </div>
            </div>
        </section>

        <!-- War Room Section -->
        <section id="war-room" class="container section-padding">
            <div class="section-header reveal">
                <h2 class="section-title">War Room</h2>
                <span class="section-subtitle">GLOBAL ALARM & SUPPLY CHAIN RISK</span>
            </div>

            <div class="war-room-container reveal" style="display: flex; gap: 20px; height: calc(100vh - 300px); min-height: 600px;">
                <!-- Google Maps Container -->
                <div id="google-map-container" style="flex: 3; border-radius: 16px; overflow: hidden; border: 1px solid var(--border-color); background: var(--card-bg); position: relative;">
                    <div id="map-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--text-sub); z-index: 1;">
                        <div style="text-align: center;">
                            <div style="font-size: 1.2rem; margin-bottom: 10px;">Loading Map...</div>
                            <div style="font-size: 0.9rem;">Initializing Google Maps</div>
                        </div>
                    </div>
                </div>
                
                <!-- Critical Alerts Sidebar -->
                <div class="card-bg" style="flex: 1; padding: 20px; display: flex; flex-direction: column; border-radius: 16px; border: 1px solid var(--border-color);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; font-size: 1.2rem;">Critical Alerts</h3>
                        <div id="alert-status" style="font-size: 0.75rem; color: var(--text-sub);">
                            <span id="alert-count">0</span> alerts
                        </div>
                    </div>
                    
                    <!-- View Toggle -->
                    <div class="view-toggle">
                        <button class="view-btn active" onclick="switchView('list')">üìã Î¶¨Ïä§Ìä∏</button>
                        <button class="view-btn" onclick="switchView('timeline')">üìÖ ÌÉÄÏûÑÎùºÏù∏</button>
                        <button class="view-btn" onclick="switchView('country')">üåç Íµ≠Í∞ÄÎ≥Ñ</button>
                    </div>
                    
                    <!-- Alert Controls -->
                    <div class="alert-controls">
                        <div class="control-group">
                            <label class="control-label">ÏúÑÌóòÎèÑ ÌïÑÌÑ∞</label>
                            <div class="filter-buttons">
                                <button class="filter-btn active" data-severity="all" onclick="filterBySeverity('all')">Ï†ÑÏ≤¥</button>
                                <button class="filter-btn" data-severity="extreme" onclick="filterBySeverity('extreme')">EXTREME</button>
                                <button class="filter-btn" data-severity="severe" onclick="filterBySeverity('severe')">SEVERE</button>
                                <button class="filter-btn" data-severity="high" onclick="filterBySeverity('high')">HIGH</button>
                            </div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Ïπ¥ÌÖåÍ≥†Î¶¨</label>
                            <select class="control-select" id="category-filter" onchange="applyFilters()">
                                <option value="all">Ï†ÑÏ≤¥</option>
                                <option value="Material Conflict">Material Conflict</option>
                                <option value="Verbal Conflict">Verbal Conflict</option>
                                <option value="Material Cooperation">Material Cooperation</option>
                                <option value="Verbal Cooperation">Verbal Cooperation</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Ï†ïÎ†¨</label>
                            <select class="control-select" id="sort-select" onchange="applyFilters()">
                                <option value="severity">ÏúÑÌóòÎèÑ ÎÜíÏùÄ Ïàú</option>
                                <option value="recent">ÏµúÏã† Ïàú</option>
                                <option value="mentions">Ïñ∏Í∏â ÎßéÏùÄ Ïàú</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- GoldsteinScale Legend -->
                    <div class="severity-legend">
                        <div class="legend-title">
                            GoldsteinScale Guide
                            <span style="cursor: help;" title="Ïù¥Î≤§Ìä∏Ïùò Ï§ëÏöîÎèÑÏôÄ ÏúÑÌóòÏÑ±ÏùÑ ÎÇòÌÉÄÎÉÖÎãàÎã§">‚ÑπÔ∏è</span>
                        </div>
                        <div class="legend-items">
                            <div class="legend-item">
                                <span class="legend-badge extreme">‚ö†Ô∏è EXTREME</span>
                                <span class="legend-range">-10.0 ~ -8.0</span>
                                <span class="legend-desc">Ï†ÑÏüÅ, ÎåÄÎüâÏÇ¥ÏÉÅ</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-badge severe">üî¥ SEVERE</span>
                                <span class="legend-range">-7.9 ~ -6.0</span>
                                <span class="legend-desc">Íµ∞ÏÇ¨Í≥µÍ≤©, Ìè≠Î†•</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-badge high">üü† HIGH</span>
                                <span class="legend-range">-5.9 ~ -4.0</span>
                                <span class="legend-desc">Ï§ëÍ∞Ñ Í∞àÎì±</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-badge moderate">üü° MODERATE</span>
                                <span class="legend-range">-3.9 ~ -2.0</span>
                                <span class="legend-desc">Í≤ΩÎØ∏Ìïú Í∞àÎì±</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-badge low">‚ÑπÔ∏è LOW</span>
                                <span class="legend-range">-1.9 Ïù¥Ìïò</span>
                                <span class="legend-desc">Ï†ïÎ≥¥ÏÑ±</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- List View -->
                    <div id="alert-items-list" class="list-view active" style="overflow-y: auto; flex: 1; display: flex; flex-direction: column; gap: 8px;">
                        <div style="text-align: center; color: var(--text-sub); padding: 40px 20px;">
                            <div style="font-size: 0.9rem;">Loading alerts...</div>
                        </div>
                    </div>
                    
                    <!-- Timeline View -->
                    <div id="alert-timeline-view" class="timeline-view">
                        <div style="text-align: center; color: var(--text-sub); padding: 40px 20px;">
                            <div style="font-size: 0.9rem;">Loading timeline...</div>
                        </div>
                    </div>
                    
                    <!-- Country Dashboard -->
                    <div id="alert-country-dashboard" class="country-dashboard">
                        <div style="text-align: center; color: var(--text-sub); padding: 40px 20px;">
                            <div style="font-size: 0.9rem;">Loading country data...</div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                        <div id="last-updated" style="font-size: 0.75rem; color: var(--text-sub); text-align: center;">
                            Last Updated: --
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Alert Detail Modal -->
        <div id="alert-detail-modal" class="alert-modal-overlay">
            <div class="alert-modal">
                <div class="modal-header">
                    <div class="modal-severity-info">
                        <div id="modal-severity-badge" class="modal-severity-badge"></div>
                        <div id="modal-severity-meaning" class="modal-severity-meaning"></div>
                    </div>
                    <button class="modal-close-btn" onclick="closeAlertModal()">‚úï</button>
                </div>
                <div class="modal-body">
                    <div class="modal-section">
                        <h2 id="modal-event-title" class="modal-event-title"></h2>
                        <div class="modal-meta-grid">
                            <div class="modal-meta-item">
                                <span>üìÖ</span>
                                <span id="modal-event-date"></span>
                            </div>
                            <div class="modal-meta-item">
                                <span>üìç</span>
                                <span id="modal-event-location"></span>
                            </div>
                            <div class="modal-meta-item">
                                <span>üè∑Ô∏è</span>
                                <span id="modal-event-category"></span>
                            </div>
                            <div class="modal-meta-item">
                                <span>üî¢</span>
                                <span id="modal-event-code"></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">ÌñâÏúÑÏûê Í¥ÄÍ≥Ñ</div>
                        <div class="modal-actors">
                            <div class="modal-actor-card">
                                <div class="modal-actor-flag" id="modal-actor1-flag">üåê</div>
                                <div class="modal-actor-name" id="modal-actor1-name"></div>
                                <div class="modal-actor-role">Actor 1</div>
                            </div>
                            <div class="modal-relationship">
                                <div class="modal-relationship-arrow">‚Üí</div>
                                <div class="modal-relationship-type" id="modal-relationship-type"></div>
                            </div>
                            <div class="modal-actor-card">
                                <div class="modal-actor-flag" id="modal-actor2-flag">üåê</div>
                                <div class="modal-actor-name" id="modal-actor2-name"></div>
                                <div class="modal-actor-role">Actor 2</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">ÌÜµÍ≥Ñ Ï†ïÎ≥¥</div>
                        <div class="modal-stats-grid">
                            <div class="modal-stat-card">
                                <div class="modal-stat-label">Ïñ∏Í∏â ÌöüÏàò</div>
                                <div class="modal-stat-value" id="modal-num-mentions">-</div>
                            </div>
                            <div class="modal-stat-card">
                                <div class="modal-stat-label">Î≥¥ÎèÑ ÏÜåÏä§</div>
                                <div class="modal-stat-value" id="modal-num-sources">-</div>
                            </div>
                            <div class="modal-stat-card">
                                <div class="modal-stat-label">Í¥ÄÎ†® Í∏∞ÏÇ¨</div>
                                <div class="modal-stat-value" id="modal-num-articles">-</div>
                            </div>
                            <div class="modal-stat-card">
                                <div class="modal-stat-label">ÌèâÍ∑† ÌÜ§</div>
                                <div class="modal-stat-value" id="modal-avg-tone">-</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <a id="modal-source-link" href="#" target="_blank" class="modal-source-link">
                            Ï†ÑÏ≤¥ Í∏∞ÏÇ¨ ÏùΩÍ∏∞ ‚Üó
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- News Section -->
        <section id="news" class="container section-padding">
            <div class="section-header reveal">
                <h2 class="section-title">Headlines</h2>
                <span class="section-subtitle">CURATED NEWS</span>
            </div>
            <div class="news-list reveal">
                <a href="#" class="news-item">
                    <div class="news-date">2024.05.20</div>
                    <div class="news-info">
                        <h3>ÌååÎÇòÎßà Ïö¥Ìïò ÌÜµÌñâÎüâ Ï†úÌïú ÏôÑÌôî Î∞úÌëú</h3>
                        <p>Ïö∞Í∏∞ ÏãúÏûëÏúºÎ°ú ÏàòÏúÑÍ∞Ä ÏÉÅÏäπÌï®Ïóê Îî∞Îùº ÏùºÏùº ÌÜµÌñâ ÏÑ†Î∞ï ÏàòÎ•º Îã®Í≥ÑÏ†ÅÏúºÎ°ú ÎäòÎ¶¥ ÏòàÏ†ïÏûÖÎãàÎã§.</p>
                    </div>
                    <div class="news-tag">Shipping</div>
                </a>
                <a href="#" class="news-item">
                    <div class="news-date">2024.05.19</div>
                    <div class="news-info">
                        <h3>Ìï≠Í≥µ ÌôîÎ¨º ÏàòÏöî, 3Í∞úÏõî Ïó∞ÏÜç ÏÉÅÏäπÏÑ∏</h3>
                        <p>Ï§ëÍµ≠Î∞ú Ïù¥Ïª§Î®∏Ïä§ Î¨ºÎüâ Í∏âÏ¶ùÏúºÎ°ú Ïù∏Ìï¥ ÏïÑÏãúÏïÑ-Î∂ÅÎØ∏ Ìï≠Í≥µ ÌôîÎ¨º Ïä§ÌéòÏù¥Ïä§ Î∂ÄÏ°± Ïã¨Ìôî.</p>
                    </div>
                    <div class="news-tag">Air Cargo</div>
                </a>
            </div>
        </section>
    </main>

    <footer>
        <div class="footer-brand">AAL.</div>
        <div class="copyright">&copy; 2024 AllAboutLogistics.</div>
    </footer>

    <!-- External JavaScript Modules -->
    <script src="js/config/constants.js"></script>
    <script src="js/utils/helpers.js"></script>
    
    <!-- Application Scripts -->
    <script>

        // 1. Scroll Reveal
        const revealElements = document.querySelectorAll('.reveal');
        const revealOnScroll = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                    observer.unobserve(entry.target);
                }
            });
        }, { threshold: 0.1, rootMargin: "0px 0px -50px 0px" });
        revealElements.forEach(el => revealOnScroll.observe(el));

        // 2. Tab Logic
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.market-content').forEach(panel => panel.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tabName + '-panel').classList.add('active');
        }

        // Product switching (Exchange Rate <-> Interest Rates)
        function switchProduct(productName) {
            // Update sidebar menu
            document.querySelectorAll('.product-menu li').forEach(li => li.classList.remove('selected'));
            // Find and select the clicked menu item
            document.querySelectorAll('.product-menu li').forEach(li => {
                let searchText = '';
                if (productName === 'exchange-rate') {
                    searchText = 'Exchange Rate';
                } else if (productName === 'interest-rates') {
                    searchText = 'Interest Rates';
                } else if (productName === 'inflation') {
                    searchText = 'Inflation';
                } else if (productName === 'gdp') {
                    searchText = 'Ï£ºÏöî ÏßÄÌëú';
                } else if (productName === 'gdp-growth') {
                    searchText = 'Economy Growth Rate';
                }
                
                if (searchText && li.textContent.includes(searchText)) {
                    li.classList.add('selected');
                }
            });
            
            // Hide all product panels and submenu
            const panels = {
                'exchange-rate': document.getElementById('economy-panel'),
                'interest-rates': document.getElementById('interest-rates-panel'),
                'inflation': document.getElementById('inflation-panel'),
                'gdp': document.getElementById('gdp-panel'),
                'trade': document.getElementById('trade-panel'),
                'employment': document.getElementById('employment-panel'),
                'gdp-growth': document.getElementById('gdp-growth-panel')
            };
            const gdpSubmenu = document.getElementById('gdp-submenu');
            
            // GDP Ìå®ÎÑêÏù¥ Ïù¥ÎØ∏ ÌëúÏãúÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏ (GDP ÏÑ†ÌÉù ÏãúÏóêÎßå ÏÇ¨Ïö©)
            const gdpPanel = panels['gdp'];
            const isGDPPanelVisible = productName === 'gdp' && gdpPanel && gdpPanel.style.display !== 'none';
            
            // Hide all panels
            Object.values(panels).forEach(panel => {
                if (panel) {
                    panel.style.display = 'none';
                }
            });
            
            // Update menu item selected state
            const productDisplayNames = {
                'exchange-rate': 'Exchange Rate',
                'interest-rates': 'Interest Rates',
                'inflation': 'Inflation',
                'gdp': 'Ï£ºÏöî ÏßÄÌëú',
                'trade': 'ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ',
                'employment': 'Í≥†Ïö© ÌÜµÍ≥Ñ',
                'gdp-growth': 'Economy Growth Rate'
            };
            
            document.querySelectorAll('.product-menu li').forEach(li => {
                li.classList.remove('selected');
                const displayName = productDisplayNames[productName];
                if (displayName && li.textContent.includes(displayName)) {
                    li.classList.add('selected');
                }
            });
            
            // Show selected panel/submenu and initialize if needed
            if (productName === 'exchange-rate' && panels['exchange-rate']) {
                if (gdpSubmenu) gdpSubmenu.style.display = 'none';
                panels['exchange-rate'].style.display = 'block';
            } else if (productName === 'interest-rates' && panels['interest-rates']) {
                if (gdpSubmenu) gdpSubmenu.style.display = 'none';
                panels['interest-rates'].style.display = 'block';
                if (!window.interestDataLoaded) {
                    initInterestRates();
                }
            } else if (productName === 'inflation' && panels['inflation']) {
                if (gdpSubmenu) gdpSubmenu.style.display = 'none';
                panels['inflation'].style.display = 'block';
                if (!window.inflationDataLoaded) {
                    initInflation();
                }
            } else if (productName === 'gdp') {
                // GDP Ìå®ÎÑê ÌëúÏãú
                if (gdpPanel) {
                    gdpPanel.style.display = 'block';
                if (!window.gdpDataLoaded) {
                    initGDP();
                    }
                }
                
                if (isGDPPanelVisible) {
                    // GDP Ìå®ÎÑêÏù¥ Ïù¥ÎØ∏ ÌëúÏãúÎêòÏñ¥ ÏûàÏúºÎ©¥ ÏÑúÎ∏åÎ©îÎâ¥Îßå ÌÜ†Í∏Ä
                    if (gdpSubmenu) {
                        gdpSubmenu.classList.toggle('show');
                        
                        // "Ï£ºÏöî ÏßÄÌëú" Î©îÎâ¥ Ìï≠Î™© ÏúÑÏπòÏóê ÎßûÏ∂∞ ÏÑúÎ∏åÎ©îÎâ¥ ÏúÑÏπò Ï°∞Ï†ï
                        if (gdpSubmenu.classList.contains('show')) {
                            updateGDPSubmenuPosition();
                        }
                    }
                } else {
                    // GDP Ìå®ÎÑêÏù¥ Ï≤òÏùå ÌëúÏãúÎêòÎ©¥ ÏÑúÎ∏åÎ©îÎâ¥ÎèÑ Ìï®Íªò ÌëúÏãú
                    if (gdpSubmenu) {
                        gdpSubmenu.classList.add('show');
                        updateGDPSubmenuPosition();
                    }
                }
            } else if (productName === 'trade' && panels['trade']) {
                if (gdpSubmenu) gdpSubmenu.classList.remove('show');
                panels['trade'].style.display = 'block';
                if (!window.tradeDataLoaded) {
                    initTrade();
                }
            } else if (productName === 'employment' && panels['employment']) {
                if (gdpSubmenu) gdpSubmenu.classList.remove('show');
                panels['employment'].style.display = 'block';
                if (!window.employmentDataLoaded) {
                    initEmployment();
                }
            } else if (productName === 'gdp-growth' && panels['gdp-growth']) {
                if (gdpSubmenu) gdpSubmenu.classList.remove('show');
                panels['gdp-growth'].style.display = 'block';
                if (!window.gdpGrowthDataLoaded) {
                    initGDPGrowth();
                }
            } else {
                // Îã§Î•∏ Ï†úÌíà ÏÑ†ÌÉù Ïãú ÏÑúÎ∏åÎ©îÎâ¥ Ïà®ÍπÄ
                if (gdpSubmenu) gdpSubmenu.classList.remove('show');
            }
        }

        // ÏÑúÎ∏åÎ©îÎâ¥ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updateGDPSubmenuPosition() {
            const gdpSubmenu = document.getElementById('gdp-submenu');
            if (!gdpSubmenu) return;
            
            const gdpMenuItem = Array.from(document.querySelectorAll('.product-menu li')).find(li => 
                li.textContent.includes('Ï£ºÏöî ÏßÄÌëú')
            );
            if (gdpMenuItem) {
                const rect = gdpMenuItem.getBoundingClientRect();
                const sidebar = gdpMenuItem.closest('.product-sidebar');
                if (sidebar) {
                    const sidebarRect = sidebar.getBoundingClientRect();
                    gdpSubmenu.style.top = `${rect.top - sidebarRect.top}px`;
                }
            }
        }

        // Date Handling Functions
        function initDateInputs() {
            // Exchange Rate Ìå®ÎÑêÏùò ÎÇ†Ïßú ÏûÖÎ†• ÌïÑÎìúÎßå ÏÑ†ÌÉù
            const economyPanel = document.getElementById('economy-panel');
            if (!economyPanel) return;
            
            const dateInputs = economyPanel.querySelectorAll('.date-input');
            if (dateInputs.length < 2) return;
            
            const end = new Date();
            const start = new Date();
            start.setDate(start.getDate() - 90); // Í∏∞Î≥∏Í∞í: ÏµúÍ∑º 3Í∞úÏõî
            
            const startDateStr = start.toISOString().split('T')[0];
            const endDateStr = end.toISOString().split('T')[0];
            
            dateInputs[0].value = startDateStr;
            dateInputs[1].value = endDateStr;
            dateInputs[0].max = endDateStr;
            dateInputs[1].max = endDateStr;
        }

        function validateDateRange() {
            // Exchange Rate Ìå®ÎÑêÏùò ÎÇ†Ïßú ÏûÖÎ†• ÌïÑÎìúÎßå ÌôïÏù∏
            const economyPanel = document.getElementById('economy-panel');
            if (!economyPanel) return false;
            
            const dateInputs = economyPanel.querySelectorAll('.date-input');
            if (dateInputs.length < 2) return false;
            
            const startDate = new Date(dateInputs[0].value);
            const endDate = new Date(dateInputs[1].value);
            
            if (startDate > endDate) {
                alert('ÏãúÏûëÏùºÏùÄ Ï¢ÖÎ£åÏùºÎ≥¥Îã§ ÏïûÏÑúÏïº Ìï©ÎãàÎã§.');
                return false;
            }
            
            return true;
        }

        function formatDateForAPI(dateStr) {
            // YYYY-MM-DD -> YYYYMMDD
            return dateStr.replace(/-/g, '');
        }
        
        // Interest Rates Ï†ÑÏö©: YYYY-MM -> YYYYMM01 (Î∞±ÏóîÎìúÎäî YYYYMMDD ÌòïÏãù Í∏∞ÎåÄ)
        function formatInterestDateForAPI(dateStr) {
            if (!dateStr) return '';
            // YYYY-MM ÌòïÏãù (month input) -> YYYYMM01 (Ìï¥Îãπ ÏõîÏùò Ï≤´Ïß∏ ÎÇ†)
            const parts = dateStr.split('-');
            if (parts.length === 2) {
                return `${parts[0]}${parts[1]}01`;
            }
            return dateStr.replace(/-/g, '');
        }

        function setDateRange(days) {
            // Exchange Rate Ìå®ÎÑêÏùò ÎÇ†Ïßú ÏûÖÎ†• ÌïÑÎìúÎßå ÏÑ†ÌÉù
            const economyPanel = document.getElementById('economy-panel');
            if (!economyPanel) return;
            
            const dateInputs = economyPanel.querySelectorAll('.date-input');
            if (dateInputs.length < 2) return;
            
            const end = new Date();
            const start = new Date();
            start.setDate(start.getDate() - days);
            
            const startDateStr = start.toISOString().split('T')[0];
            const endDateStr = end.toISOString().split('T')[0];
            
            dateInputs[0].value = startDateStr;
            dateInputs[1].value = endDateStr;
            
            // Period Î≤ÑÌäº ÌôúÏÑ±Ìôî ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Exchange Rate Ìå®ÎÑê ÎÇ¥Ïùò Î≤ÑÌäºÎßå)
            economyPanel.querySelectorAll('.period-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Îç∞Ïù¥ÌÑ∞ Ïû¨Ï°∞Ìöå
            if (validateDateRange()) {
                fetchExchangeRateData();
            }
        }

        function handlePeriodClick(period) {
            const days = {
                '1W': 7,
                '1M': 30,
                '3M': 90,
                '1Y': 365
            };
            
            if (days[period]) {
                setDateRange(days[period]);
            }
        }

        // 3. Backend API Integration
        // CURRENCY_MAPPINGÏùÄ js/config/constants.jsÏóêÏÑú Ïù¥ÎØ∏ Ï†ïÏùòÎêòÏñ¥ ÏûàÏùå
        // Ï§ëÎ≥µ ÏÑ†Ïñ∏ÏùÑ ÌîºÌïòÍ∏∞ ÏúÑÌï¥ window.CURRENCY_MAPPINGÏùÑ ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò constants.jsÏùò Í≤ÉÏùÑ ÏÇ¨Ïö©

        async function fetchExchangeRateData() {
            if (!validateDateRange()) return;
            
            // Exchange Rate Ìå®ÎÑêÏùò ÎÇ†Ïßú ÏûÖÎ†• ÌïÑÎìúÎßå ÏÑ†ÌÉù
            const economyPanel = document.getElementById('economy-panel');
            if (!economyPanel) return;
            
            const dateInputs = economyPanel.querySelectorAll('.date-input');
            if (dateInputs.length < 2) return;
            
            const startDate = formatDateForAPI(dateInputs[0].value);
            const endDate = formatDateForAPI(dateInputs[1].value);
            
            // ÌôúÏÑ±ÌôîÎêú ÌÜµÌôî Ï§ë BOKÏóêÏÑú ÏßÄÏõêÌïòÎäî ÌÜµÌôîÎßå ÌïÑÌÑ∞ÎßÅ
            const validCurrencies = activeCurrencies.filter(curr => CURRENCY_MAPPING[curr]);
            
            if (validCurrencies.length === 0) {
                console.warn('No valid currencies selected');
                return;
            }
            
            // Î°úÎî© ÏÉÅÌÉú ÌëúÏãú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            const chartContainer = document.getElementById('chart-container');
            if (chartContainer) {
                chartContainer.style.opacity = '0.5';
            }
            
            try {
                // Í∞Å ÌÜµÌôîÎ≥ÑÎ°ú API Ìò∏Ï∂ú
                const fetchPromises = validCurrencies.map(async (currency) => {
                    const itemCode = CURRENCY_MAPPING[currency];
                    const url = `${API_BASE}/market/indices?type=exchange&itemCode=${itemCode}&startDate=${startDate}&endDate=${endDate}`;
                    
                    try {
                        const response = await fetch(url);
                        const json = await response.json();
                        return { currency, data: json };
                    } catch (err) {
                        console.error(`Failed to fetch ${currency}:`, err);
                        return { currency, data: { error: err.message } };
                    }
                });
                
                const results = await Promise.all(fetchPromises);
                processExchangeRateData(results);
                
            } catch (err) {
                console.error('Failed to fetch exchange rate data:', err);
                alert('ÌôòÏú® Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            } finally {
                if (chartContainer) {
                    chartContainer.style.opacity = '1';
                }
            }
        }

        async function fetchExchangeRateStats(currency, startDate, endDate) {
            try {
                const itemCode = CURRENCY_MAPPING[currency];
                if (!itemCode) return null;
                
                const url = `${API_BASE}/market/indices/stats?type=exchange&itemCode=${currency}&startDate=${startDate}&endDate=${endDate}`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.error) {
                    console.error(`Stats error for ${currency}:`, data.error);
                    return null;
                }
                
                return data;
            } catch (err) {
                console.error(`Failed to fetch stats for ${currency}:`, err);
                return null;
            }
        }

        // Î™®Îì† ÌÜµÌôîÏùò ÌòÑÏû¨ ÌôòÏú® Í∞ÄÏ†∏Ïò§Í∏∞ (Ï£ºÏöî ÌÜµÌôîÎ≥Ñ ÌòÑÏû¨ ÌôòÏú® ÌÖåÏù¥Î∏îÏö©)
        async function fetchAllCurrencyRates() {
            const allCurrencies = ['USD', 'EUR', 'JPY', 'CNY', 'GBP', 'CHF', 'HKD', 'CAD', 'RUB'];
            
            // Ïò§Îäò ÎÇ†ÏßúÎ°ú ÏÑ§Ï†ï (ÏµúÏã† ÌôòÏú®)
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0].replace(/-/g, '');
            
            try {
                // Í∞Å ÌÜµÌôîÎ≥ÑÎ°ú ÏµúÏã† ÌôòÏú® Í∞ÄÏ†∏Ïò§Í∏∞
                const fetchPromises = allCurrencies.map(async (currency) => {
                    const itemCode = CURRENCY_MAPPING[currency];
                    if (!itemCode) return { currency, data: null };
                    
                    // ÏµúÍ∑º 7Ïùº Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏ÏôÄÏÑú Í∞ÄÏû• ÏµúÏã† Í∞í ÏÇ¨Ïö©
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - 7);
                    const startDateStr = startDate.toISOString().split('T')[0].replace(/-/g, '');
                    
                    const url = `${API_BASE}/market/indices?type=exchange&itemCode=${itemCode}&startDate=${startDateStr}&endDate=${todayStr}`;
                    
                    try {
                        const response = await fetch(url);
                        const json = await response.json();
                        return { currency, data: json };
                    } catch (err) {
                        console.error(`Failed to fetch ${currency}:`, err);
                        return { currency, data: null };
                    }
                });
                
                const results = await Promise.all(fetchPromises);
                
                // Í≤∞Í≥º Ï≤òÎ¶¨: Í∞Å ÌÜµÌôîÏùò ÏµúÏã† ÌôòÏú®Í≥º Ï†ÑÏùº ÌôòÏú®ÏùÑ Ï†ÄÏû•
                results.forEach(({ currency, data }) => {
                    if (data && !data.error && data.StatisticSearch && data.StatisticSearch.row) {
                        const rows = data.StatisticSearch.row;
                        if (rows.length > 0) {
                            // ÎÇ†ÏßúÏàúÏúºÎ°ú Ï†ïÎ†¨ (Ïò§ÎûòÎêú Í≤ÉÎ∂ÄÌÑ∞)
                            const sortedRows = [...rows].sort((a, b) => {
                                const dateA = parseInt(a.TIME || '0', 10);
                                const dateB = parseInt(b.TIME || '0', 10);
                                return dateA - dateB;
                            });
                            
                            // Í∞ÄÏû• ÏµúÏã† Îç∞Ïù¥ÌÑ∞ (ÎßàÏßÄÎßâ Ìï≠Î™©) = Ïò§Îäò
                            const latest = sortedRows[sortedRows.length - 1];
                            if (latest && latest.DATA_VALUE) {
                                const currentValue = parseFloat(latest.DATA_VALUE);
                                if (!isNaN(currentValue)) {
                                    exchangeRates[currency] = currentValue;
                                    
                                    // Ï†ÑÏùº Îç∞Ïù¥ÌÑ∞ Ï∞æÍ∏∞ (Ïò§Îäò Î∞îÎ°ú Ï†Ñ ÎÇ†Ïßú)
                                    // Ï£ºÎßêÏù¥ÎÇò Í≥µÌú¥ÏùºÏùÑ Í≥†Î†§ÌïòÏó¨ Í∞ÄÏû• ÏµúÏã† Îç∞Ïù¥ÌÑ∞Ïùò Î∞îÎ°ú Ï†Ñ ÎÇ†ÏßúÎ•º Ï∞æÏùå
                                    if (sortedRows.length >= 2) {
                                        // ÎßàÏßÄÎßâÏóêÏÑú Îëê Î≤àÏß∏ Ìï≠Î™©Ïù¥ Ï†ÑÏùº (Î∞îÎ°ú Ï†Ñ Í±∞ÎûòÏùº)
                                        const previous = sortedRows[sortedRows.length - 2];
                                        if (previous && previous.DATA_VALUE) {
                                            const previousValue = parseFloat(previous.DATA_VALUE);
                                            if (!isNaN(previousValue)) {
                                                // Ï†ÑÏùº ÌôòÏú® Ï†ÄÏû• (Ï†ÑÏùº ÎåÄÎπÑ Í≥ÑÏÇ∞Ïö©)
                                                previousRates[currency] = previousValue;
                                            }
                                        }
                                    }
                                    // Ï†ÑÏùº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ previousRatesÏóê Ï†ÄÏû•ÌïòÏßÄ ÏïäÏùå
                                    // (updateCurrencyRatesTableÏóêÏÑú "-"Î°ú ÌëúÏãúÎê®)
                                }
                            }
                        }
                    }
                });
                
                // ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
                updateCurrencyRatesTable();
                
            } catch (err) {
                console.error('Failed to fetch all currency rates:', err);
            }
        }

        // Interest Rates Functions
        let interestRateData = {}; // Interest rate data cache (Îã®Ïùº Íµ≠Í∞ÄÏö©, ÌïòÏúÑ Ìò∏ÌôòÏÑ±)
        let interestCycle = 'M'; // Current cycle (A, M, Q)
        let interestYAxisRange = { min: 0, max: 0 }; // Y-axis range for interest rates
        
        // International Interest Rates Variables
        let activeInterestCountries = []; // ÌôúÏÑ±ÌôîÎêú Íµ≠Í∞Ä Î™©Î°ù (item_code)
        let interestCountryData = {}; // Íµ≠Í∞ÄÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• { 'item_code': [{date, value}], ... }
        let interestCountryMapping = {}; // item_code ‚Üí {code, name} Îß§Ìïë
        let interestCountryListLoaded = false; // Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎìú Ïó¨Î∂Ä
        
        // Economy Growth Rate Variables
        let gdpGrowthCycle = 'Q'; // Current cycle (Q only)
        let activeGDPGrowthCountries = []; // ÌôúÏÑ±ÌôîÎêú Íµ≠Í∞Ä Î™©Î°ù (item_code)
        let gdpGrowthCountryData = {}; // Íµ≠Í∞ÄÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• { 'item_code': [{date, value}], ... }
        let gdpGrowthCountryMapping = {}; // item_code ‚Üí {code, name} Îß§Ìïë
        let gdpGrowthCountryListLoaded = false; // Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎìú Ïó¨Î∂Ä
        let gdpGrowthYAxisRange = { min: 0, max: 0 }; // Y-axis range for GDP growth
        
        // Trade Statistics variables
        let tradeCycle = 'M'; // Current cycle (M, Q)
        let tradeCurrency = 'USD'; // Ìï≠ÏÉÅ USD Î™®Îìú (ÏõêÌôî ÌôòÏÇ∞Í∞íÎèÑ Ìï®Íªò ÌëúÏãú)
        let activeTradeIndicators = ['EXPORT', 'IMPORT']; // Active indicators
        let tradeData = { EXPORT: [], IMPORT: [] }; // Trade data storage (USD Í∏∞Ï§Ä)
        let tradeDataKRW = { EXPORT: [], IMPORT: [] }; // Trade data storage (KRW Î≥ÄÌôòÍ∞í)
        let tradeExchangeRates = {}; // ÌôòÏú® Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• { 'YYYYMM': rate } (ÏàòÏ∂úÏûÖ ÌÜµÍ≥ÑÏö©)
        let tradeYAxisRange = { min: 0, max: 0 }; // Y-axis range for trade
        
        // International Trade Statistics variables
        let activeTradeCountry = null; // ÏÑ†ÌÉùÎêú Íµ≠Í∞Ä (1Í∞úÎßå)
        let tradeCountryMapping = {}; // Íµ≠Í∞Ä Îß§Ìïë { 'item_code': {code, name} }
        let tradeCountryData = { EXPORT: [], IMPORT: [], BALANCE: [] }; // ÏÑ†ÌÉùÎêú Íµ≠Í∞ÄÏùò ÏàòÏ∂ú/ÏàòÏûÖ/Î¨¥Ïó≠ÏàòÏßÄ Îç∞Ïù¥ÌÑ∞
        
        // Employment Statistics variables
        let employmentCycle = 'M'; // Current cycle (M, Q)
        let activeEmploymentIndicators = ['UNEMPLOYMENT_RATE', 'EMPLOYMENT_RATE']; // Active indicators
        let employmentData = { UNEMPLOYMENT_RATE: [], EMPLOYMENT_RATE: [], EMPLOYED: [] }; // Employment data storage
        let employmentYAxisRange = { min: 0, max: 0 }; // Y-axis range for employment

        function initInterestRates() {
            // Initialize date inputs for interest rates
            const startDateInput = document.getElementById('interest-start-date');
            const endDateInput = document.getElementById('interest-end-date');
            
            if (startDateInput && endDateInput) {
                const end = new Date();
                const start = new Date();
                // ÏõîÎ≥Ñ Í∏∞Î≥∏Í∞í: ÌòÑÏû¨ ÏõîÏùÑ Ìè¨Ìï®Ìï¥ÏÑú Í≥ºÍ±∞ 12Í∞úÏõî
                start.setMonth(end.getMonth() - 11); // 12Í∞úÏõî (ÌòÑÏû¨Ïõî Ìè¨Ìï®)
                start.setDate(1); // Ìï¥Îãπ ÏõîÏùò 1ÏùºÎ°ú ÏÑ§Ï†ï
                
                // YYYY-MM ÌòïÏãùÏúºÎ°ú ÏÑ§Ï†ï (month input ÌÉÄÏûÖ)
                const startYear = start.getFullYear();
                const startMonth = String(start.getMonth() + 1).padStart(2, '0');
                const endYear = end.getFullYear();
                const endMonth = String(end.getMonth() + 1).padStart(2, '0');
                
                startDateInput.value = `${startYear}-${startMonth}`;
                endDateInput.value = `${endYear}-${endMonth}`;
                startDateInput.max = endDateInput.value;
                endDateInput.max = endDateInput.value;
                
                // Add event listeners for date inputs
                startDateInput.addEventListener('change', () => {
                    if (validateInterestDateRange()) {
                        if (activeInterestCountries.length > 0) {
                            fetchInterestRateDataMulti();
                        } else {
                            fetchInterestRateData();
                        }
                    }
                });
                endDateInput.addEventListener('change', () => {
                    if (validateInterestDateRange()) {
                        if (activeInterestCountries.length > 0) {
                            fetchInterestRateDataMulti();
                        } else {
                            fetchInterestRateData();
                        }
                    }
                });
            }
            
            // Initialize cycle buttons (M, Q)
            // Í∏∞Ï°¥ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞ ÌõÑ ÏÉàÎ°ú Ï∂îÍ∞Ä (Ï§ëÎ≥µ Î∞©ÏßÄ)
            document.querySelectorAll('.interest-cycle-btn').forEach(btn => {
                // Í∏∞Ï°¥ ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ï†úÍ±∞Î•º ÏúÑÌï¥ ÌÅ¥Î°† ÌõÑ Ïû¨Ï∂îÍ∞Ä
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
                
                newBtn.addEventListener('click', function() {
                    // Î™®Îì† Î≤ÑÌäºÏóêÏÑú active Ï†úÍ±∞
                    document.querySelectorAll('.interest-cycle-btn').forEach(b => b.classList.remove('active'));
                    // ÌÅ¥Î¶≠Ìïú Î≤ÑÌäºÏóê active Ï∂îÍ∞Ä
                    this.classList.add('active');
                    // interestCycle Î≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏
                    interestCycle = this.getAttribute('data-cycle');
                    
                    console.log('Cycle changed to:', interestCycle);
                    
                    // Îç∞Ïù¥ÌÑ∞ Ïû¨Ï°∞Ìöå (ÎÇ†ÏßúÎäî Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå)
                    if (activeInterestCountries.length > 0) {
                        fetchInterestRateDataMulti();
                    } else {
                        fetchInterestRateData();
                    }
                });
            });
            
            // Load country list and initialize chips
            fetchInterestCountryList().then(() => {
                // Initial data fetch (Îã§Ï§ë Íµ≠Í∞Ä)
                if (activeInterestCountries.length > 0) {
                    fetchInterestRateDataMulti();
                } else {
                    // Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎìú Ïã§Ìå® Ïãú Í∏∞Ï°¥ Îã®Ïùº Íµ≠Í∞Ä Î∞©Ïãù ÏÇ¨Ïö©
                    fetchInterestRateData();
                }
            }).catch(err => {
                console.error('Failed to load country list, using single country mode:', err);
                fetchInterestRateData();
            });
            window.interestDataLoaded = true;
        }


        function validateInterestDateRange() {
            const startDateInput = document.getElementById('interest-start-date');
            const endDateInput = document.getElementById('interest-end-date');
            
            if (!startDateInput || !endDateInput) return false;
            
            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);
            
            if (startDate > endDate) {
                alert('ÏãúÏûëÏùºÏùÄ Ï¢ÖÎ£åÏùºÎ≥¥Îã§ ÏïûÏÑúÏïº Ìï©ÎãàÎã§.');
                return false;
            }
            
            return true;
        }

        async function fetchInterestRateData() {
            if (!validateInterestDateRange()) return;
            
            const startDateInput = document.getElementById('interest-start-date');
            const endDateInput = document.getElementById('interest-end-date');
            
            if (!startDateInputEl || !endDateInputEl) return;
            
            // Ïó∞ÎèÑÎ≥Ñ(A)Ïù∏ Í≤ΩÏö∞ ÎÖÑÎèÑ Í∞íÏùÑ ÎÇ†ÏßúÎ°ú Î≥ÄÌôò
            let startDate, endDate;
            if (interestCycle === 'A' && startDateInputEl.type === 'number') {
                // ÎÖÑÎèÑÎßå ÏÑ†ÌÉùÌïú Í≤ΩÏö∞, Ìï¥Îãπ ÎÖÑÎèÑÏùò 1Ïõî 1Ïùº ~ 12Ïõî 31ÏùºÎ°ú Î≥ÄÌôò
                const startYear = parseInt(startDateInputEl.value);
                const endYear = parseInt(endDateInputEl.value);
                startDate = `${startYear}0101`;
                endDate = `${endYear}1231`;
            } else {
                startDate = formatDateForAPI(startDateInputEl.value);
                endDate = formatDateForAPI(endDateInputEl.value);
            }
            
            const chartContainer = document.getElementById('interest-chart-container');
            if (chartContainer) {
                chartContainer.style.opacity = '0.5';
            }
            
            try {
                // Ïó∞ÎèÑÎ≥Ñ(A)Ïùº ÎïåÎäî ÏùºÎ≥Ñ(D) Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏ÏôÄÏÑú Ïó∞ÎèÑÎ≥ÑÎ°ú Î≥ÄÌôò
                const apiCycle = interestCycle === 'A' ? 'D' : interestCycle;
                
                const url = `${API_BASE}/market/indices?type=interest&itemCode=BASE_RATE&startDate=${startDate}&endDate=${endDate}&cycle=${apiCycle}`;
                console.log('Fetching interest rate data from:', url);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API response error:', {
                        status: response.status,
                        statusText: response.statusText,
                        url: url,
                        error: errorText
                    });
                    alert(`Í∏àÎ¶¨ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå® (${response.status}): ${response.statusText}\nURL: ${url}`);
                    return;
                }
                
                const json = await response.json();
                
                if (json.error) {
                    console.error('Interest rate API error:', json.error);
                    alert('Í∏àÎ¶¨ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + json.error);
                    return;
                }
                
                console.log('API response received:', {
                    rowCount: json.StatisticSearch?.row?.length || 0,
                    totalCount: json.StatisticSearch?.list_total_count || 0
                });
                
                // Process data
                processInterestRateData(json);
                
                // Fetch statistics (Ïó∞ÎèÑÎ≥ÑÏùº ÎïåÎäî ÏùºÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î°ú ÌÜµÍ≥Ñ Í≥ÑÏÇ∞)
                const statsCycle = interestCycle;
                const statsUrl = `${API_BASE}/market/indices/stats?type=interest&itemCode=BASE_RATE&startDate=${startDate}&endDate=${endDate}&cycle=${statsCycle}`;
                console.log('Fetching statistics from:', statsUrl);
                
                const statsResponse = await fetch(statsUrl);
                
                if (statsResponse.ok) {
                    const statsData = await statsResponse.json();
                    if (!statsData.error) {
                        updateInterestChartHeader(statsData);
                    }
                } else {
                    console.warn('Statistics API error:', statsResponse.status, statsResponse.statusText);
                }
                
            } catch (err) {
                console.error('Failed to fetch interest rate data:', err);
                console.error('Error details:', {
                    message: err.message,
                    stack: err.stack,
                    name: err.name
                });
                alert('Í∏àÎ¶¨ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + err.message);
            } finally {
                if (chartContainer) {
                    chartContainer.style.opacity = '1';
                }
            }
        }

        // International Interest Rates Functions
        async function fetchInterestCountryList() {
            if (interestCountryListLoaded && Object.keys(interestCountryMapping).length > 0) {
                return interestCountryMapping;
            }
            
            try {
                // BOK_MAPPINGÏóêÏÑú interest-international Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò itemsÎ•º Í∞ÄÏ†∏Ïò§Í∏∞ ÏúÑÌï¥
                // get_market_indexÎ•º Ìò∏Ï∂úÌïòÎ©¥ ÏûêÎèôÏúºÎ°ú itemsÍ∞Ä Ï±ÑÏõåÏßê
                // ÌïòÏßÄÎßå ÌîÑÎ°†Ìä∏ÏóîÎìúÏóêÏÑúÎäî ÏßÅÏ†ë itemsÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏúºÎØÄÎ°ú
                // ÏûÑÏãúÎ°ú ÌïòÎÇòÏùò item_codeÎ°ú ÏöîÏ≤≠ÌïòÏó¨ itemsÎ•º Ï±ÑÏö∞Í±∞ÎÇò,
                // Î≥ÑÎèÑÏùò ÏóîÎìúÌè¨Ïù∏Ìä∏Í∞Ä ÌïÑÏöîÌï®
                // ÏùºÎã® Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§Îäî APIÎ•º ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò,
                // Ï≤´ Î≤àÏß∏ item_codeÎ•º ÏãúÎèÑÌï¥ÏÑú ÏóêÎü¨ Î©îÏãúÏßÄÏóêÏÑú ÏÇ¨Ïö© Í∞ÄÎä•Ìïú itemsÎ•º Ïïå Ïàò ÏûàÏùå
                
                // ÎåÄÏã† Î∞±ÏóîÎìúÏùò get_statistic_item_listÎ•º ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÏóîÎìúÌè¨Ïù∏Ìä∏Í∞Ä ÌïÑÏöî
                // ÎòêÎäî Ï≤´ Î≤àÏß∏ Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠ Ïãú ÏûêÎèôÏúºÎ°ú itemsÍ∞Ä Ï±ÑÏõåÏßÄÎØÄÎ°ú
                // ÏûÑÏãúÎ°ú Ï≤´ Î≤àÏß∏ Íµ≠Í∞ÄÎ•º ÏöîÏ≤≠ÌïòÏó¨ itemsÎ•º Ï±ÑÏõÄ
                
                // Í∞ÑÎã®Ìïú Î∞©Î≤ï: Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ïÎ≥¥ Ï°∞Ìöå ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏÇ¨Ïö©
                const url = `${API_BASE}/market/categories?category=interest-international`;
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.items && Object.keys(data.items).length > 0) {
                        interestCountryMapping = data.items;
                        interestCountryListLoaded = true;
                        
                        // Í∏∞Î≥∏ÏúºÎ°ú Ï≤´ 3Í∞ú Íµ≠Í∞Ä ÏÑ†ÌÉù (ÌïúÍµ≠, ÎØ∏Íµ≠, ÏùºÎ≥∏ Ïö∞ÏÑ†)
                        const itemCodes = Object.keys(interestCountryMapping);
                        const defaultCodes = [];
                        
                        // ÌïúÍµ≠ Ï∞æÍ∏∞ (KOR, KOREA, ÌïúÍµ≠ Îì±)
                        const korCode = itemCodes.find(code => {
                            const name = interestCountryMapping[code].name;
                            return name.includes('ÌïúÍµ≠') || name.includes('KOR') || code.includes('KOR');
                        });
                        if (korCode) defaultCodes.push(korCode);
                        
                        // ÎØ∏Íµ≠ Ï∞æÍ∏∞
                        const usaCode = itemCodes.find(code => {
                            const name = interestCountryMapping[code].name;
                            return name.includes('ÎØ∏Íµ≠') || name.includes('USA') || name.includes('US') || code.includes('USA');
                        });
                        if (usaCode && !defaultCodes.includes(usaCode)) defaultCodes.push(usaCode);
                        
                        // ÏùºÎ≥∏ Ï∞æÍ∏∞
                        const jpnCode = itemCodes.find(code => {
                            const name = interestCountryMapping[code].name;
                            return name.includes('ÏùºÎ≥∏') || name.includes('JPN') || name.includes('JAPAN') || code.includes('JPN');
                        });
                        if (jpnCode && !defaultCodes.includes(jpnCode)) defaultCodes.push(jpnCode);
                        
                        // ÏµúÏÜå 1Í∞úÎäî ÏÑ†ÌÉù
                        if (defaultCodes.length === 0 && itemCodes.length > 0) {
                            defaultCodes.push(itemCodes[0]);
                        }
                        
                        activeInterestCountries = defaultCodes;
                        initInterestCountryChips();
                        
                        return interestCountryMapping;
                    }
                }
                
                // Fallback: Ï≤´ Î≤àÏß∏ item_codeÎ°ú ÏöîÏ≤≠ÌïòÏó¨ itemsÎ•º Ï±ÑÏõÄ
                // Ïù¥ Î∞©Î≤ïÏùÄ Î∞±ÏóîÎìúÏóêÏÑú itemsÍ∞Ä Ï±ÑÏõåÏßÄÎØÄÎ°ú, 
                // Îã§Ïùå ÏöîÏ≤≠Î∂ÄÌÑ∞Îäî Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ïÎ≥¥ Ï°∞ÌöåÎ°ú itemsÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏûàÏùå
                throw new Error('Failed to fetch country list from categories endpoint');
                
            } catch (err) {
                console.error('Failed to fetch interest country list:', err);
                // Í∏∞Î≥∏ Íµ≠Í∞Ä Îß§Ìïë (ÌïòÎìúÏΩîÎî©, Ïã§Ï†ú APIÏóêÏÑú Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌïú Í≤ΩÏö∞)
                // Ïù¥ Í≤ΩÏö∞ Î∞±ÏóîÎìúÍ∞Ä itemsÎ•º ÏûêÎèôÏúºÎ°ú Ï±ÑÏõåÏ§Ñ ÎïåÍπåÏßÄ ÎåÄÍ∏∞ÌïòÍ±∞ÎÇò
                // Îã§Ïãú ÏãúÎèÑÌï¥Ïïº Ìï®
                throw err;
            }
        }
        
        function initInterestCountryChips() {
            const chipsContainer = document.getElementById('interest-country-chips');
            if (!chipsContainer) return;
            
            chipsContainer.innerHTML = '';
            
            const itemCodes = Object.keys(interestCountryMapping);
            if (itemCodes.length === 0) {
                chipsContainer.innerHTML = '<span style="color: var(--text-sub); font-size: 0.8rem;">Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎî© Ï§ë...</span>';
                return;
            }
            
            itemCodes.forEach(itemCode => {
                const countryInfo = interestCountryMapping[itemCode];
                const chip = document.createElement('button');
                chip.className = 'chip';
                chip.setAttribute('data-item-code', itemCode);
                chip.setAttribute('title', countryInfo.name);
                
                const isActive = activeInterestCountries.includes(itemCode);
                if (isActive) {
                    chip.classList.add('active');
                }
                
                // Íµ≠Í∞ÄÎ≥Ñ Í∑∏ÎûòÌîÑ ÏÉâÏÉÅ Í∞ÄÏ†∏Ïò§Í∏∞
                const countryColor = getInterestCountryColor(itemCode);
                
                const chipDot = document.createElement('div');
                chipDot.className = 'chip-dot';
                // active ÏÉÅÌÉúÏùº ÎïåÎßå ÏÉâÏÉÅ Ï†ÅÏö©
                if (isActive) {
                    chipDot.style.background = countryColor;
                    chip.style.borderColor = countryColor;
                    chip.style.color = countryColor;
                    // CSS Î≥ÄÏàòÎ•º Ïã§Ï†ú ÏÉâÏÉÅÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ Î∞∞Í≤ΩÏÉâ ÏÑ§Ï†ï
                    const tempEl = document.createElement('div');
                    tempEl.style.color = countryColor;
                    document.body.appendChild(tempEl);
                    const computedColor = window.getComputedStyle(tempEl).color;
                    document.body.removeChild(tempEl);
                    // RGB Í∞íÏùÑ Ï∂îÏ∂úÌïòÏó¨ Ìà¨Î™ÖÎèÑ Ï†ÅÏö©
                    const rgbMatch = computedColor.match(/\d+/g);
                    if (rgbMatch && rgbMatch.length >= 3) {
                        chip.style.background = `rgba(${rgbMatch[0]}, ${rgbMatch[1]}, ${rgbMatch[2]}, 0.2)`;
                    }
                } else {
                    chipDot.style.background = 'currentColor';
                }
                
                chip.appendChild(chipDot);
                // Íµ≠Í∞Ä Ïù¥Î¶ÑÏùÑ ÏòÅÏñ¥Î°ú ÌëúÏãú
                const englishName = getInterestCountryNameEnglish(countryInfo.name);
                chip.appendChild(document.createTextNode(englishName));
                
                chip.addEventListener('click', () => toggleInterestCountry(itemCode));
                
                chipsContainer.appendChild(chip);
            });
        }
        
        function toggleInterestCountry(itemCode) {
            const index = activeInterestCountries.indexOf(itemCode);
            
            // ÌÜ†Í∏Ä: ÏûàÏúºÎ©¥ Ï†úÍ±∞, ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
            if (index === -1) {
                activeInterestCountries.push(itemCode);
            } else {
                activeInterestCountries.splice(index, 1);
            }
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            const chip = document.querySelector(`#interest-country-chips [data-item-code="${itemCode}"]`);
            if (chip) {
                const chipDot = chip.querySelector('.chip-dot');
                const isActive = activeInterestCountries.includes(itemCode);
                
                if (isActive) {
                    chip.classList.add('active');
                    // active ÏÉÅÌÉúÏùº ÎïåÎßå ÏÉâÏÉÅ Ï†ÅÏö©
                    const countryColor = getInterestCountryColor(itemCode);
                    if (chipDot) {
                        chipDot.style.background = countryColor;
                    }
                    // chipÏùò Î∞∞Í≤ΩÏÉâÍ≥º ÌÖåÎëêÎ¶¨ ÏÉâÏÉÅÎèÑ ÏÑ§Ï†ï
                    chip.style.borderColor = countryColor;
                    chip.style.color = countryColor;
                    // CSS Î≥ÄÏàòÎ•º Ïã§Ï†ú ÏÉâÏÉÅÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ Î∞∞Í≤ΩÏÉâ ÏÑ§Ï†ï
                    const tempEl = document.createElement('div');
                    tempEl.style.color = countryColor;
                    document.body.appendChild(tempEl);
                    const computedColor = window.getComputedStyle(tempEl).color;
                    document.body.removeChild(tempEl);
                    // RGB Í∞íÏùÑ Ï∂îÏ∂úÌïòÏó¨ Ìà¨Î™ÖÎèÑ Ï†ÅÏö©
                    const rgbMatch = computedColor.match(/\d+/g);
                    if (rgbMatch && rgbMatch.length >= 3) {
                        chip.style.background = `rgba(${rgbMatch[0]}, ${rgbMatch[1]}, ${rgbMatch[2]}, 0.2)`;
                    }
                } else {
                    chip.classList.remove('active');
                    // ÎπÑÌôúÏÑ±Ìôî Ïãú ÏÉâÏÉÅ Ï†úÍ±∞
                    if (chipDot) {
                        chipDot.style.background = 'currentColor';
                    }
                    // chip Ïä§ÌÉÄÏùº Ï¥àÍ∏∞Ìôî
                    chip.style.borderColor = '';
                    chip.style.color = '';
                    chip.style.background = '';
                }
            }
            
            // Îç∞Ïù¥ÌÑ∞ Ïû¨Ï°∞Ìöå (ÎòêÎäî Í∑∏ÎûòÌîÑ ÏóÖÎç∞Ïù¥Ìä∏)
            if (activeInterestCountries.length === 0) {
                // Î™®Îì† Íµ≠Í∞ÄÍ∞Ä Ìï¥Ï†úÎêòÎ©¥ Í∑∏ÎûòÌîÑ ÎπÑÏö∞Í∏∞
                updateInterestChartMulti();
            } else if (validateInterestDateRange()) {
                fetchInterestRateDataMulti();
            }
        }
        
        async function fetchInterestRateDataMulti() {
            if (!validateInterestDateRange()) return;
            
            const startDateInputEl = document.getElementById('interest-start-date');
            const endDateInputEl = document.getElementById('interest-end-date');
            
            if (!startDateInputEl || !endDateInputEl) return;
            
            if (activeInterestCountries.length === 0) {
                // Î™®Îì† Íµ≠Í∞ÄÍ∞Ä Ìï¥Ï†úÎêòÎ©¥ Í∑∏ÎûòÌîÑ ÎπÑÏö∞Í∏∞
                updateInterestChartMulti();
                return;
            }
            
            const startDate = formatInterestDateForAPI(startDateInputEl.value);
            const endDate = formatInterestDateForAPI(endDateInputEl.value);
            // Î∞±ÏóîÎìúÏóêÎäî Ìï≠ÏÉÅ ÏõîÎ≥Ñ(M)Î°ú ÏöîÏ≤≠ÌïòÍ≥†, ÌîÑÎ°†Ìä∏ÏóîÎìúÏóêÏÑú Î∂ÑÍ∏∞Î≥ÑÎ°ú Í∑∏Î£πÌôî
            const cycle = 'M'; // Ìï≠ÏÉÅ ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∞õÏïÑÏÑú ÌîÑÎ°†Ìä∏ÏóîÎìúÏóêÏÑú Ï≤òÎ¶¨
            
            const chartContainer = document.getElementById('interest-chart-container');
            if (chartContainer) {
                chartContainer.style.opacity = '0.5';
            }
            
            try {
                // Í∞Å Íµ≠Í∞ÄÎ≥ÑÎ°ú API Ìò∏Ï∂ú
                const fetchPromises = activeInterestCountries.map(async (itemCode) => {
                    const url = `${API_BASE}/market/indices?type=interest-international&itemCode=${itemCode}&startDate=${startDate}&endDate=${endDate}&cycle=${cycle}`;
                    
                    try {
                        const response = await fetch(url);
                        const json = await response.json();
                        return { itemCode, data: json };
                    } catch (err) {
                        console.error(`Failed to fetch ${itemCode}:`, err);
                        return { itemCode, data: { error: err.message } };
                    }
                });
                
                const results = await Promise.all(fetchPromises);
                processInterestRateDataMulti(results);
                
            } catch (err) {
                console.error('Failed to fetch interest rate data:', err);
                alert('Í∏àÎ¶¨ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + err.message);
            } finally {
                if (chartContainer) {
                    chartContainer.style.opacity = '1';
                }
            }
        }
        
        function processInterestRateDataMulti(results) {
            interestCountryData = {};
            
            // ÏÑ†ÌÉùÌïú Í∏∞Í∞Ñ Í∞ÄÏ†∏Ïò§Í∏∞
            const startDateInputEl = document.getElementById('interest-start-date');
            const endDateInputEl = document.getElementById('interest-end-date');
            const startDateStr = startDateInputEl ? formatInterestDateForAPI(startDateInputEl.value) : '';
            const endDateStr = endDateInputEl ? formatInterestDateForAPI(endDateInputEl.value) : '';
            
            // ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÍ∏∞Î≥ÑÎ°ú Í∑∏Î£πÌôîÌïòÎäî Ìï®Ïàò
            function groupMonthlyToQuarterly(monthlyData) {
                const quarterlyMap = new Map();
                
                monthlyData.forEach(item => {
                    if (item.date && item.date.length === 6) {
                        // YYYYMM ÌòïÏãù
                        const year = item.date.substring(0, 4);
                        const month = parseInt(item.date.substring(4, 6), 10);
                        let quarter;
                        
                        if (month >= 1 && month <= 3) quarter = 1;
                        else if (month >= 4 && month <= 6) quarter = 2;
                        else if (month >= 7 && month <= 9) quarter = 3;
                        else if (month >= 10 && month <= 12) quarter = 4;
                        else return; // Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïõî
                        
                        const quarterKey = `${year}Q${quarter}`;
                        
                        if (!quarterlyMap.has(quarterKey)) {
                            quarterlyMap.set(quarterKey, []);
                        }
                        quarterlyMap.get(quarterKey).push(item.value);
                    }
                });
                
                // Í∞Å Î∂ÑÍ∏∞Ïùò ÌèâÍ∑†Í∞í Í≥ÑÏÇ∞
                const quarterlyData = [];
                quarterlyMap.forEach((values, quarterKey) => {
                    const avgValue = values.reduce((sum, v) => sum + v, 0) / values.length;
                    quarterlyData.push({
                        date: quarterKey,
                        value: avgValue
                    });
                });
                
                return quarterlyData;
            }
            
            results.forEach(({ itemCode, data }) => {
                if (data.error || !data.StatisticSearch) {
                    console.error(`Error processing ${itemCode}:`, data.error || 'Invalid data format');
                    return;
                }
                
                const rows = data.StatisticSearch.row || [];
                let values = rows.map(row => ({
                    date: row.TIME,
                    value: parseFloat(row.DATA_VALUE)
                })).filter(item => !isNaN(item.value) && item.value > 0);
                
                // Î∂ÑÍ∏∞Î≥Ñ ÏÑ†ÌÉù Ïãú ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÍ∏∞Î≥ÑÎ°ú Í∑∏Î£πÌôî
                if (interestCycle === 'Q') {
                    // Î®ºÏ†Ä ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÍ∏∞Î≥ÑÎ°ú Í∑∏Î£πÌôî
                    values = groupMonthlyToQuarterly(values);
                }
                
                // ÏÑ†ÌÉùÌïú Í∏∞Í∞ÑÏùò Îç∞Ïù¥ÌÑ∞Îßå ÌïÑÌÑ∞ÎßÅ
                if (startDateStr && endDateStr) {
                    // startDateStrÍ≥º endDateStrÏùÄ YYYYMM01 ÌòïÏãùÏù¥ÎØÄÎ°ú YYYYMMÎßå Ï∂îÏ∂ú
                    const startMonth = startDateStr.substring(0, 6); // YYYYMM
                    const endMonth = endDateStr.substring(0, 6); // YYYYMM
                    
                    values = values.filter(item => {
                        if (!item.date) return false;
                        
                        let itemDateStr = item.date;
                        
                        // YYYYQn ÌòïÏãùÏùÑ YYYYMMÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ ÎπÑÍµê
                        if (itemDateStr.includes('Q')) {
                            const year = itemDateStr.substring(0, 4);
                            const quarter = parseInt(itemDateStr.substring(5), 10);
                            const month = (quarter - 1) * 3 + 1; // Î∂ÑÍ∏∞Ïùò Ï≤´ Î≤àÏß∏ Ïõî
                            itemDateStr = `${year}${String(month).padStart(2, '0')}`;
                        } else if (itemDateStr.length === 8) {
                            // YYYYMMDD ÌòïÏãùÏù∏ Í≤ΩÏö∞ YYYYMMÎßå Ï∂îÏ∂ú
                            itemDateStr = itemDateStr.substring(0, 6);
                        }
                        
                        // YYYYMM ÌòïÏãùÏúºÎ°ú ÎπÑÍµê
                        return itemDateStr >= startMonth && itemDateStr <= endMonth;
                    });
                }
                
                // ÎÇ†Ïßú Ï†ïÎ†¨ (YYYYMM ÎòêÎäî YYYYQn ÌòïÏãù ÏßÄÏõê)
                values.sort((a, b) => {
                    return compareInterestDates(a.date, b.date, interestCycle || 'M');
                });
                
                interestCountryData[itemCode] = values;
            });
            
            console.log('Processed interest rate data (multi):', {
                countries: Object.keys(interestCountryData),
                cycle: interestCycle,
                dateRange: { start: startDateStr, end: endDateStr },
                dataCounts: Object.fromEntries(
                    Object.entries(interestCountryData).map(([code, data]) => [code, data.length])
                )
            });
            
            updateInterestChartMulti();
        }
        
        function processInterestRateData(data) {
            if (!data || !data.StatisticSearch) {
                console.error('Invalid interest rate data format');
                return;
            }
            
            const rows = data.StatisticSearch.row || [];
            let values = rows.map(row => ({
                date: row.TIME,
                value: parseFloat(row.DATA_VALUE)
            })).filter(item => !isNaN(item.value) && item.value > 0);
            
            // Ïó∞ÎèÑÎ≥Ñ(A)Ïùº ÎïåÎäî ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Í∑∏ÎåÄÎ°ú ÌëúÏãú (Ïõî Îã®ÏúÑÎ°ú Ï¥òÏ¥òÌïòÍ≤å)
            // Ïó∞ÎèÑÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò Î°úÏßÅ Ï†úÍ±∞ - ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
            // if (interestCycle === 'A') {
            //     // Ïó∞ÎèÑÎ≥Ñ Î≥ÄÌôò Î°úÏßÅ Ï†úÍ±∞Îê® - ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Í∑∏ÎåÄÎ°ú ÌëúÏãú
            // }
            
            // Ï£ºÍ∏∞Ïóê Îî∞Îùº ÎÇ†Ïßú Ï†ïÎ†¨
            values.sort((a, b) => compareInterestDates(a.date, b.date, interestCycle));
            
            interestRateData = values;
            
            // ÎîîÎ≤ÑÍπÖ: Ï≤òÎ¶¨Îêú Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
            console.log('Processed interest rate data:', {
                cycle: interestCycle,
                count: values.length,
                dates: values.map(v => v.date),
                dateRange: values.length > 0 ? {
                    start: values[0].date,
                    end: values[values.length - 1].date
                } : null
            });
            
            updateInterestChart();
        }

        // Ï£ºÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Í∞úÏàò Í≥ÑÏÇ∞ Ìï®Ïàò
        function getInterestDataUnitCount(data, cycle) {
            if (!data || data.length === 0) return 0;
            
            if (cycle === 'M') {
                // ÏõîÎ≥Ñ: Í≥†Ïú†Ìïú Ïõî Í∞úÏàò Í≥ÑÏÇ∞
                const uniqueMonths = new Set();
                data.forEach(item => {
                    if (item.date && item.date.length === 6) {
                        uniqueMonths.add(item.date); // YYYYMM ÌòïÏãù
                    }
                });
                return uniqueMonths.size;
            } else if (cycle === 'Q') {
                // Î∂ÑÍ∏∞Î≥Ñ: Í≥†Ïú†Ìïú Î∂ÑÍ∏∞ Í∞úÏàò Í≥ÑÏÇ∞
                const uniqueQuarters = new Set();
                data.forEach(item => {
                    if (item.date && item.date.includes('Q')) {
                        uniqueQuarters.add(item.date); // YYYYQn ÌòïÏãù
                    }
                });
                return uniqueQuarters.size;
            } else if (cycle === 'A') {
                // Ïó∞ÎèÑÎ≥Ñ: Í≥†Ïú†Ìïú Ïó∞ÎèÑ Í∞úÏàò Í≥ÑÏÇ∞
                const uniqueYears = new Set();
                data.forEach(item => {
                    if (item.date && item.date.length === 4) {
                        uniqueYears.add(item.date); // YYYY ÌòïÏãù
                    }
                });
                return uniqueYears.size;
            }
            
            return data.length;
        }

        // Íµ≠Í∞Ä Ï†ïÎ≥¥ Îß§Ìïë (ÌïúÍµ≠Ïñ¥Î™Ö ‚Üí {englishName, color})
        const interestCountryInfoMap = [
            { keywords: ['Ìò∏Ï£º', 'aus', 'australia'], englishName: 'Australia', color: 'var(--c-interest-aus)' },
            { keywords: ['Î∏åÎùºÏßà', 'bra', 'brazil'], englishName: 'Brazil', color: 'var(--c-interest-bra)' },
            { keywords: ['Ï∫êÎÇòÎã§', 'can', 'canada'], englishName: 'Canada', color: 'var(--c-interest-can)' },
            { keywords: ['Ïä§ÏúÑÏä§', 'che', 'switzerland'], englishName: 'Switzerland', color: 'var(--accent-color)' },
            { keywords: ['Ïπ†Î†à', 'chl', 'chile'], englishName: 'Chile', color: 'var(--accent-color)' },
            { keywords: ['Ï§ëÍµ≠', 'chn', 'china'], englishName: 'China', color: 'var(--c-interest-chn)' },
            { keywords: ['Ï≤¥ÏΩî', 'cze', 'czech'], englishName: 'Czech Republic', color: 'var(--accent-color)' },
            { keywords: ['Îç¥ÎßàÌÅ¨', 'dnk', 'denmark'], englishName: 'Denmark', color: 'var(--accent-color)' },
            { keywords: ['ÏòÅÍµ≠', 'gbr', 'uk', 'united kingdom'], englishName: 'UK', color: 'var(--c-interest-gbr)' },
            { keywords: ['ÌóùÍ∞ÄÎ¶¨', 'hun', 'hungary'], englishName: 'Hungary', color: 'var(--accent-color)' },
            { keywords: ['Ïù∏ÎèÑÎÑ§ÏãúÏïÑ', 'idn', 'indonesia'], englishName: 'Indonesia', color: 'var(--accent-color)' },
            { keywords: ['Ïù¥Ïä§ÎùºÏóò', 'isr', 'israel'], englishName: 'Israel', color: 'var(--accent-color)' },
            { keywords: ['Ïù∏ÎèÑ', 'ind', 'india'], englishName: 'India', color: 'var(--c-interest-ind)' },
            { keywords: ['ÏïÑÏù¥Ïä¨ÎûÄÎìú', 'isl', 'iceland'], englishName: 'Iceland', color: 'var(--accent-color)' },
            { keywords: ['ÏùºÎ≥∏', 'jpn', 'japan'], englishName: 'Japan', color: 'var(--c-interest-jpn)' },
            { keywords: ['ÌïúÍµ≠', 'kor', 'korea'], englishName: 'Korea', color: 'var(--c-interest-kor)' },
            { keywords: ['Î©ïÏãúÏΩî', 'mex', 'mexico'], englishName: 'Mexico', color: 'var(--accent-color)' },
            { keywords: ['ÎÖ∏Î•¥Ïõ®Ïù¥', 'nor', 'norway'], englishName: 'Norway', color: 'var(--accent-color)' },
            { keywords: ['Îâ¥ÏßàÎûúÎìú', 'nzl', 'zealand'], englishName: 'New Zealand', color: 'var(--c-interest-nzl)' },
            { keywords: ['Ìè¥ÎûÄÎìú', 'pol', 'poland'], englishName: 'Poland', color: 'var(--accent-color)' },
            { keywords: ['Îü¨ÏãúÏïÑ', 'rus', 'russia'], englishName: 'Russia', color: 'var(--c-interest-rus)' },
            { keywords: ['Ïä§Ïõ®Îç¥', 'swe', 'sweden'], englishName: 'Sweden', color: 'var(--accent-color)' },
            { keywords: ['ÌäÄÎ•¥ÌÇ§Ïòà', 'tur', 'turkey'], englishName: 'Turkey', color: 'var(--accent-color)' },
            { keywords: ['ÎØ∏Íµ≠', 'usa', 'us ', 'united states'], englishName: 'USA', color: 'var(--c-interest-usa)' },
            { keywords: ['Ïú†Î°ú', 'eur', 'eurozone', 'euro area'], englishName: 'Eurozone', color: 'var(--accent-color)' },
            { keywords: ['ÎÇ®ÏïÑÌîÑÎ¶¨Ïπ¥', 'zaf', 'south africa'], englishName: 'South Africa', color: 'var(--accent-color)' },
            { keywords: ['ÎèÖÏùº', 'deu', 'germany'], englishName: 'Germany', color: 'var(--c-interest-deu)' },
            { keywords: ['ÌîÑÎûëÏä§', 'fra', 'france'], englishName: 'France', color: 'var(--c-interest-fra)' },
            { keywords: ['Ïù¥ÌÉàÎ¶¨ÏïÑ', 'ita', 'italy'], englishName: 'Italy', color: 'var(--c-interest-ita)' },
            { keywords: ['Ïä§ÌéòÏù∏', 'esp', 'spain'], englishName: 'Spain', color: 'var(--c-interest-esp)' }
        ];
        
        // Íµ≠Í∞Ä Ï†ïÎ≥¥ Ï∞æÍ∏∞ (ÌïúÍµ≠Ïñ¥Î™Ö Í∏∞Î∞ò)
        function findInterestCountryInfo(koreanName) {
            if (!koreanName) return null;
            
            const name = koreanName.toLowerCase();
            
            for (const info of interestCountryInfoMap) {
                if (info.keywords.some(keyword => name.includes(keyword))) {
                    return info;
                }
            }
            
            return null;
        }
        
        // Íµ≠Í∞Ä Ïù¥Î¶ÑÏùÑ ÏòÅÏñ¥Î°ú Î≥ÄÌôòÌïòÎäî Ìï®Ïàò
        function getInterestCountryNameEnglish(koreanName) {
            const info = findInterestCountryInfo(koreanName);
            return info ? info.englishName : koreanName;
        }
        
        // Íµ≠Í∞ÄÎ≥Ñ ÏÉâÏÉÅ Îß§Ìïë (item_code ‚Üí CSS Î≥ÄÏàò)
        function getInterestCountryColor(itemCode) {
            const countryInfo = interestCountryMapping[itemCode];
            if (!countryInfo) {
                // Í∏∞Î≥∏ ÏÉâÏÉÅ (item_code Í∏∞Î∞ò Ìï¥Ïãú)
                const colors = [
                    'var(--c-interest-kor)', 'var(--c-interest-usa)', 'var(--c-interest-jpn)',
                    'var(--c-interest-chn)', 'var(--c-interest-gbr)', 'var(--c-interest-deu)',
                    'var(--c-interest-fra)', 'var(--c-interest-ita)', 'var(--c-interest-esp)',
                    'var(--c-interest-can)', 'var(--c-interest-aus)', 'var(--c-interest-nzl)'
                ];
                let hash = 0;
                for (let i = 0; i < itemCode.length; i++) {
                    hash = ((hash << 5) - hash) + itemCode.charCodeAt(i);
                    hash = hash & hash;
                }
                return colors[Math.abs(hash) % colors.length];
            }
            
            const info = findInterestCountryInfo(countryInfo.name);
            if (info) {
                return info.color;
            }
            
            // Îß§ÌïëÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Í∏∞Î≥∏ ÏÉâÏÉÅ (item_code Í∏∞Î∞ò Ìï¥Ïãú)
            const colors = [
                'var(--c-interest-kor)', 'var(--c-interest-usa)', 'var(--c-interest-jpn)',
                'var(--c-interest-chn)', 'var(--c-interest-gbr)', 'var(--c-interest-deu)',
                'var(--c-interest-fra)', 'var(--c-interest-ita)', 'var(--c-interest-esp)',
                'var(--c-interest-can)', 'var(--c-interest-aus)', 'var(--c-interest-nzl)'
            ];
            let hash = 0;
            for (let i = 0; i < itemCode.length; i++) {
                hash = ((hash << 5) - hash) + itemCode.charCodeAt(i);
                hash = hash & hash;
            }
            return colors[Math.abs(hash) % colors.length];
        }
        
        function updateInterestChartMulti() {
            const svg = document.getElementById('interest-chart-svg');
            const pointsGroup = document.getElementById('interest-data-points');
            
            if (!svg || !pointsGroup) return;
            
            // Î™®Îì† Íµ≠Í∞Ä path Ï†ïÎ¶¨
            Object.keys(interestCountryMapping).forEach(itemCode => {
                let path = document.getElementById(`path-interest-${itemCode}`);
                if (!path) {
                    // path ÏöîÏÜå ÏÉùÏÑ±
                    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.id = `path-interest-${itemCode}`;
                    path.classList.add('chart-path');
                    path.setAttribute('stroke', getInterestCountryColor(itemCode));
                    path.setAttribute('stroke-width', '2.5');
                    path.setAttribute('fill', 'none');
                    svg.insertBefore(path, pointsGroup);
                }
                path.setAttribute('d', '');
                path.classList.remove('visible');
            });
            
            // ÌôúÏÑ±ÌôîÎêú Íµ≠Í∞ÄÍ∞Ä ÏóÜÏúºÎ©¥ Í∑∏ÎûòÌîÑ ÎπÑÏö∞Í∏∞
            if (activeInterestCountries.length === 0) {
                renderInterestYAxisLabelsMulti([]);
                renderInterestXAxisLabelsMulti([]);
                pointsGroup.innerHTML = '';
                return;
            }
            
            // Î™®Îì† Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ Î≥ëÌï©ÌïòÏó¨ Í≥µÌÜµ ÎÇ†Ïßú Î™©Î°ù ÏÉùÏÑ±
            const allDates = new Set();
            Object.values(interestCountryData).forEach(data => {
                data.forEach(item => allDates.add(item.date));
            });
            const sortedDates = Array.from(allDates).sort((a, b) => {
                return compareInterestDates(a, b, interestCycle || 'M');
            });
            
            if (sortedDates.length === 0) {
                renderInterestYAxisLabelsMulti([]);
                renderInterestXAxisLabelsMulti([]);
                return;
            }
            
            // YÏ∂ï Î≤îÏúÑ Í≥ÑÏÇ∞ (Î™®Îì† Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)
            const allValues = [];
            Object.values(interestCountryData).forEach(data => {
                data.forEach(item => allValues.push(item.value));
            });
            
            if (allValues.length === 0) {
                renderInterestYAxisLabelsMulti([]);
                renderInterestXAxisLabelsMulti(sortedDates);
                return;
            }
            
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            const range = maxValue - minValue || 1;
            const paddingPercent = range < 10 ? 0.05 : 0.03;
            interestYAxisRange = {
                min: Math.max(0, minValue - range * paddingPercent),
                max: maxValue + range * paddingPercent
            };
            
            // YÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ
            renderInterestYAxisLabelsMulti(sortedDates);
            
            // Í∞Å Íµ≠Í∞ÄÎ≥Ñ path Î†åÎçîÎßÅ
            activeInterestCountries.forEach(itemCode => {
                const data = interestCountryData[itemCode];
                if (!data || data.length === 0) return;
                
                let path = document.getElementById(`path-interest-${itemCode}`);
                if (!path) {
                    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.id = `path-interest-${itemCode}`;
                    path.classList.add('chart-path');
                    path.setAttribute('stroke', getInterestCountryColor(itemCode));
                    path.setAttribute('stroke-width', '2.5');
                    path.setAttribute('fill', 'none');
                    svg.insertBefore(path, pointsGroup);
                }
                
                // Îç∞Ïù¥ÌÑ∞Î•º Í≥µÌÜµ ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨
                const sortedData = sortedDates.map(date => {
                    const found = data.find(item => item.date === date);
                    return found || { date, value: null };
                }).filter(item => item.value !== null);
                
                if (sortedData.length > 0) {
                    const pathData = generateInterestSVGPathMulti(sortedData);
                    path.setAttribute('d', pathData);
                    path.classList.add('visible');
                }
            });
            
            // Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ Î†åÎçîÎßÅ
            renderInterestDataPointsMulti(sortedDates);
            
            // XÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ
            renderInterestXAxisLabelsMulti(sortedDates);
            
            // Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Í∏∞Îä• ÏÑ§Ï†ï
            setupInterestChartInteractivityMulti();
            
            // ÌÜµÍ≥Ñ Ìó§Îçî ÏóÖÎç∞Ïù¥Ìä∏
            updateInterestChartHeaderMulti();
        }
        
        function generateInterestSVGPathMulti(data) {
            if (!data || data.length === 0) return '';
            
            const svg = document.getElementById('interest-chart-svg');
            if (!svg) return '';
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = interestYAxisRange.min;
            const maxValue = interestYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            let pathData = '';
            data.forEach((point, index) => {
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            return pathData;
        }
        
        function renderInterestYAxisLabelsMulti(sortedDates) {
            const yAxisGroup = document.getElementById('interest-y-axis-labels');
            if (!yAxisGroup) return;
            
            yAxisGroup.innerHTML = '';
            
            const minValue = interestYAxisRange.min;
            const maxValue = interestYAxisRange.max;
            const steps = 5;
            
            for (let i = 0; i <= steps; i++) {
                const value = maxValue - (i / steps) * (maxValue - minValue);
                const y = 20 + (i / steps) * 330; // 350 - 20 = 330 (Ï∞®Ìä∏ ÎÜíÏù¥)
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', '30');
                label.setAttribute('y', y);
                label.setAttribute('class', 'chart-yaxis-label');
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('dominant-baseline', 'middle');
                label.textContent = value.toFixed(2) + '%';
                
                yAxisGroup.appendChild(label);
            }
        }
        
        function renderInterestXAxisLabelsMulti(sortedDates) {
            const xAxisGroup = document.getElementById('interest-x-axis-labels');
            if (!xAxisGroup || !sortedDates || sortedDates.length === 0) return;
            
            xAxisGroup.innerHTML = '';
            
            const svg = document.getElementById('interest-chart-svg');
            if (!svg) return;
            
            const { width } = getSvgViewBoxSize(svg);
            const padding = { left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            
            // Ï£ºÍ∏∞Ïóê Îî∞Îùº ÎùºÎ≤® Í∞ÑÍ≤© Ï°∞Ï†ï
            const labelInterval = Math.max(1, Math.floor(sortedDates.length / 8));
            
            sortedDates.forEach((date, index) => {
                if (index % labelInterval !== 0 && index !== sortedDates.length - 1) return;
                
                const x = padding.left + (index / (sortedDates.length - 1 || 1)) * chartWidth;
                const y = 370; // 400 - 30 = 370
                
                // ÎÇ†Ïßú ÌòïÏãù Î≥ÄÌôò (YYYYMM ÎòêÎäî YYYYQn)
                let labelText = '';
                if (date.length === 6 && !date.includes('Q')) {
                    // YYYYMM ÌòïÏãù
                    const year = date.substring(0, 4);
                    const month = date.substring(4, 6);
                    labelText = `${year.substring(2)}.${month}`;
                } else if (date.includes('Q')) {
                    // YYYYQn ÌòïÏãù (Ïòà: 2024Q1)
                    const year = date.substring(0, 4);
                    const quarter = date.substring(5);
                    labelText = `${year.substring(2)}Q${quarter}`;
                } else {
                    labelText = date;
                }
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', y);
                label.setAttribute('class', 'chart-xaxis-label');
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('dominant-baseline', 'middle');
                label.textContent = labelText;
                
                xAxisGroup.appendChild(label);
            });
        }
        
        function renderInterestDataPointsMulti(sortedDates) {
            const pointsGroup = document.getElementById('interest-data-points');
            if (!pointsGroup || !sortedDates || sortedDates.length === 0) return;
            
            pointsGroup.innerHTML = '';
            
            const svg = document.getElementById('interest-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = interestYAxisRange.min;
            const maxValue = interestYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            activeInterestCountries.forEach(itemCode => {
                const data = interestCountryData[itemCode];
                if (!data || data.length === 0) return;
                
                const color = getInterestCountryColor(itemCode);
                
                sortedDates.forEach((date, index) => {
                    const item = data.find(d => d.date === date);
                    if (!item) return;
                    
                    const x = padding.left + (index / (sortedDates.length - 1 || 1)) * chartWidth;
                    const normalizedValue = (item.value - minValue) / valueRange;
                    const y = padding.top + (1 - normalizedValue) * chartHeight;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', '4');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', 'var(--bg-color)');
                    circle.setAttribute('stroke-width', '1');
                    circle.setAttribute('data-date', date);
                    circle.setAttribute('data-item-code', itemCode);
                    circle.setAttribute('data-value', item.value);
                    circle.style.cursor = 'pointer';
                    
                    pointsGroup.appendChild(circle);
                });
            });
        }
        
        function setupInterestChartInteractivityMulti() {
            const chartContainer = document.getElementById('interest-chart-container');
            const svg = document.getElementById('interest-chart-svg');
            if (!chartContainer || !svg) return;
            
            // Ìà¥ÌåÅÏùÑ bodyÎ°ú Ïù¥Îèô (exchange rate Ïä§ÌÉÄÏùº)
            const tooltip = document.getElementById('interest-chart-tooltip');
            if (tooltip) {
                if (tooltip.parentElement !== document.body) {
                    document.body.appendChild(tooltip);
                }
            }
            
            // Í∏∞Ï°¥ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
            if (interestMouseMoveHandler) {
                chartContainer.removeEventListener('mousemove', interestMouseMoveHandler);
            }
            if (interestMouseLeaveHandler) {
                chartContainer.removeEventListener('mouseleave', interestMouseLeaveHandler);
            }
            
            let rafId = null;
            
            interestMouseMoveHandler = (event) => {
                if (rafId) return;
                
                rafId = requestAnimationFrame(() => {
                    rafId = null;
                    showInterestTooltipMulti(event);
                });
            };
            
            interestMouseLeaveHandler = () => {
                if (rafId) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                }
                hideInterestTooltip();
            };
            
            chartContainer.addEventListener('mousemove', interestMouseMoveHandler);
            chartContainer.addEventListener('mouseleave', interestMouseLeaveHandler);
        }
        
        function showInterestTooltipMulti(event) {
            const tooltip = document.getElementById('interest-chart-tooltip');
            if (!tooltip) return;
            
            const svg = document.getElementById('interest-chart-svg');
            if (!svg) return;
            
            const rect = svg.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const chartPadding = { left: 40, right: 20 };
            const chartWidth = width - chartPadding.left - chartPadding.right;
            
            // Î™®Îì† Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ Î≥ëÌï©ÌïòÏó¨ Í≥µÌÜµ ÎÇ†Ïßú Î™©Î°ù ÏÉùÏÑ±
            const allDates = new Set();
            Object.values(interestCountryData).forEach(data => {
                data.forEach(item => allDates.add(item.date));
            });
            const sortedDates = Array.from(allDates).sort((a, b) => {
                return compareInterestDates(a, b, interestCycle || 'M');
            });
            
            if (sortedDates.length === 0) return;
            
            // X Ï¢åÌëúÎ°ú ÎÇ†Ïßú Ï∞æÍ∏∞
            const dateIndex = Math.round(((x - chartPadding.left) / chartWidth) * (sortedDates.length - 1));
            const dateIndexClamped = Math.max(0, Math.min(sortedDates.length - 1, dateIndex));
            const date = sortedDates[dateIndexClamped];
            
            // ÎÇ†Ïßú Ìè¨Îß∑ÌåÖ
            let dateLabel = date;
            if (date.length === 6 && !date.includes('Q')) {
                // YYYYMM ÌòïÏãù
                const year = date.substring(0, 4);
                const month = date.substring(4, 6);
                dateLabel = `${year}.${month}`;
            } else if (date.includes('Q')) {
                // YYYYQn ÌòïÏãù (Ïòà: 2024Q1 -> 24Q1)
                const year = date.substring(0, 4);
                const quarter = date.substring(5);
                dateLabel = `${year.substring(2)}Q${quarter}`;
            }
            
            // Exchange rate Ïä§ÌÉÄÏùºÏùò Ìà¥ÌåÅ ÏÉùÏÑ±
            let content = '';
            activeInterestCountries.forEach(itemCode => {
                const data = interestCountryData[itemCode];
                if (!data) return;
                
                // Ï†ïÌôïÌïú ÎÇ†Ïßú Îß§Ïπ≠ ÏãúÎèÑ
                let item = data.find(d => d.date === date);
                
                // Ï†ïÌôïÌïú Îß§Ïπ≠Ïù¥ ÏóÜÏúºÎ©¥ Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÎÇ†Ïßú Ï∞æÍ∏∞
                if (!item && sortedDates.length > 0) {
                    const currentIndex = sortedDates.indexOf(date);
                    if (currentIndex > 0) {
                        const prevDate = sortedDates[currentIndex - 1];
                        item = data.find(d => d.date === prevDate);
                    }
                    if (!item && currentIndex < sortedDates.length - 1) {
                        const nextDate = sortedDates[currentIndex + 1];
                        item = data.find(d => d.date === nextDate);
                    }
                }
                
                if (!item) return;
                
                const countryInfo = interestCountryMapping[itemCode];
                const countryName = countryInfo ? getInterestCountryNameEnglish(countryInfo.name) : itemCode;
                const color = getInterestCountryColor(itemCode);
                
                // CSS Î≥ÄÏàòÎ•º Ïã§Ï†ú ÏÉâÏÉÅÏúºÎ°ú Î≥ÄÌôò
                const tempEl = document.createElement('div');
                tempEl.style.color = color;
                document.body.appendChild(tempEl);
                const computedColor = window.getComputedStyle(tempEl).color;
                document.body.removeChild(tempEl);
                
                content += `
                    <div class="chart-tooltip-item">
                        <div class="chart-tooltip-currency">
                            <div class="chart-tooltip-dot" style="background: ${computedColor}"></div>
                            <span>${countryName}</span>
                        </div>
                        <span class="chart-tooltip-value">${item.value.toFixed(2)}%</span>
                    </div>
                `;
            });
            
            if (!content) {
                hideInterestTooltip();
                return;
            }
            
            const tooltipContentEl = document.getElementById('interest-tooltip-content');
            if (tooltipContentEl) {
                tooltipContentEl.innerHTML = content;
            }
            
            const tooltipDateEl = document.getElementById('interest-tooltip-date');
            if (tooltipDateEl) {
                tooltipDateEl.textContent = dateLabel;
            }
            
            // Ìà¥ÌåÅÏùÑ Î®ºÏ†Ä ÌëúÏãúÌï¥ÏÑú ÌÅ¨Í∏∞Î•º Ï∏°Ï†ï (exchange rate Ïä§ÌÉÄÏùº)
            tooltip.style.visibility = 'hidden';
            tooltip.classList.add('visible');
            
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const tooltipPadding = 15;
            
            // Í∏∞Î≥∏ ÏúÑÏπò (ÎßàÏö∞Ïä§ Ïò§Î•∏Ï™Ω ÏïÑÎûò)
            let left = event.clientX + tooltipPadding;
            let top = event.clientY + tooltipPadding;
            
            // Ïö∞Ï∏° Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Ï°∞Ï†ï
            if (left + tooltipRect.width > viewportWidth - tooltipPadding) {
                left = event.clientX - tooltipRect.width - tooltipPadding;
            }
            
            // Ï¢åÏ∏° Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Ï°∞Ï†ï
            if (left < tooltipPadding) {
                if (event.clientX + tooltipRect.width + tooltipPadding <= viewportWidth - tooltipPadding) {
                    left = event.clientX + tooltipPadding;
                } else {
                    left = tooltipPadding;
                }
            }
            
            // ÌïòÎã® Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Ï°∞Ï†ï
            if (top + tooltipRect.height > viewportHeight - tooltipPadding) {
                top = event.clientY - tooltipRect.height - tooltipPadding;
            }
            
            // ÏÉÅÎã® Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Ï°∞Ï†ï
            if (top < tooltipPadding) {
                if (event.clientY + tooltipRect.height + tooltipPadding <= viewportHeight - tooltipPadding) {
                    top = event.clientY + tooltipPadding;
                } else {
                    top = tooltipPadding;
                }
            }
            
            // ÏµúÏ¢Ö Í≤ÄÏ¶ù Î∞è Í∞ïÏ†ú Ï°∞Ï†ï
            if (left < tooltipPadding) left = tooltipPadding;
            if (left + tooltipRect.width > viewportWidth - tooltipPadding) {
                left = viewportWidth - tooltipPadding - tooltipRect.width;
            }
            if (top < tooltipPadding) top = tooltipPadding;
            if (top + tooltipRect.height > viewportHeight - tooltipPadding) {
                top = viewportHeight - tooltipPadding - tooltipRect.height;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.visibility = 'visible';
        }
        
        function hideInterestTooltip() {
            const tooltip = document.getElementById('interest-chart-tooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
                tooltip.style.visibility = 'hidden';
            }
        }
        
        function updateInterestChartHeaderMulti() {
            if (activeInterestCountries.length === 0) return;
            
            // Ï≤´ Î≤àÏß∏ Íµ≠Í∞ÄÏùò Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö© (ÎåÄÌëú Í∏∞Ï§ÄÍ∏àÎ¶¨)
            const firstCountryCode = activeInterestCountries[0];
            const firstCountryData = interestCountryData[firstCountryCode];
            
            if (!firstCountryData || firstCountryData.length === 0) return;
            
            // Ï≤´ Î≤àÏß∏ Íµ≠Í∞ÄÏùò ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Í∏∞Í∞ÑÏùò Í∞íÎì§Îßå ÏÇ¨Ïö©
            const values = firstCountryData.map(item => item.value);
            const high = Math.max(...values);
            const low = Math.min(...values);
            const average = values.reduce((sum, v) => sum + v, 0) / values.length;
            
            // Ï≤´ Î≤àÏß∏ Íµ≠Í∞ÄÏùò ÏµúÏã†Í∞í
            const current = firstCountryData[firstCountryData.length - 1].value;
            const previous = firstCountryData.length > 1
                ? firstCountryData[firstCountryData.length - 2].value
                : current;
            
            const change = current - previous;
            const changePercent = previous !== 0 ? (change / previous) * 100 : 0;
            
            // Ìó§Îçî ÏóÖÎç∞Ïù¥Ìä∏
            const countryInfo = interestCountryMapping[firstCountryCode];
            const countryName = countryInfo ? getInterestCountryNameEnglish(countryInfo.name) : firstCountryCode;
            
            const titleEl = document.getElementById('interest-chart-main-title');
            if (titleEl) titleEl.textContent = countryName + ' Interest Rate';
            
            const valueEl = document.getElementById('interest-chart-main-value');
            if (valueEl) valueEl.textContent = current.toFixed(2) + '%';
            
            // Î≥ÄÌôîÏú® ÌëúÏãú Ïà®ÍπÄ
            const changeContainer = document.getElementById('interest-chart-change');
            if (changeContainer) {
                changeContainer.style.display = 'none';
            }
            const changeValueEl = document.getElementById('interest-change-value');
            const changePercentEl = document.getElementById('interest-change-percent');
            if (changeValueEl && changePercentEl) {
                changeValueEl.textContent = '';
                changePercentEl.textContent = '';
            }
            
            // ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ (Ï≤´ Î≤àÏß∏ Íµ≠Í∞ÄÏùò ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Í∏∞Í∞ÑÎßå)
            const highEl = document.getElementById('interest-stat-high');
            const lowEl = document.getElementById('interest-stat-low');
            const avgEl = document.getElementById('interest-stat-average');
            
            if (highEl) highEl.textContent = high.toFixed(2) + '%';
            if (lowEl) lowEl.textContent = low.toFixed(2) + '%';
            if (avgEl) avgEl.textContent = average.toFixed(2) + '%';
        }
        
        function updateInterestChart() {
            const path = document.getElementById('path-interest');
            const barGroup = document.getElementById('interest-bar-chart');
            const pointsGroup = document.getElementById('interest-data-points');
            
            if (!path || !barGroup || !pointsGroup) return;
            
            if (!interestRateData || interestRateData.length === 0) {
                path.setAttribute('d', '');
                path.classList.remove('visible');
                barGroup.innerHTML = '';
                pointsGroup.innerHTML = '';
                return;
            }
            
            // Ï£ºÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Í∞úÏàò Í≥ÑÏÇ∞
            const unitCount = getInterestDataUnitCount(interestRateData, interestCycle);
            const isSingleUnit = unitCount <= 1;
            
            // Update Y-axis labels
            renderInterestYAxisLabels();
            
            if (isSingleUnit) {
                // 1Í∞ú Îã®ÏúÑ Ïù¥Ìïò: ÎßâÎåÄ Í∑∏ÎûòÌîÑ
                path.setAttribute('d', '');
                path.classList.remove('visible');
                pointsGroup.innerHTML = '';
                renderInterestBarChart();
            } else {
                // 2Í∞ú Îã®ÏúÑ Ïù¥ÏÉÅ: Í∫æÏùÄÏÑ† Í∑∏ÎûòÌîÑ + Ìè¨Ïù∏Ìä∏
                barGroup.innerHTML = '';
                const pathData = generateInterestSVGPath(interestRateData);
                path.setAttribute('d', pathData);
                path.classList.add('visible');
                renderInterestDataPoints();
            }
            
            // Update X-axis labels
            renderInterestXAxisLabels(isSingleUnit);
            
            // Setup interactivity
            setupInterestChartInteractivity();
        }

        // Store handlers for cleanup
        let interestMouseMoveHandler = null;
        let interestMouseLeaveHandler = null;

        function setupInterestChartInteractivity() {
            const chartContainer = document.getElementById('interest-chart-container');
            const svg = document.getElementById('interest-chart-svg');
            
            if (!chartContainer || !svg) return;
            
            // Ensure tooltip is in body
            const tooltip = document.getElementById('interest-chart-tooltip');
            if (tooltip && tooltip.parentElement !== document.body) {
                document.body.appendChild(tooltip);
            }
            
            // Remove existing listeners if they exist
            if (interestMouseMoveHandler) {
                chartContainer.removeEventListener('mousemove', interestMouseMoveHandler);
            }
            if (interestMouseLeaveHandler) {
                chartContainer.removeEventListener('mouseleave', interestMouseLeaveHandler);
            }
            
            // Add new listeners
            let rafId = null;
            
            interestMouseMoveHandler = (e) => {
                if (rafId) return;
                rafId = requestAnimationFrame(() => {
                    rafId = null;
                    
                    if (!interestRateData || interestRateData.length === 0) {
                        hideInterestTooltip();
                        return;
                    }
                    
                    const rect = chartContainer.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const svgX = (x / rect.width) * 1200; // viewBox width
                    
                    const padding = { left: 40, right: 20 };
                    const chartWidth = 1200 - padding.left - padding.right;
                    const dataIndex = Math.round(((svgX - padding.left) / chartWidth) * (interestRateData.length - 1));
                    
                    if (dataIndex >= 0 && dataIndex < interestRateData.length) {
                        const dataPoint = interestRateData[dataIndex];
                        showInterestTooltip(e, dataPoint);
                    } else {
                        hideInterestTooltip();
                    }
                });
            };
            
            interestMouseLeaveHandler = () => {
                hideInterestTooltip();
            };
            
            chartContainer.addEventListener('mousemove', interestMouseMoveHandler);
            chartContainer.addEventListener('mouseleave', interestMouseLeaveHandler);
        }

        function showInterestTooltip(event, dataPoint) {
            const tooltip = document.getElementById('interest-chart-tooltip');
            const tooltipDate = document.getElementById('interest-tooltip-date');
            const tooltipContent = document.getElementById('interest-tooltip-content');
            
            if (!tooltip || !tooltipDate || !tooltipContent || !dataPoint) return;
            
            // Ï£ºÍ∏∞Ïóê Îî∞Îùº ÎÇ†Ïßú Ìè¨Îß∑
            const dateObj = parseInterestDate(dataPoint.date, interestCycle);
            let formattedDate = dataPoint.date;
            
            if (dateObj) {
                formattedDate = formatInterestDate(dateObj, interestCycle);
                tooltipDate.textContent = formattedDate;
            } else {
                // ÌååÏã± Ïã§Ìå® Ïãú ÏõêÎ≥∏ ÌëúÏãú (Ï£ºÍ∏∞Î≥Ñ ÌòïÏãùÏúºÎ°ú Ìè¨Îß∑)
                if (interestCycle === 'M' && dataPoint.date.length === 6) {
                    formattedDate = `${dataPoint.date.substring(0, 4)}/${dataPoint.date.substring(4, 6)}`;
                } else if (interestCycle === 'Q' && dataPoint.date.includes('Q')) {
                    // Î∂ÑÍ∏∞Î≥Ñ: YYQn ÌòïÏãù (Ïòà: 24Q1, 24Q2)
                    const match = dataPoint.date.match(/^(\d{4})Q([1-4])$/);
                    if (match) {
                        const year = match[1].substring(2, 4); // ÎßàÏßÄÎßâ 2ÏûêÎ¶¨
                        const quarter = match[2];
                        formattedDate = `${year}Q${quarter}`;
                    } else {
                        formattedDate = dataPoint.date;
                    }
                    }
                tooltipDate.textContent = formattedDate;
            }
            
            // Show value
            tooltipContent.innerHTML = `
                <div class="chart-tooltip-item">
                    <div class="chart-tooltip-currency">
                        <div class="chart-tooltip-dot" style="background: var(--accent-color);"></div>
                        <span>Í∏∞Ï§ÄÍ∏àÎ¶¨</span>
                    </div>
                    <span class="chart-tooltip-value">${dataPoint.value.toFixed(2)}%</span>
                </div>
            `;
            
            // Position tooltip
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
            tooltip.style.visibility = 'visible';
            tooltip.classList.add('visible');
        }

        function hideInterestTooltip() {
            const tooltip = document.getElementById('interest-chart-tooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
                tooltip.style.visibility = 'hidden';
            }
        }

        function generateInterestSVGPath(data) {
            if (!data || data.length === 0) return '';
            
            const svg = document.getElementById('interest-chart-svg');
            if (!svg) return '';
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Use Y-axis range
            const minValue = interestYAxisRange.min;
            const maxValue = interestYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            let pathData = '';
            data.forEach((point, index) => {
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            return pathData;
        }

        // ÎßâÎåÄ Í∑∏ÎûòÌîÑ Î†åÎçîÎßÅ Ìï®Ïàò (1Í∞ú Îã®ÏúÑÏùº Îïå)
        function renderInterestBarChart() {
            const barGroup = document.getElementById('interest-bar-chart');
            if (!barGroup || !interestRateData || interestRateData.length === 0) return;
            
            barGroup.innerHTML = '';
            
            const svg = document.getElementById('interest-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Ï§ëÏïôÏóê ÎßâÎåÄ ÌëúÏãú
            const centerX = padding.left + chartWidth / 2;
            const barWidth = Math.min(60, chartWidth * 0.3);
            
            // Ï≤´ Î≤àÏß∏ Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ ÏÇ¨Ïö© (1Í∞ú Îã®ÏúÑÏù¥ÎØÄÎ°ú)
            const dataPoint = interestRateData[0];
            const minValue = interestYAxisRange.min;
            const maxValue = interestYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            const normalizedValue = (dataPoint.value - minValue) / valueRange;
            const barHeight = normalizedValue * chartHeight;
            const barY = padding.top + (1 - normalizedValue) * chartHeight;
            
            // ÎßâÎåÄ Í∑∏Î¶¨Í∏∞
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', String(centerX - barWidth / 2));
            rect.setAttribute('y', String(barY));
            rect.setAttribute('width', String(barWidth));
            rect.setAttribute('height', String(barHeight));
            rect.setAttribute('fill', 'var(--accent-color)');
            rect.setAttribute('rx', '4');
            barGroup.appendChild(rect);
        }

        // Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ Î†åÎçîÎßÅ Ìï®Ïàò (Í∫æÏùÄÏÑ† Í∑∏ÎûòÌîÑÏö©)
        function renderInterestDataPoints() {
            const pointsGroup = document.getElementById('interest-data-points');
            if (!pointsGroup || !interestRateData || interestRateData.length === 0) return;
            
            pointsGroup.innerHTML = '';
            
            const svg = document.getElementById('interest-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = interestYAxisRange.min;
            const maxValue = interestYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            // Í∞Å Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏Ïóê ÎèôÍ∑∏ÎùºÎØ∏ Ï∂îÍ∞Ä
            interestRateData.forEach((point, index) => {
                const x = padding.left + (index / (interestRateData.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                // Ïô∏Î∂Ä Ïõê (Î∞∞Í≤Ω)
                const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                outerCircle.setAttribute('cx', String(x));
                outerCircle.setAttribute('cy', String(y));
                outerCircle.setAttribute('r', '5');
                outerCircle.setAttribute('fill', 'var(--bg-color)');
                outerCircle.setAttribute('stroke', 'var(--accent-color)');
                outerCircle.setAttribute('stroke-width', '2');
                pointsGroup.appendChild(outerCircle);
                
                // ÎÇ¥Î∂Ä Ïõê (Ìè¨Ïù∏Ìä∏)
                const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                innerCircle.setAttribute('cx', String(x));
                innerCircle.setAttribute('cy', String(y));
                innerCircle.setAttribute('r', '3');
                innerCircle.setAttribute('fill', 'var(--accent-color)');
                pointsGroup.appendChild(innerCircle);
            });
        }

        function renderInterestYAxisLabels() {
            const svg = document.getElementById('interest-chart-svg');
            const g = document.getElementById('interest-y-axis-labels');
            if (!svg || !g) return;
            
            g.innerHTML = '';
            
            if (!interestRateData || interestRateData.length === 0) return;
            
            // Calculate min/max values
            const values = interestRateData.map(d => d.value);
            let minValue = Math.min(...values);
            let maxValue = Math.max(...values);
            
            // Îã®Ïùº Í∞íÏù∏ Í≤ΩÏö∞ ÎßâÎåÄÍ∑∏ÎûòÌîÑÎ•º ÏúÑÌï¥ YÏ∂ïÏùÑ 0.5 Îã®ÏúÑÎ°ú ÎÇòÎàî
            const isSingleValue = minValue === maxValue;
            const isSingleUnit = getInterestDataUnitCount(interestRateData, interestCycle) <= 1;
            
            if (isSingleValue && isSingleUnit) {
                // ÎßâÎåÄÍ∑∏ÎûòÌîÑÎ•º ÏúÑÌï¥ YÏ∂ïÏùÑ 0.5 Îã®ÏúÑÎ°ú ÏÑ§Ï†ï
                const centerValue = minValue;
                // 0.5 Îã®ÏúÑÎ°ú YÏ∂ï Î≤îÏúÑ ÏÑ§Ï†ï (Ïòà: 2.5Î©¥ 0.0 ~ 3.0)
                interestYAxisRange.min = Math.max(0, Math.floor(centerValue * 2) / 2 - 0.5);
                interestYAxisRange.max = Math.ceil(centerValue * 2) / 2 + 0.5;
                
                // ÏµúÏÜåÍ∞íÏù¥ 0Î≥¥Îã§ ÏûëÏúºÎ©¥ 0ÏúºÎ°ú ÏÑ§Ï†ï
                if (interestYAxisRange.min < 0) {
                    interestYAxisRange.min = 0;
                }
            } else {
                // Calculate range with padding
                const range = maxValue - minValue;
                let paddingPercent = 0.01;
                if (range > 1) {
                    paddingPercent = 0.003;
                } else if (range > 0.1) {
                    paddingPercent = 0.005;
                }
                
                const padding = range * paddingPercent;
                const calculatedMin = minValue - padding;
                const calculatedMax = maxValue + padding;
                
                const minValueRatio = minValue / (maxValue || 1);
                if (calculatedMin < 0 || (minValueRatio < 0.05 && minValue < range * 0.1)) {
                    interestYAxisRange.min = 0;
                    interestYAxisRange.max = maxValue + padding + Math.abs(Math.min(0, calculatedMin));
                } else {
                    interestYAxisRange.min = calculatedMin;
                    interestYAxisRange.max = calculatedMax;
                }
            }
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding_axis = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartHeight = height - padding_axis.top - padding_axis.bottom;
            
            const numLabels = 6;
            const step = (interestYAxisRange.max - interestYAxisRange.min) / (numLabels - 1);
            
            for (let i = 0; i < numLabels; i++) {
                const value = interestYAxisRange.max - (step * i);
                const y = padding_axis.top + (i / (numLabels - 1)) * chartHeight;
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', String(padding_axis.left - 10));
                label.setAttribute('y', String(y));
                label.setAttribute('class', 'chart-yaxis-label');
                label.textContent = value.toLocaleString('ko-KR', {
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 1
                });
                g.appendChild(label);
            }
        }

        function renderInterestXAxisLabels(isSingleUnit = false) {
            const svg = document.getElementById('interest-chart-svg');
            const g = document.getElementById('interest-x-axis-labels');
            if (!svg || !g) return;
            
            g.innerHTML = '';
            
            if (!interestRateData || interestRateData.length === 0) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { left: 40, right: 20, top: 20, bottom: 30 };
            const chartWidth = width - padding.left - padding.right;
            const y = height - padding.bottom + 15;
            
            if (isSingleUnit) {
                // 1Í∞ú Îã®ÏúÑ: Ï§ëÏïôÏóê Î†àÏù¥Î∏î ÌëúÏãú
                const centerX = padding.left + chartWidth / 2;
                const dataPoint = interestRateData[0];
                let label = '';
                
                if (interestCycle === 'M' && dataPoint.date.length === 6) {
                    // ÏõîÎ≥Ñ: YY.MM ÌòïÏãùÏúºÎ°ú Î™ÖÌôïÌïòÍ≤å ÌëúÏãú
                    const year = dataPoint.date.substring(2, 4);
                    const month = dataPoint.date.substring(4, 6);
                    label = `${year}.${month}`;
                } else if (interestCycle === 'Q' && dataPoint.date.includes('Q')) {
                    // Î∂ÑÍ∏∞Î≥Ñ: YYQn ÌòïÏãù (Ïòà: 24Q1, 24Q2)
                    const match = dataPoint.date.match(/^(\d{4})Q([1-4])$/);
                    if (match) {
                        const year = match[1].substring(2, 4); // ÎßàÏßÄÎßâ 2ÏûêÎ¶¨
                        const quarter = match[2];
                        label = `${year}Q${quarter}`;
                    } else {
                        label = dataPoint.date;
                    }
                } else {
                    label = dataPoint.date;
                }
                
                const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                t.setAttribute('x', String(centerX));
                t.setAttribute('y', String(y));
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'middle');
                t.setAttribute('class', 'chart-xaxis-label');
                t.textContent = label;
                g.appendChild(t);
            } else {
                // 2Í∞ú Ïù¥ÏÉÅ: Í∏∞Ï°¥ Î°úÏßÅ ÏÇ¨Ïö©
                const dates = interestRateData.map(d => d.date);
                const rangeKey = getInterestRangeKey();
                const targets = buildInterestXAxisTargets(rangeKey, dates);
                const n = dates.length;
                
                for (const tInfo of targets) {
                    const i = tInfo.idx;
                    let x = padding.left + (i / (n - 1 || 1)) * chartWidth;
                    
                    // ÎßàÏßÄÎßâ Î†àÏù¥Î∏îÏù∏ Í≤ΩÏö∞ Ïò§Î•∏Ï™Ω Ïó¨Î∞± Í≥†Î†§ (ÌÖçÏä§Ìä∏Í∞Ä ÏûòÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù)
                    if (i === n - 1 && n > 1) {
                        // ÌÖçÏä§Ìä∏ ÎÑàÎπÑÎ•º Í≥†Î†§ÌïòÏó¨ ÏúÑÏπò Ï°∞Ï†ï (ÎåÄÎûµ 40px Ïó¨Ïú†)
                        x = Math.min(x, width - padding.right - 20);
                    }
                    
                    const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    t.setAttribute('x', x.toFixed(2));
                    t.setAttribute('y', String(y));
                    t.setAttribute('text-anchor', 'middle');
                    t.setAttribute('dominant-baseline', 'middle');
                    t.setAttribute('class', 'chart-xaxis-label');
                    t.textContent = tInfo.label;
                    g.appendChild(t);
                }
            }
        }

        function getInterestRangeKey() {
            // Map cycle to range key for X-axis formatting
            const cycleMap = {
                'A': '1Y',
                'M': '3M',
                'Q': '1Y'
            };
            return cycleMap[interestCycle] || '3M';
        }

        function buildInterestXAxisTargets(rangeKey, dates) {
            const n = dates.length;
            if (n === 0) return [];
            
            // ÏùºÏ†ïÌïú Í∞ÑÍ≤©ÏúºÎ°ú ÎùºÎ≤® ÌëúÏãú (Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ)
            const targets = [];
            let labelIndices = [];
            
            if (interestCycle === 'M') {
                // ÏõîÎ≥Ñ: Îß§ 2Í∞úÏõîÎßàÎã§ ÌëúÏãú
                for (let i = 0; i < n; i += 2) {
                    labelIndices.push(i);
                }
            } else if (interestCycle === 'Q') {
                // Î∂ÑÍ∏∞Î≥Ñ: Î™®Îì† Î∂ÑÍ∏∞ ÌëúÏãú
                for (let i = 0; i < n; i++) {
                    labelIndices.push(i);
                }
            }
            
            // Ï≤´ Î≤àÏß∏ÏôÄ ÎßàÏßÄÎßâ ÎùºÎ≤®ÏùÄ Ìï≠ÏÉÅ Ìè¨Ìï®
            if (labelIndices.length === 0 || labelIndices[0] !== 0) {
                labelIndices.unshift(0);
            }
            if (labelIndices[labelIndices.length - 1] !== n - 1) {
                labelIndices.push(n - 1);
            }
            
            // Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è Ï†ïÎ†¨
            labelIndices = [...new Set(labelIndices)].sort((a, b) => a - b);
            
            for (const i of labelIndices) {
                const dateStr = dates[i];
                let label = dateStr;
                
                if (interestCycle === 'M' && dateStr.length === 6) {
                    // ÏõîÎ≥Ñ: Ìï≠ÏÉÅ Ïó∞ÎèÑ.Ïõî ÌòïÏãùÏúºÎ°ú Î™ÖÌôïÌïòÍ≤å ÌëúÏãú
                    const year = dateStr.substring(2, 4);
                    const month = dateStr.substring(4, 6);
                    label = `${year}.${month}`;
                } else if (interestCycle === 'Q' && dateStr.includes('Q')) {
                    // Î∂ÑÍ∏∞Î≥Ñ: YYQn ÌòïÏãù (Ïòà: 24Q1, 24Q2)
                    const match = dateStr.match(/^(\d{4})Q([1-4])$/);
                    if (match) {
                        const year = match[1].substring(2, 4); // ÎßàÏßÄÎßâ 2ÏûêÎ¶¨
                        const quarter = match[2];
                        label = `${year}Q${quarter}`;
                    } else {
                        label = dateStr;
                    }
                }
                
                if (label) {
                    targets.push({ idx: i, label: label });
                }
            }
            
            return targets;
        }

        function updateInterestChartHeader(stats) {
            if (!stats || stats.error) {
                document.getElementById('interest-chart-main-title').textContent = 'Í∏∞Ï§ÄÍ∏àÎ¶¨';
                document.getElementById('interest-chart-main-value').textContent = '-';
                document.getElementById('interest-change-value').textContent = '-';
                document.getElementById('interest-change-percent').textContent = '(-)';
                document.getElementById('interest-stat-high').textContent = '-';
                document.getElementById('interest-stat-low').textContent = '-';
                document.getElementById('interest-stat-average').textContent = '-';
                return;
            }
            
            // Update current value
            const currentValueEl = document.getElementById('interest-chart-main-value');
            const targetValue = stats.current;
            const currentValue = parseFloat(currentValueEl.textContent.replace(/,/g, '')) || 0;
            if (currentValue !== targetValue) {
                animateValue(currentValueEl, currentValue, targetValue, 800);
            } else {
                currentValueEl.textContent = targetValue.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
            
            // Update change
            const change = stats.change;
            const changePercent = stats.changePercent;
            const isUp = change >= 0;
            
            const changeValueEl = document.getElementById('interest-change-value');
            const changePercentEl = document.getElementById('interest-change-percent');
            
            changeValueEl.textContent = `${isUp ? '+' : ''}${change.toFixed(2)}`;
            changePercentEl.textContent = `(${isUp ? '+' : ''}${changePercent.toFixed(2)}%)`;
            
            changeValueEl.className = `change-value ${isUp ? 'up' : 'down'}`;
            changePercentEl.className = `change-percent ${isUp ? 'up' : 'down'}`;
            
            // Update statistics
            const statHighEl = document.getElementById('interest-stat-high');
            const statLowEl = document.getElementById('interest-stat-low');
            const statAverageEl = document.getElementById('interest-stat-average');
            
            const currentHigh = parseFloat(statHighEl.textContent.replace(/,/g, '')) || 0;
            const currentLow = parseFloat(statLowEl.textContent.replace(/,/g, '')) || 0;
            const currentAverage = parseFloat(statAverageEl.textContent.replace(/,/g, '')) || 0;
            
            if (currentHigh !== stats.high) {
                animateValue(statHighEl, currentHigh, stats.high, 800);
            } else {
                statHighEl.textContent = stats.high.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
            
            if (currentLow !== stats.low) {
                animateValue(statLowEl, currentLow, stats.low, 800);
            } else {
                statLowEl.textContent = stats.low.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
            
            if (currentAverage !== stats.average) {
                animateValue(statAverageEl, currentAverage, stats.average, 800);
            } else {
                statAverageEl.textContent = stats.average.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
        }

        function updateChartHeader(currency, stats) {
            if (!stats || stats.error) {
                // Í∏∞Î≥∏Í∞í ÌëúÏãú
                document.getElementById('chart-main-title').textContent = `${currency}/KRW`;
                document.getElementById('chart-main-value').textContent = '-';
                document.getElementById('change-value').textContent = '-';
                document.getElementById('change-percent').textContent = '(-)';
                document.getElementById('stat-high').textContent = '-';
                document.getElementById('stat-low').textContent = '-';
                document.getElementById('stat-average').textContent = '-';
                return;
            }
            
            // Ï†úÎ™© ÏóÖÎç∞Ïù¥Ìä∏
            document.getElementById('chart-main-title').textContent = `${currency}/KRW`;
            
            // ÌòÑÏû¨Í∞í ÏóÖÎç∞Ïù¥Ìä∏ (Ïπ¥Ïö¥Ìä∏ÏóÖ Ïï†ÎãàÎ©îÏù¥ÏÖò)
            const currentValueEl = document.getElementById('chart-main-value');
            const targetValue = stats.current;
            const currentValue = parseFloat(currentValueEl.textContent.replace(/,/g, '')) || 0;
            if (currentValue !== targetValue) {
                animateValue(currentValueEl, currentValue, targetValue, 800);
            } else {
                currentValueEl.textContent = targetValue.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
            
            // Î≥ÄÎèôÎ•† ÏóÖÎç∞Ïù¥Ìä∏
            const change = stats.change;
            const changePercent = stats.changePercent;
            const isUp = change >= 0;
            
            const changeValueEl = document.getElementById('change-value');
            const changePercentEl = document.getElementById('change-percent');
            
            changeValueEl.textContent = `${isUp ? '+' : ''}${change.toFixed(2)}`;
            changePercentEl.textContent = `(${isUp ? '+' : ''}${changePercent.toFixed(2)}%)`;
            
            changeValueEl.className = `change-value ${isUp ? 'up' : 'down'}`;
            changePercentEl.className = `change-percent ${isUp ? 'up' : 'down'}`;
            
            // ÌÜµÍ≥Ñ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
            const statHighEl = document.getElementById('stat-high');
            const statLowEl = document.getElementById('stat-low');
            const statAverageEl = document.getElementById('stat-average');
            
            const currentHigh = parseFloat(statHighEl.textContent.replace(/,/g, '')) || 0;
            const currentLow = parseFloat(statLowEl.textContent.replace(/,/g, '')) || 0;
            const currentAverage = parseFloat(statAverageEl.textContent.replace(/,/g, '')) || 0;
            
            if (currentHigh !== stats.high) {
                animateValue(statHighEl, currentHigh, stats.high, 800);
            } else {
                statHighEl.textContent = stats.high.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
            
            if (currentLow !== stats.low) {
                animateValue(statLowEl, currentLow, stats.low, 800);
            } else {
                statLowEl.textContent = stats.low.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
            
            if (currentAverage !== stats.average) {
                animateValue(statAverageEl, currentAverage, stats.average, 800);
            } else {
                statAverageEl.textContent = stats.average.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
        }

        function animateValue(element, start, end, duration) {
            if (!element || isNaN(start) || isNaN(end)) return;
            
            const startTime = performance.now();
            const difference = end - start;
            
            function update(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (ease-out)
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                const current = start + (difference * easeProgress);
                
                element.textContent = current.toLocaleString('ko-KR', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            requestAnimationFrame(update);
        }

        // ========== INFLATION (Î¨ºÍ∞Ä) FUNCTIONS ==========
        // Raw CPI index-level series from API: { [itemCode]: [{date, value}] }
        let inflationData = {};
        // Îã®Ïùº ÏÑ†ÌÉù(ÎùºÎîîÏò§Ï≤òÎüº 1Í∞úÎßå Ïú†ÏßÄ)
        let activeInflationItems = ['CPI_TOTAL'];
        // ÌëúÏãú Î©îÌä∏Î¶≠: ÏßÄÏàò Î†àÎ≤®(ÏõêÏûêÎ£å) + Ï†ÑÏõîÎπÑ/Ï†ÑÍ∏∞ÎπÑ(Î≥ÄÌôîÎüâ/Î≥ÄÌôîÏú®)
        let inflationYAxisRange = { min: 0, max: 0 };
        let inflationCycle = 'M'; // Current cycle (M, Q)
        
        // International CPI Variables
        let activeInflationCountries = []; // ÌôúÏÑ±ÌôîÎêú Íµ≠Í∞Ä Î™©Î°ù (item_code)
        let inflationCountryData = {}; // Íµ≠Í∞ÄÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• { 'item_code': [{date, value}], ... }
        let inflationCountryMapping = {}; // item_code ‚Üí {code, name} Îß§Ìïë
        let inflationCountryListLoaded = false; // Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎìú Ïó¨Î∂Ä

        const INFLATION_ITEM_NAMES = {
            'CPI_TOTAL': 'Ï¥ùÏßÄÏàò',
            'CPI_FRESH': 'Ïã†ÏÑ†ÏãùÌíà',
            'CPI_INDUSTRIAL': 'Í≥µÏóÖÏ†úÌíà'
        };

        const INFLATION_ITEM_COLORS = {
            'CPI_TOTAL': 'var(--c-cpi-total)',
            'CPI_FRESH': 'var(--c-cpi-fresh)',
            'CPI_INDUSTRIAL': 'var(--c-cpi-industrial)'
        };

        function parseInflationDate(dateStr, cycle) {
            if (!dateStr) return null;
            if (cycle === 'M') {
                // YYYYMM
                if (dateStr.length === 6) {
                    const year = parseInt(dateStr.substring(0, 4), 10);
                    const month = parseInt(dateStr.substring(4, 6), 10) - 1;
                    return new Date(year, month, 1);
                }
            } else if (cycle === 'Q') {
                // YYYYQn
                const match = dateStr.match(/^(\d{4})Q([1-4])$/);
                if (match) {
                    const year = parseInt(match[1], 10);
                    const q = parseInt(match[2], 10);
                    const month = (q - 1) * 3;
                    return new Date(year, month, 1);
                }
            }
            return null;
        }

        function compareInflationDates(a, b, cycle) {
            const da = parseInflationDate(a, cycle);
            const db = parseInflationDate(b, cycle);
            if (!da || !db) return String(a).localeCompare(String(b));
            return da.getTime() - db.getTime();
        }

        function formatInflationPeriodLabel(dateStr, cycle) {
            if (!dateStr) return '';
            if (cycle === 'M' && dateStr.length === 6) {
                const yy = dateStr.substring(2, 4);
                const mm = dateStr.substring(4, 6);
                return `${yy}.${mm}`;
            }
            if (cycle === 'Q') {
                const match = dateStr.match(/^(\d{4})Q([1-4])$/);
                if (match) {
                    const yy = match[1].substring(2, 4);
                    const q = match[2];
                    return `${yy}Q${q}`;
                }
            }
            return dateStr;
        }

        function getInflationMetricLabel(cycle) {
            // UI ÏöîÍµ¨ÏÇ¨Ìï≠: ÏõîÎ≥ÑÏùÄ Ï†ÑÏõîÎπÑ, Î∂ÑÍ∏∞Î≥ÑÏùÄ Ï†ÑÍ∏∞ÎπÑ
            return cycle === 'Q' ? 'Ï†ÑÍ∏∞ÎπÑ' : 'Ï†ÑÏõîÎπÑ';
        }

        function calculateInflationIndexStats(rawSeries, cycle) {
            if (!Array.isArray(rawSeries) || rawSeries.length === 0) {
                return { current: 0, change: 0, changePercent: 0, high: 0, low: 0, average: 0, hasData: false };
            }
            const sorted = [...rawSeries].sort((a, b) => compareInflationDates(a.date, b.date, cycle));
            const values = sorted.map(d => d.value).filter(v => Number.isFinite(v));
            if (values.length === 0) {
                return { current: 0, change: 0, changePercent: 0, high: 0, low: 0, average: 0, hasData: false };
            }
            const current = values[values.length - 1];
            const prev = values.length >= 2 ? values[values.length - 2] : null;
            const change = prev == null ? 0 : (current - prev);
            // Ï†ÑÏõîÎπÑ/Ï†ÑÍ∏∞ÎπÑ(%)Îäî ÏßÅÏ†Ñ Í∞í ÎåÄÎπÑ
            const changePercent = prev == null || prev === 0 ? 0 : (change / prev) * 100;
            const high = Math.max(...values);
            const low = Math.min(...values);
            const average = values.reduce((a, b) => a + b, 0) / values.length;
            return { current, change, changePercent, high, low, average, hasData: true };
        }

        function initInflation() {
            const startDateInput = document.getElementById('inflation-start-date');
            const endDateInput = document.getElementById('inflation-end-date');
            
            if (startDateInput && endDateInput) {
                const end = new Date();
                const start = new Date();
                // ÏõîÎ≥Ñ Í∏∞Î≥∏Í∞í: ÌòÑÏû¨ ÏõîÏùÑ Ìè¨Ìï®Ìï¥ÏÑú Í≥ºÍ±∞ 12Í∞úÏõî
                start.setMonth(end.getMonth() - 11); // 12Í∞úÏõî (ÌòÑÏû¨Ïõî Ìè¨Ìï®)
                start.setDate(1); // Ìï¥Îãπ ÏõîÏùò 1ÏùºÎ°ú ÏÑ§Ï†ï
                
                startDateInput.value = start.toISOString().split('T')[0];
                endDateInput.value = end.toISOString().split('T')[0];
                startDateInput.max = endDateInput.value;
                endDateInput.max = endDateInput.value;
                
                startDateInput.addEventListener('change', () => {
                    if (validateInflationDateRange()) {
                        fetchInflationData();
                    }
                });
                endDateInput.addEventListener('change', () => {
                    if (validateInflationDateRange()) {
                        fetchInflationData();
                    }
                });
            }
            
            // Ï£ºÍ∏∞ Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä (Interest RatesÏôÄ ÎèôÏùº)
            document.querySelectorAll('.inflation-cycle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.inflation-cycle-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    inflationCycle = this.getAttribute('data-cycle');
                    
                    const endDateInput = document.getElementById('inflation-end-date');
                    const startDateInput = document.getElementById('inflation-start-date');
                    
                    if (!endDateInput || !startDateInput) {
                        fetchInflationData();
                        return;
                    }
                    
                    // ÏõîÎ≥Ñ(M) ÏÑ†ÌÉù Ïãú ÌòÑÏû¨ ÏõîÏùÑ Ìè¨Ìï®Ìï¥ÏÑú Í≥ºÍ±∞ 12Í∞úÏõî
                    if (inflationCycle === 'M') {
                        const end = new Date();
                        const start = new Date();
                        start.setMonth(end.getMonth() - 11); // 12Í∞úÏõî (ÌòÑÏû¨Ïõî Ìè¨Ìï®)
                        start.setDate(1); // Ìï¥Îãπ ÏõîÏùò 1ÏùºÎ°ú ÏÑ§Ï†ï
                        
                        startDateInput.value = start.toISOString().split('T')[0];
                        endDateInput.value = end.toISOString().split('T')[0];
                        startDateInput.max = endDateInput.value;
                        endDateInput.max = endDateInput.value;
                        
                        // date inputÏùÑ Îã§Ïãú ÌëúÏãú
                        startDateInput.type = 'date';
                        endDateInput.type = 'date';
                    }
                    // Î∂ÑÍ∏∞Î≥Ñ(Q) ÏÑ†ÌÉù Ïãú ÌòÑÏû¨Ïùº Í∏∞Ï§ÄÏúºÎ°ú 2Í∞úÎÖÑ Period ÏûêÎèô ÏÑ§Ï†ï (Ï¥ù 8Í∞ú Î∂ÑÍ∏∞)
                    else if (inflationCycle === 'Q') {
                        const end = new Date();
                        const start = new Date();
                        start.setFullYear(end.getFullYear() - 2); // 2Í∞úÎÖÑ (ÌòÑÏû¨ÎÖÑ Ìè¨Ìï®)
                        
                        startDateInput.type = 'date';
                        endDateInput.type = 'date';
                        
                        const startDateStr = start.toISOString().split('T')[0];
                        const endDateStr = end.toISOString().split('T')[0];
                        
                        startDateInput.value = startDateStr;
                        endDateInput.value = endDateStr;
                        startDateInput.max = endDateStr;
                        endDateInput.max = endDateStr;
                    }
                    
                    fetchInflationData();
                });
            });
            
            fetchInflationData();
            // Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎìú
            fetchInflationCountryList().then(() => {
                initInflationCountryChips();
            }).catch(err => {
                console.error('Failed to load inflation country list:', err);
            });
            window.inflationDataLoaded = true;
        }
        
        // International CPI Functions
        async function fetchInflationCountryList() {
            if (inflationCountryListLoaded && Object.keys(inflationCountryMapping).length > 0) {
                return inflationCountryMapping;
            }
            
            try {
                const url = `${API_BASE}/market/categories?category=cpi-international`;
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.items && Object.keys(data.items).length > 0) {
                        inflationCountryMapping = data.items;
                        inflationCountryListLoaded = true;
                        return inflationCountryMapping;
                    }
                }
                
                throw new Error('Failed to fetch country list from categories endpoint');
                
            } catch (err) {
                console.error('Failed to fetch inflation country list:', err);
                throw err;
            }
        }
        
        function initInflationCountryChips() {
            const chipsContainer = document.getElementById('inflation-country-chips');
            if (!chipsContainer) return;
            
            chipsContainer.innerHTML = '';
            
            const itemCodes = Object.keys(inflationCountryMapping);
            if (itemCodes.length === 0) {
                chipsContainer.innerHTML = '<span style="color: var(--text-sub); font-size: 0.8rem;">Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎî© Ï§ë...</span>';
                return;
            }
            
            itemCodes.forEach(itemCode => {
                const countryInfo = inflationCountryMapping[itemCode];
                // ÌïúÍµ≠ Î≤ÑÌäº Ï†úÍ±∞
                const name = countryInfo.name.toLowerCase();
                if (name.includes('ÌïúÍµ≠') || name.includes('kor') || name.includes('korea')) {
                    return; // ÌïúÍµ≠ÏùÄ Í±¥ÎÑàÎõ∞Í∏∞
                }
                
                const chip = document.createElement('button');
                chip.className = 'chip';
                chip.setAttribute('data-item-code', itemCode);
                chip.setAttribute('title', countryInfo.name);
                
                const isActive = activeInflationCountries.includes(itemCode);
                if (isActive) {
                    chip.classList.add('active');
                }
                
                // Íµ≠Í∞ÄÎ≥Ñ Í∑∏ÎûòÌîÑ ÏÉâÏÉÅ Í∞ÄÏ†∏Ïò§Í∏∞
                const countryColor = getInflationCountryColor(itemCode);
                
                const chipDot = document.createElement('div');
                chipDot.className = 'chip-dot';
                // active ÏÉÅÌÉúÏùº ÎïåÎßå ÏÉâÏÉÅ Ï†ÅÏö©
                if (isActive) {
                    chipDot.style.background = countryColor;
                    chip.style.borderColor = countryColor;
                    chip.style.color = countryColor;
                    // CSS Î≥ÄÏàòÎ•º Ïã§Ï†ú ÏÉâÏÉÅÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ Î∞∞Í≤ΩÏÉâ ÏÑ§Ï†ï
                    const tempEl = document.createElement('div');
                    tempEl.style.color = countryColor;
                    document.body.appendChild(tempEl);
                    const computedColor = window.getComputedStyle(tempEl).color;
                    document.body.removeChild(tempEl);
                    // RGB Í∞íÏùÑ Ï∂îÏ∂úÌïòÏó¨ Ìà¨Î™ÖÎèÑ Ï†ÅÏö©
                    const rgbMatch = computedColor.match(/\d+/g);
                    if (rgbMatch && rgbMatch.length >= 3) {
                        chip.style.background = `rgba(${rgbMatch[0]}, ${rgbMatch[1]}, ${rgbMatch[2]}, 0.2)`;
                    }
                } else {
                    chipDot.style.background = 'currentColor';
                }
                
                chip.appendChild(chipDot);
                chip.appendChild(document.createTextNode(countryInfo.name));
                
                chip.addEventListener('click', () => toggleInflationCountry(itemCode));
                
                chipsContainer.appendChild(chip);
            });
        }
        
        function getInflationCountryColor(itemCode) {
            // Íµ≠Í∞ÄÎ≥Ñ ÏÉâÏÉÅ Îß§Ìïë (exchange rateÎÇò interest rateÏôÄ Ïú†ÏÇ¨Ìïú ÏÉâÏÉÅ ÏÇ¨Ïö©)
            const colorMap = {
                '0000001': 'var(--c-usd)', // ÎØ∏Íµ≠
                '0000002': 'var(--c-jpy)', // ÏùºÎ≥∏
                '0000003': 'var(--c-eur)', // Ïú†Î°ú
                '0000004': 'var(--c-gbp)', // ÏòÅÍµ≠
                '0000005': 'var(--c-cny)', // Ï§ëÍµ≠
            };
            // Í∏∞Î≥∏ ÏÉâÏÉÅ ÌåîÎ†àÌä∏
            const defaultColors = [
                'var(--c-usd)', 'var(--c-jpy)', 'var(--c-eur)', 'var(--c-gbp)', 'var(--c-cny)',
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE'
            ];
            return colorMap[itemCode] || defaultColors[Object.keys(inflationCountryMapping).indexOf(itemCode) % defaultColors.length];
        }
        
        function toggleInflationCountry(itemCode) {
            const index = activeInflationCountries.indexOf(itemCode);
            
            // ÌÜ†Í∏Ä: ÏûàÏúºÎ©¥ Ï†úÍ±∞, ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
            if (index === -1) {
                activeInflationCountries.push(itemCode);
            } else {
                activeInflationCountries.splice(index, 1);
            }
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            const chip = document.querySelector(`#inflation-country-chips [data-item-code="${itemCode}"]`);
            if (chip) {
                const chipDot = chip.querySelector('.chip-dot');
                const isActive = activeInflationCountries.includes(itemCode);
                
                if (isActive) {
                    chip.classList.add('active');
                    const countryColor = getInflationCountryColor(itemCode);
                    if (chipDot) {
                        chipDot.style.background = countryColor;
                    }
                    chip.style.borderColor = countryColor;
                    chip.style.color = countryColor;
                    const tempEl = document.createElement('div');
                    tempEl.style.color = countryColor;
                    document.body.appendChild(tempEl);
                    const computedColor = window.getComputedStyle(tempEl).color;
                    document.body.removeChild(tempEl);
                    const rgbMatch = computedColor.match(/\d+/g);
                    if (rgbMatch && rgbMatch.length >= 3) {
                        chip.style.background = `rgba(${rgbMatch[0]}, ${rgbMatch[1]}, ${rgbMatch[2]}, 0.2)`;
                    }
                } else {
                    chip.classList.remove('active');
                    if (chipDot) {
                        chipDot.style.background = 'currentColor';
                    }
                    chip.style.borderColor = '';
                    chip.style.color = '';
                    chip.style.background = '';
                }
            }
            
            // Îç∞Ïù¥ÌÑ∞ Ïû¨Ï°∞Ìöå
            if (validateInflationDateRange()) {
                fetchInflationData();
            }
        }

        function validateInflationDateRange() {
            const startDateInput = document.getElementById('inflation-start-date');
            const endDateInput = document.getElementById('inflation-end-date');
            
            if (!startDateInput || !endDateInput) return false;
            
            // ÎÇ†Ïßú Í≤ÄÏ¶ù
            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);
            
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                alert('Ïú†Ìö®Ìïú ÎÇ†ÏßúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
                return false;
            }
            
            if (startDate > endDate) {
                alert('ÏãúÏûëÏùºÏùÄ Ï¢ÖÎ£åÏùºÎ≥¥Îã§ ÏïûÏÑúÏïº Ìï©ÎãàÎã§.');
                return false;
            }
            
            return true;
        }

        // setInflationPeriod Ìï®ÏàòÎäî Ï†úÍ±∞Îê® - Ï£ºÍ∏∞ Î≤ÑÌäºÏúºÎ°ú ÎåÄÏ≤¥Îê®

        function toggleInflationItem(itemCode) {
            // Îã®Ïùº ÏÑ†ÌÉù(ÎùºÎîîÏò§): Ìï≠ÏÉÅ 1Í∞úÎßå active Ïú†ÏßÄ
            const panel = document.getElementById('inflation-panel');
            if (!panel) return;
            const chip = panel.querySelector(`.chip[data-item="${itemCode}"]`);
            if (!chip) return;
            
            // Î™®Îì† Ïπ© ÎπÑÌôúÏÑ±Ìôî
            panel.querySelectorAll('.chip[data-item]').forEach(btn => btn.classList.remove('active'));
            // ÏÑ†ÌÉù Ïπ© ÌôúÏÑ±Ìôî
                chip.classList.add('active');
            activeInflationItems = [itemCode];
            
            fetchInflationData();
        }

        async function fetchInflationData() {
            if (!validateInflationDateRange()) return;
            
            const startDateInput = document.getElementById('inflation-start-date');
            const endDateInput = document.getElementById('inflation-end-date');
            
            const selectedItem = activeInflationItems && activeInflationItems.length > 0 ? activeInflationItems[0] : null;
            if (!startDateInput || !endDateInput || !selectedItem) {
                console.warn('Inflation: Missing inputs or no active items');
                return;
            }
            
            let startDate = formatDateForAPI(startDateInput.value);
            let endDate = formatDateForAPI(endDateInput.value);
            
            // API Ìò∏Ï∂ú Ïãú cycle ÌååÎùºÎØ∏ÌÑ∞Î•º ÎèôÏ†ÅÏúºÎ°ú ÏÇ¨Ïö©
            const apiCycle = inflationCycle;
            
            console.log('Fetching inflation data:', {
                item: selectedItem,
                startDate,
                endDate,
                cycle: inflationCycle,
                apiCycle: apiCycle,
                countries: activeInflationCountries
            });
            
            const chartContainer = document.getElementById('inflation-chart-container');
            if (chartContainer) {
                chartContainer.style.opacity = '0.5';
            }
            
            try {
                // 1. ÌïúÍµ≠ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (Í∏∞Ï°¥ Î°úÏßÅ)
                const koreaUrl = `${API_BASE}/market/indices?type=inflation&itemCode=${selectedItem}&startDate=${startDate}&endDate=${endDate}&cycle=${apiCycle}`;
                console.log(`Fetching Korean inflation data from: ${koreaUrl}`);
                const koreaRes = await fetch(koreaUrl);
                if (!koreaRes.ok) {
                    throw new Error(`HTTP ${koreaRes.status}: ${koreaRes.statusText}`);
                }
                const koreaData = await koreaRes.json();
                if (koreaData.error) {
                    throw new Error(String(koreaData.error));
                }
                if (!koreaData.StatisticSearch || !Array.isArray(koreaData.StatisticSearch.row)) {
                    throw new Error('Invalid API response (missing StatisticSearch.row)');
                }

                const koreaProcessed = koreaData.StatisticSearch.row.map(row => ({
                    date: row.TIME,
                    value: parseFloat(row.DATA_VALUE)
                })).filter(item => Number.isFinite(item.value) && item.value > 0);

                inflationData = { [selectedItem]: koreaProcessed };
                
                // 2. ÏÑ†ÌÉùÎêú Íµ≠Í∞ÄÎì§Ïùò Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
                if (activeInflationCountries.length > 0) {
                    const countryFetchPromises = activeInflationCountries.map(async (itemCode) => {
                        const url = `${API_BASE}/market/indices?type=cpi-international&itemCode=${itemCode}&startDate=${startDate}&endDate=${endDate}&cycle=${apiCycle}`;
                        try {
                            const res = await fetch(url);
                            if (!res.ok) {
                                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                            }
                            const data = await res.json();
                            if (data.error) {
                                throw new Error(String(data.error));
                            }
                            if (!data.StatisticSearch || !Array.isArray(data.StatisticSearch.row)) {
                                throw new Error('Invalid API response (missing StatisticSearch.row)');
                            }
                            
                            const processed = data.StatisticSearch.row.map(row => ({
                                date: row.TIME,
                                value: parseFloat(row.DATA_VALUE)
                            })).filter(item => Number.isFinite(item.value) && item.value > 0);
                            
                            return { itemCode, data: processed };
                        } catch (err) {
                            console.error(`Failed to fetch CPI data for country ${itemCode}:`, err);
                            return { itemCode, data: [] };
                        }
                    });
                    
                    const countryResults = await Promise.all(countryFetchPromises);
                    countryResults.forEach(({ itemCode, data }) => {
                        inflationCountryData[itemCode] = data;
                    });
                } else {
                    inflationCountryData = {};
                }

                // Update chart (ÏßÄÏàò Î†àÎ≤® Í∏∞Ï§Ä Î†åÎçîÎßÅ)
                updateInflationChart();
                
                // Ìó§Îçî/ÌÜµÍ≥ÑÎäî ÌïúÍµ≠ Îç∞Ïù¥ÌÑ∞ Í∏∞Ï§Ä + Ï†ÑÏõîÎπÑ/Ï†ÑÍ∏∞ÎπÑ(Î≥ÄÌôîÎüâ/Î≥ÄÌôîÏú®) Í≥ÑÏÇ∞
                const stats = calculateInflationIndexStats(koreaProcessed, inflationCycle);
                if (stats && stats.hasData) {
                    updateInflationChartHeader(stats, selectedItem);
                } else {
                    updateInflationChartHeader({ current: 0, change: 0, changePercent: 0, high: 0, low: 0, average: 0, hasData: false }, selectedItem);
                }
                
            } catch (err) {
                console.error('Failed to fetch inflation data:', err);
                alert('Î¨ºÍ∞Ä Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + err.message);
            } finally {
                if (chartContainer) {
                    chartContainer.style.opacity = '1';
                }
            }
        }

        function updateInflationChart() {
            const svg = document.getElementById('inflation-chart-svg');
            const pointsGroup = document.getElementById('inflation-data-points');
            const barGroup = document.getElementById('inflation-bar-chart');
            
            if (!svg || !pointsGroup) return;
            
            // ÌïúÍµ≠ Ìï≠Î™© path Ï†ïÎ¶¨
            const allItems = ['CPI_TOTAL', 'CPI_FRESH', 'CPI_INDUSTRIAL'];
            allItems.forEach(itemCode => {
                const path = document.getElementById(`path-inflation-${itemCode}`);
                if (path) {
                    path.setAttribute('d', '');
                    path.classList.remove('visible');
                }
            });
            
            // Íµ≠Í∞Ä path Ï†ïÎ¶¨
            Object.keys(inflationCountryMapping).forEach(itemCode => {
                let path = document.getElementById(`path-inflation-country-${itemCode}`);
                if (path) {
                    path.setAttribute('d', '');
                    path.classList.remove('visible');
                }
            });
            
            if (barGroup) barGroup.innerHTML = '';
            if (pointsGroup) pointsGroup.innerHTML = '';

            const selectedItem = activeInflationItems && activeInflationItems.length > 0 ? activeInflationItems[0] : null;
            const koreaDataUnsorted = selectedItem ? (inflationData[selectedItem] || []) : [];
            const koreaData = [...koreaDataUnsorted].sort((a, b) => compareInflationDates(a.date, b.date, inflationCycle));
            
            // Î™®Îì† Îç∞Ïù¥ÌÑ∞ Î≥ëÌï© (ÌïúÍµ≠ + ÏÑ†ÌÉùÎêú Íµ≠Í∞ÄÎì§)
            const allData = [];
            if (koreaData.length > 0) {
                allData.push(...koreaData);
            }
            activeInflationCountries.forEach(itemCode => {
                const countryData = inflationCountryData[itemCode] || [];
                allData.push(...countryData);
            });
            
            // Í≥µÌÜµ ÎÇ†Ïßú Î™©Î°ù ÏÉùÏÑ±
            const allDates = new Set();
            if (koreaData.length > 0) {
                koreaData.forEach(item => allDates.add(item.date));
            }
            activeInflationCountries.forEach(itemCode => {
                const countryData = inflationCountryData[itemCode] || [];
                countryData.forEach(item => allDates.add(item.date));
            });
            const sortedDates = Array.from(allDates).sort((a, b) => compareInflationDates(a, b, inflationCycle));
            
            // YÏ∂ï Î≤îÏúÑ Í≥ÑÏÇ∞ (Î™®Îì† Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)
            const allValues = allData.map(d => d.value).filter(v => Number.isFinite(v) && v > 0);
            if (allValues.length > 0) {
                const minValue = Math.min(...allValues);
                const maxValue = Math.max(...allValues);
                const range = maxValue - minValue || 1;
                const paddingPercent = 0.05;
                inflationYAxisRange = {
                    min: Math.max(0, minValue - range * paddingPercent),
                    max: maxValue + range * paddingPercent
                };
            } else {
                inflationYAxisRange = { min: 0, max: 0 };
            }
            
            // YÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ
            renderInflationYAxisLabels(allData.length > 0 ? allData : koreaData);
            
            if (sortedDates.length === 0 && koreaData.length === 0) {
                renderInflationXAxisLabels([], true);
                setupInflationChartInteractivity();
                return;
            }
            
            // ÌïúÍµ≠ Îç∞Ïù¥ÌÑ∞ Î†åÎçîÎßÅ
            if (koreaData.length > 0) {
                const isLessThanTwo = koreaData.length < 2;
                
                if (isLessThanTwo) {
                    // 1Í∞ú: ÎßâÎåÄ Í∑∏ÎûòÌîÑ
                    renderInflationBarChart(koreaData, selectedItem);
                } else {
                    // 2Í∞ú Ïù¥ÏÉÅ: ÎùºÏù∏ + Ìè¨Ïù∏Ìä∏
                    const path = document.getElementById(`path-inflation-${selectedItem}`);
                    if (path) {
                        const pathData = generateInflationSVGPath(koreaData);
                        path.setAttribute('d', pathData);
                        path.classList.add('visible');
                    }
                    renderInflationDataPoints(koreaData, selectedItem);
                }
            }
            
            // Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ Î†åÎçîÎßÅ
            activeInflationCountries.forEach(itemCode => {
                const countryData = inflationCountryData[itemCode] || [];
                if (countryData.length === 0) return;
                
                let path = document.getElementById(`path-inflation-country-${itemCode}`);
                if (!path) {
                    // path ÏöîÏÜå ÏÉùÏÑ±
                    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.id = `path-inflation-country-${itemCode}`;
                    path.classList.add('chart-path');
                    path.setAttribute('stroke', getInflationCountryColor(itemCode));
                    path.setAttribute('stroke-width', '2.5');
                    path.setAttribute('stroke-dasharray', '5,5'); // Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞Îäî Ï†êÏÑ†ÏúºÎ°ú Íµ¨Î∂Ñ
                    path.setAttribute('fill', 'none');
                    svg.insertBefore(path, pointsGroup);
                }
                
                // Îç∞Ïù¥ÌÑ∞Î•º Í≥µÌÜµ ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨
                const sortedData = sortedDates.map(date => {
                    const found = countryData.find(item => item.date === date);
                    return found || { date, value: null };
                }).filter(item => item.value !== null);
                
                if (sortedData.length > 0) {
                    const pathData = generateInflationSVGPath(sortedData);
                    path.setAttribute('d', pathData);
                    path.classList.add('visible');
                }
                
                // Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ Î†åÎçîÎßÅ
                renderInflationCountryDataPoints(countryData, itemCode);
            });
            
            // XÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ (Í≥µÌÜµ ÎÇ†Ïßú ÏÇ¨Ïö©)
            const displayDates = sortedDates.length > 0 ? sortedDates : (koreaData.length > 0 ? koreaData.map(d => d.date) : []);
            renderInflationXAxisLabels(displayDates, displayDates.length < 2);
            setupInflationChartInteractivity();
        }
        
        function renderInflationCountryDataPoints(data, itemCode) {
            const pointsGroup = document.getElementById('inflation-data-points');
            if (!pointsGroup || !data || data.length === 0) return;
            
            const svg = document.getElementById('inflation-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = inflationYAxisRange.min;
            const maxValue = inflationYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            const countryColor = getInflationCountryColor(itemCode);
            
            data.forEach((point, index) => {
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', '4');
                circle.setAttribute('fill', countryColor);
                circle.setAttribute('stroke', '#fff');
                circle.setAttribute('stroke-width', '1.5');
                circle.setAttribute('data-date', point.date);
                circle.setAttribute('data-value', point.value);
                circle.setAttribute('data-country', itemCode);
                circle.classList.add('data-point');
                pointsGroup.appendChild(circle);
            });
        }

        function generateInflationSVGPath(data) {
            if (!data || data.length === 0) return '';
            
            const svg = document.getElementById('inflation-chart-svg');
            if (!svg) return '';
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = inflationYAxisRange.min;
            const maxValue = inflationYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            let pathData = '';
            data.forEach((point, index) => {
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            return pathData;
        }

        function renderInflationYAxisLabels(displaySeries) {
            const g = document.getElementById('inflation-y-axis-labels');
            if (!g) return;
            
            g.innerHTML = '';
            
            const values = (Array.isArray(displaySeries) ? displaySeries : [])
                .map(d => d.value)
                .filter(v => Number.isFinite(v));
            if (values.length === 0) return;

            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const range = maxValue - minValue || 1;
            
            // Dynamic padding
            const paddingPercent = range < 10 ? 0.01 : (range < 50 ? 0.005 : 0.003);
            const paddedMin = minValue - range * paddingPercent;
            const paddedMax = maxValue + range * paddingPercent;
            
            inflationYAxisRange = { min: paddedMin, max: paddedMax };
            
            const svg = document.getElementById('inflation-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartHeight = height - padding.top - padding.bottom;
            
            const steps = 5;
            for (let i = 0; i <= steps; i++) {
                const value = paddedMax - (i / steps) * (paddedMax - paddedMin);
                const y = padding.top + (i / steps) * chartHeight;
                
                const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                t.setAttribute('x', String(padding.left - 10));
                t.setAttribute('y', String(y));
                t.setAttribute('text-anchor', 'end');
                t.setAttribute('dominant-baseline', 'middle');
                t.setAttribute('class', 'chart-yaxis-label');
                t.textContent = value.toFixed(2);
                g.appendChild(t);
            }
        }

        function renderInflationXAxisLabels(displaySeries, isSingleUnit = false) {
            const g = document.getElementById('inflation-x-axis-labels');
            if (!g) return;
            
            g.innerHTML = '';
            
            const data = Array.isArray(displaySeries) ? displaySeries : [];
            if (data.length === 0) return;
            const svg = document.getElementById('inflation-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const y = height - padding.bottom + 20;
            
            // 1Í∞ú Îã®ÏúÑ: Ï§ëÏïôÏóê ÎùºÎ≤® ÌëúÏãú (ÌëúÏ§Ä Ï§ÄÏàò)
            if (isSingleUnit && data.length === 1) {
                const centerX = padding.left + chartWidth / 2;
                const dataPoint = data[0];
                const label = formatInflationPeriodLabel(dataPoint.date, inflationCycle);
                
                const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                t.setAttribute('x', String(centerX));
                t.setAttribute('y', String(y));
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'middle');
                t.setAttribute('class', 'chart-xaxis-label');
                t.textContent = label;
                g.appendChild(t);
                return;
            }
            
            // M: 2Í∞úÎßàÎã§, Q: Ï†ÑÎ∂Ä. Ï≤´/ÎÅùÏùÄ Ìï≠ÏÉÅ Ìè¨Ìï®
            const labelIndices = [];
            if (inflationCycle === 'M') {
                for (let i = 0; i < data.length; i += 2) labelIndices.push(i);
                } else {
                for (let i = 0; i < data.length; i++) labelIndices.push(i);
            }
            if (labelIndices.length === 0 || labelIndices[0] !== 0) labelIndices.unshift(0);
            if (labelIndices[labelIndices.length - 1] !== data.length - 1) labelIndices.push(data.length - 1);
            const unique = [...new Set(labelIndices)].sort((a, b) => a - b);

            unique.forEach(index => {
                const point = data[index];
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                const label = formatInflationPeriodLabel(point.date, inflationCycle);
                    const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    t.setAttribute('x', String(x));
                    t.setAttribute('y', String(y));
                    t.setAttribute('text-anchor', 'middle');
                    t.setAttribute('dominant-baseline', 'middle');
                    t.setAttribute('class', 'chart-xaxis-label');
                    t.textContent = label;
                    g.appendChild(t);
            });
        }

        function renderInflationBarChart(displaySeries, itemCode) {
            const barGroup = document.getElementById('inflation-bar-chart');
            if (!barGroup) return;
            
            barGroup.innerHTML = '';

            const data = Array.isArray(displaySeries) ? displaySeries : [];
            if (!itemCode || data.length === 0) return;
            
            const svg = document.getElementById('inflation-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
                const dataPoint = data[0];
                const minValue = inflationYAxisRange.min;
                const maxValue = inflationYAxisRange.max;
                const valueRange = maxValue - minValue || 1;
                const normalizedValue = (dataPoint.value - minValue) / valueRange;
                const barHeight = normalizedValue * chartHeight;
                const barY = padding.top + (1 - normalizedValue) * chartHeight;
                
            const barWidth = Math.min(60, chartWidth * 0.3);
                const centerX = padding.left + chartWidth / 2;
            const barX = centerX - barWidth / 2;

            const color = INFLATION_ITEM_COLORS[itemCode] || 'var(--accent-color)';
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', String(barX));
                rect.setAttribute('y', String(barY));
                rect.setAttribute('width', String(barWidth));
                rect.setAttribute('height', String(barHeight));
                rect.setAttribute('fill', color);
                rect.setAttribute('rx', '4');
                barGroup.appendChild(rect);
        }

        function renderInflationDataPoints(displaySeries, itemCode) {
            const g = document.getElementById('inflation-data-points');
            if (!g) return;
            
            g.innerHTML = '';
            
            const data = Array.isArray(displaySeries) ? displaySeries : [];
            if (!itemCode || data.length === 0) return;
                
                const svg = document.getElementById('inflation-chart-svg');
                if (!svg) return;
                
                const { width, height } = getSvgViewBoxSize(svg);
                const padding = { top: 20, bottom: 30, left: 40, right: 20 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                const minValue = inflationYAxisRange.min;
                const maxValue = inflationYAxisRange.max;
                const valueRange = maxValue - minValue || 1;
                
            const color = INFLATION_ITEM_COLORS[itemCode] || 'var(--accent-color)';
                
                data.forEach((point, index) => {
                    const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                    const normalizedValue = (point.value - minValue) / valueRange;
                    const y = padding.top + (1 - normalizedValue) * chartHeight;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', String(x));
                    circle.setAttribute('cy', String(y));
                    circle.setAttribute('r', '4');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '1');
                    g.appendChild(circle);
            });
        }

        // Store handlers for cleanup
        let inflationMouseMoveHandler = null;
        let inflationMouseLeaveHandler = null;

        function setupInflationChartInteractivity() {
            const chartContainer = document.getElementById('inflation-chart-container');
            const svg = document.getElementById('inflation-chart-svg');
            
            if (!chartContainer || !svg) return;
            
            // Ensure tooltip is in body
            const tooltip = document.getElementById('inflation-chart-tooltip');
            if (tooltip && tooltip.parentElement !== document.body) {
                document.body.appendChild(tooltip);
            }
            
            // Remove existing listeners if they exist
            if (inflationMouseMoveHandler) {
                chartContainer.removeEventListener('mousemove', inflationMouseMoveHandler);
            }
            if (inflationMouseLeaveHandler) {
                chartContainer.removeEventListener('mouseleave', inflationMouseLeaveHandler);
            }
            
            // Add new listeners
            let rafId = null;
            
            inflationMouseMoveHandler = (e) => {
                if (rafId) return;
                rafId = requestAnimationFrame(() => {
                    rafId = null;
                    
                    const firstItem = activeInflationItems[0];
                    const raw = firstItem ? (inflationData[firstItem] || []) : [];
                    const data = [...raw].sort((a, b) => compareInflationDates(a.date, b.date, inflationCycle));
                    if (!firstItem || data.length === 0) {
                        hideInflationTooltip();
                        return;
                    }
                    
                    const rect = chartContainer.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const svgX = (x / rect.width) * 1200; // viewBox width
                    
                    const padding = { left: 40, right: 20 };
                    const chartWidth = 1200 - padding.left - padding.right;
                    const dataIndex = Math.round(((svgX - padding.left) / chartWidth) * (data.length - 1));
                    
                    if (dataIndex >= 0 && dataIndex < data.length) {
                        const dataPoint = data[dataIndex];
                        const prevPoint = dataIndex > 0 ? data[dataIndex - 1] : null;
                        
                        // ÌôúÏÑ±ÌôîÎêú Íµ≠Í∞ÄÎì§Ïùò Îç∞Ïù¥ÌÑ∞ÎèÑ Ï∞æÍ∏∞
                        const countryDataPoints = {};
                        activeInflationCountries.forEach(itemCode => {
                            const countryData = inflationCountryData[itemCode] || [];
                            const sortedCountryData = [...countryData].sort((a, b) => compareInflationDates(a.date, b.date, inflationCycle));
                            if (sortedCountryData.length > 0) {
                                // Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÎÇ†Ïßú Ï∞æÍ∏∞
                                let closestPoint = sortedCountryData.find(d => d.date === dataPoint.date);
                                if (!closestPoint && sortedCountryData.length > 0) {
                                    // Ï†ïÌôïÌïú Îß§Ïπ≠Ïù¥ ÏóÜÏúºÎ©¥ Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÎÇ†Ïßú Ï∞æÍ∏∞
                                    const dateIndex = sortedCountryData.findIndex(d => compareInflationDates(d.date, dataPoint.date, inflationCycle) >= 0);
                                    if (dateIndex >= 0) {
                                        closestPoint = sortedCountryData[dateIndex];
                                    } else {
                                        closestPoint = sortedCountryData[sortedCountryData.length - 1];
                                    }
                                }
                                if (closestPoint) {
                                    countryDataPoints[itemCode] = closestPoint;
                                }
                            }
                        });
                        
                        showInflationTooltip(e, dataPoint, firstItem, prevPoint, countryDataPoints);
                    } else {
                        hideInflationTooltip();
                    }
                });
            };
            
            inflationMouseLeaveHandler = () => {
                hideInflationTooltip();
            };
            
            chartContainer.addEventListener('mousemove', inflationMouseMoveHandler);
            chartContainer.addEventListener('mouseleave', inflationMouseLeaveHandler);
        }

        function showInflationTooltip(event, dataPoint, itemCode, prevPoint = null, countryDataPoints = {}) {
            const tooltip = document.getElementById('inflation-chart-tooltip');
            const tooltipDate = document.getElementById('inflation-tooltip-date');
            const tooltipContent = document.getElementById('inflation-tooltip-content');
            
            if (!tooltip || !tooltipDate || !tooltipContent) return;
            
            const formattedDate = formatInflationPeriodLabel(dataPoint.date, inflationCycle);
            tooltipDate.textContent = formattedDate;
            
            // Show value
            const itemNames = INFLATION_ITEM_NAMES;
            const colorMap = INFLATION_ITEM_COLORS;
            const metricLabel = getInflationMetricLabel(inflationCycle);
            const valueText = Number(dataPoint.value).toLocaleString('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

            let changeRow = '';
            if (prevPoint && Number.isFinite(prevPoint.value) && prevPoint.value !== 0) {
                const change = dataPoint.value - prevPoint.value;
                const changePercent = (change / prevPoint.value) * 100;
                const sign = change > 0 ? '+' : '';
                changeRow = `
                    <div class="chart-tooltip-item">
                        <div class="chart-tooltip-currency">
                            <div class="chart-tooltip-dot" style="background: ${colorMap[itemCode] || 'var(--accent-color)'}; opacity: 0.6;"></div>
                            <span>${metricLabel}</span>
                        </div>
                        <span class="chart-tooltip-value">${sign}${change.toFixed(2)} (${sign}${changePercent.toFixed(2)}%)</span>
                    </div>
                `;
            }
            
            // ÌôúÏÑ±ÌôîÎêú Íµ≠Í∞ÄÎì§Ïùò ÏßÄÏàò ÌëúÏãú
            let countryRows = '';
            Object.keys(countryDataPoints).forEach(itemCode => {
                const countryPoint = countryDataPoints[itemCode];
                const countryInfo = inflationCountryMapping[itemCode];
                const countryName = countryInfo ? countryInfo.name : itemCode;
                const countryColor = getInflationCountryColor(itemCode);
                
                // CSS Î≥ÄÏàòÎ•º Ïã§Ï†ú ÏÉâÏÉÅÏúºÎ°ú Î≥ÄÌôò
                const tempEl = document.createElement('div');
                tempEl.style.color = countryColor;
                document.body.appendChild(tempEl);
                const computedColor = window.getComputedStyle(tempEl).color;
                document.body.removeChild(tempEl);
                
                const countryValueText = Number(countryPoint.value).toLocaleString('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                countryRows += `
                    <div class="chart-tooltip-item">
                        <div class="chart-tooltip-currency">
                            <div class="chart-tooltip-dot" style="background: ${computedColor};"></div>
                            <span>${countryName}</span>
                        </div>
                        <span class="chart-tooltip-value">${countryValueText}</span>
                    </div>
                `;
            });
            
            tooltipContent.innerHTML = `
                <div class="chart-tooltip-item">
                    <div class="chart-tooltip-currency">
                        <div class="chart-tooltip-dot" style="background: ${colorMap[itemCode] || 'var(--accent-color)'};"></div>
                        <span>${itemNames[itemCode] || itemCode}</span>
                    </div>
                    <span class="chart-tooltip-value">${valueText}</span>
                </div>
                ${changeRow}
                ${countryRows}
            `;
            
            // Position tooltip
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
            tooltip.style.visibility = 'visible';
            tooltip.classList.add('visible');
        }

        function hideInflationTooltip() {
            const tooltip = document.getElementById('inflation-chart-tooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
                tooltip.style.visibility = 'hidden';
            }
        }

        function updateInflationChartHeader(stats, itemCode) {
            const titleEl = document.getElementById('inflation-chart-main-title');
            const valueEl = document.getElementById('inflation-chart-main-value');
            const changeValueEl = document.getElementById('inflation-change-value');
            const changePercentEl = document.getElementById('inflation-change-percent');
            const statHighEl = document.getElementById('inflation-stat-high');
            const statLowEl = document.getElementById('inflation-stat-low');
            const statAverageEl = document.getElementById('inflation-stat-average');
            
            const name = INFLATION_ITEM_NAMES[itemCode] || 'ÏÜåÎπÑÏûêÎ¨ºÍ∞ÄÏßÄÏàò';
            const metricLabel = getInflationMetricLabel(inflationCycle);
            if (titleEl) titleEl.textContent = `${name} (ÏßÄÏàò)`;

            const has = stats && stats.hasData;
            if (!has) {
                if (valueEl) valueEl.textContent = '-';
                if (changeValueEl) changeValueEl.textContent = '-';
                if (changePercentEl) changePercentEl.textContent = '(-)';
                if (changeValueEl) changeValueEl.className = 'change-value';
                if (changePercentEl) changePercentEl.className = 'change-percent';
                if (statHighEl) statHighEl.textContent = '-';
                if (statLowEl) statLowEl.textContent = '-';
                if (statAverageEl) statAverageEl.textContent = '-';
                return;
            }

            const fmtIndex = (v) => Number(v).toLocaleString('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            if (valueEl) valueEl.textContent = fmtIndex(stats.current);

            const change = Number(stats.change);
            const changePct = Number(stats.changePercent);
            const isUp = change > 0;
            const isDown = change < 0;

            if (changeValueEl && changePercentEl) {
                // ÏòàÏãú: -10 (-10%)
                changeValueEl.textContent = `${isUp ? '+' : ''}${change.toFixed(2)}`;
                changePercentEl.textContent = `(${isUp ? '+' : ''}${changePct.toFixed(2)}%)`;
                changeValueEl.className = `change-value ${isUp ? 'up' : (isDown ? 'down' : '')}`;
                changePercentEl.className = `change-percent ${isUp ? 'up' : (isDown ? 'down' : '')}`;
            }

            if (statHighEl) statHighEl.textContent = fmtIndex(stats.high);
            if (statLowEl) statLowEl.textContent = fmtIndex(stats.low);
            if (statAverageEl) statAverageEl.textContent = fmtIndex(stats.average);
        }

        // ========== GDP (Íµ≠ÎØºÏÜåÎìù) FUNCTIONS ==========
        // raw(Ïó∞Í∞Ñ) Îç∞Ïù¥ÌÑ∞: { [itemCode]: [{date:'YYYY', value:number}] }
        let gdpData = {};
        let gdpDisplayData = {};
        // GDP Ìï≠Î™©ÏùÄ Îã®Ïùº ÏÑ†ÌÉù(ÎùºÎîîÏò§Ìòï)
        let activeGDPItems = ['10101'];
        let currentGDPIndicator = '10101'; // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏßÄÌëú ÏΩîÎìú (10101, 10102, 10106, 10107)
        let currentGDPCurrency = 'KRW'; // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÌÜµÌôî (KRW, USD)
        
        // ÏßÄÌëú ÏΩîÎìúÏôÄ ÌÜµÌôîÎ•º item_codeÎ°ú Îß§Ìïë
        const GDP_INDICATOR_MAP = {
            '10101': { KRW: '10101', USD: '1010101' },
            '10102': { KRW: '10102', USD: '1010201' },
            '10106': { KRW: '10106', USD: '1010601' },
            '10107': { KRW: '10107', USD: '1010701' }
        };
        let gdpYAxisRange = { min: 0, max: 0 };
        // GDPÎäî 200Y101(Ïó∞Í∞Ñ A)Îßå Ï†úÍ≥µ
        const gdpPeriodMode = 'Y';

        const GDP_ITEM_UNITS = {
            '10101': 'Ïã≠ÏñµÏõê',      // Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞ (KRW)
            '1010101': 'ÏñµÎã¨Îü¨',    // Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞ (USD)
            '10102': 'Ïã≠ÏñµÏõê',      // Íµ≠ÎØºÏ¥ùÏÜåÎìù (KRW)
            '1010201': 'ÏñµÎã¨Îü¨',    // Íµ≠ÎØºÏ¥ùÏÜåÎìù (USD)
            '10106': 'ÎßåÏõê',        // 1Ïù∏Îãπ Íµ≠ÎØºÏ¥ùÏÜåÎìù (KRW)
            '1010601': 'Îã¨Îü¨',      // 1Ïù∏Îãπ Íµ≠ÎØºÏ¥ùÏÜåÎìù (USD)
            '10107': 'ÎßåÏõê',        // 1Ïù∏Îãπ Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞ (KRW)
            '1010701': 'Îã¨Îü¨'       // 1Ïù∏Îãπ Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞ (USD)
        };

        const GDP_ITEM_LABELS = {
            '10101': 'Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞(GDP)',
            '1010101': 'Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞(GDP)',
            '10102': 'Íµ≠ÎØºÏ¥ùÏÜåÎìù(GNI)',
            '1010201': 'Íµ≠ÎØºÏ¥ùÏÜåÎìù(GNI)',
            '10106': '1Ïù∏Îãπ Íµ≠ÎØºÏ¥ùÏÜåÎìù',
            '1010601': '1Ïù∏Îãπ Íµ≠ÎØºÏ¥ùÏÜåÎìù',
            '10107': '1Ïù∏Îãπ Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞',
            '1010701': '1Ïù∏Îãπ Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞'
        };

        function formatGDPNumber(n, maxFrac = 1) {
            if (!Number.isFinite(n)) return '-';
            return n.toLocaleString('ko-KR', { maximumFractionDigits: maxFrac });
        }

        function formatGDPChange(n, maxFrac = 1) {
            if (!Number.isFinite(n)) return '-';
            const sign = n > 0 ? '+' : (n < 0 ? '' : '');
            return `${sign}${n.toLocaleString('ko-KR', { maximumFractionDigits: maxFrac })}`;
        }

        /**
         * GDP Ïà´ÏûêÏóê Ïâ¨Ïö¥ Îã®ÏúÑÎ•º Í¥ÑÌò∏Î°ú Ï∂îÍ∞ÄÌïòÎäî Ìï®Ïàò
         * @param {number} value - ÏõêÎ≥∏ Í∞í
         * @param {string} itemCode - Ìï≠Î™© ÏΩîÎìú (10101, 1010101, 10102, 1010201, 10106, 1010601, 10107, 1010701)
         * @returns {string} - "2,556,857.4 (2556Ï°∞)" ÌòïÏãùÏùò Î¨∏ÏûêÏó¥
         */
        function formatGDPNumberWithEasyUnit(value, itemCode) {
            if (!Number.isFinite(value)) return formatGDPNumber(value, 1);
            
            const formattedValue = formatGDPNumber(value, 1);
            let easyUnit = '';
            
            // Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞ / Íµ≠ÎØºÏ¥ùÏÜåÎìù (KRW): Ïã≠ÏñµÏõê ‚Üí Ï°∞Ïõê
            // Í≥ÑÏÇ∞: 1Ï°∞ = 1,000 Ïã≠ÏñµÏõê (1Ï°∞ = 10^12Ïõê, Ïã≠Ïñµ = 10^9Ïõê)
            if (itemCode === '10101' || itemCode === '10102') {
                const joValue = value / 1000; // Ïã≠ÏñµÏõê ‚Üí Ï°∞Ïõê (Ïò¨Î∞îÎ•∏ Î≥ÄÌôò: 1Ï°∞ = 1,000 Ïã≠Ïñµ)
                if (joValue >= 0.01) { // 0.01Ï°∞ Ïù¥ÏÉÅÏùº ÎïåÎßå ÌëúÏãú
                    easyUnit = `(${joValue.toFixed(joValue >= 1 ? 0 : 1)}Ï°∞)`;
                }
            }
            // Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞ / Íµ≠ÎØºÏ¥ùÏÜåÎìù (USD): ÏñµÎã¨Îü¨ ‚Üí Ï°∞Îã¨Îü¨
            else if (itemCode === '1010101' || itemCode === '1010201') {
                const joValue = value / 10000; // ÏñµÎã¨Îü¨ ‚Üí Ï°∞Îã¨Îü¨
                if (joValue >= 0.01) { // 0.01Ï°∞ Ïù¥ÏÉÅÏùº ÎïåÎßå ÌëúÏãú
                    easyUnit = `(${joValue.toFixed(joValue >= 1 ? 0 : 2)}Ï°∞)`;
                }
            }
            // 1Ïù∏Îãπ Íµ≠ÎØºÏ¥ùÏÜåÎìù / 1Ïù∏Îãπ Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞ (KRW): ÎßåÏõê ‚Üí ÏñµÏõê/Ï≤úÎßåÏõê
            else if (itemCode === '10106' || itemCode === '10107') {
                if (value >= 10000) {
                    // ÎßåÏõê ‚Üí ÏñµÏõê
                    const eokValue = value / 10000;
                    easyUnit = `(${eokValue.toFixed(1)}Ïñµ)`;
                } else if (value >= 1000) {
                    // ÎßåÏõê ‚Üí Ï≤úÎßåÏõê
                    const cheonValue = value / 1000;
                    easyUnit = `(${cheonValue.toFixed(1)}Ï≤úÎßå)`;
                }
                // 1000 ÎØ∏ÎßåÏùÄ ÌëúÏãúÌïòÏßÄ ÏïäÏùå
            }
            // 1Ïù∏Îãπ Íµ≠ÎØºÏ¥ùÏÜåÎìù / 1Ïù∏Îãπ Íµ≠ÎÇ¥Ï¥ùÏÉùÏÇ∞ (USD): Îã¨Îü¨ ‚Üí ÎßåÎã¨Îü¨/Ï≤úÎã¨Îü¨
            else if (itemCode === '1010601' || itemCode === '1010701') {
                if (value >= 10000) {
                    // Îã¨Îü¨ ‚Üí ÎßåÎã¨Îü¨
                    const manValue = value / 10000;
                    easyUnit = `(${manValue.toFixed(1)}Îßå)`;
                } else if (value >= 1000) {
                    // Îã¨Îü¨ ‚Üí Ï≤úÎã¨Îü¨
                    const cheonValue = value / 1000;
                    easyUnit = `(${cheonValue.toFixed(1)}Ï≤ú)`;
                }
                // 1000 ÎØ∏ÎßåÏùÄ ÌëúÏãúÌïòÏßÄ ÏïäÏùå
            }
            
            return easyUnit ? `${formattedValue} ${easyUnit}` : formattedValue;
        }

        /**
         * ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ Ïà´ÏûêÏóê Ïâ¨Ïö¥ Îã®ÏúÑÎ•º Í¥ÑÌò∏Î°ú Ï∂îÍ∞ÄÌïòÎäî Ìï®Ïàò
         * @param {number} value - ÏõêÎ≥∏ Í∞í (USD: Î∞±ÎßåÎã¨Îü¨ Îã®ÏúÑ, KRW: ÏñµÏõê Îã®ÏúÑ)
         * @param {string} currency - ÌÜµÌôî ('USD' ÎòêÎäî 'KRW')
         * @returns {object} - { formatted: "55,878", easyUnit: "(559Ïñµ)" } ÌòïÏãùÏùò Í∞ùÏ≤¥
         */
        function formatTradeNumberWithEasyUnit(value, currency = 'USD') {
            if (!Number.isFinite(value)) {
                return { formatted: value.toFixed(0), easyUnit: '' };
            }
            
            // Ïà´ÏûêÏóê ÏâºÌëú Ï∂îÍ∞Ä (Í∞ÄÏãúÏÑ± Ìñ•ÏÉÅ)
            const formattedValue = Number(value).toLocaleString('ko-KR', { 
                maximumFractionDigits: 0 
            });
            
            let easyUnit = '';
            
            if (currency === 'USD') {
                // Î∞±ÎßåÎã¨Îü¨ ‚Üí ÏñµÎã¨Îü¨ Î≥ÄÌôò
                // Í≥ÑÏÇ∞: 1ÏñµÎã¨Îü¨ = 100 Î∞±ÎßåÎã¨Îü¨ (1Ïñµ = 10^8, Î∞±Îßå = 10^6)
                const eokValue = value / 100; // Î∞±ÎßåÎã¨Îü¨ ‚Üí ÏñµÎã¨Îü¨
                if (eokValue >= 0.1) { // 0.1Ïñµ Ïù¥ÏÉÅÏùº ÎïåÎßå ÌëúÏãú
                    easyUnit = `(${eokValue.toFixed(eokValue >= 1 ? 0 : 1)}Ïñµ)`;
                }
            } else if (currency === 'KRW') {
                // ÏñµÏõê ‚Üí Ï°∞Ïõê Î≥ÄÌôò
                // Í≥ÑÏÇ∞: 1Ï°∞Ïõê = 10,000 ÏñµÏõê (1Ï°∞ = 10^12, Ïñµ = 10^8)
                const joValue = value / 10000; // ÏñµÏõê ‚Üí Ï°∞Ïõê
                if (joValue >= 0.01) { // 0.01Ï°∞ Ïù¥ÏÉÅÏùº ÎïåÎßå ÌëúÏãú
                    easyUnit = `(${joValue.toFixed(joValue >= 1 ? 0 : 1)}Ï°∞)`;
                }
            }
            
            return { formatted: formattedValue, easyUnit: easyUnit };
        }

        function buildYearLabel(year) {
            // Ïó∞ÎèÑÎ≥Ñ Î™®ÎìúÎäî Ïó∞ÎèÑ Ïà´ÏûêÎßå ÌëúÏãú
            return String(year);
        }

        function normalizeGDPYearInputsIfNeeded() {
            const startInput = document.getElementById('gdp-start-date');
            const endInput = document.getElementById('gdp-end-date');
            if (!startInput || !endInput) return;

            const now = new Date();
            const maxY = now.getFullYear() - 1; // Ïò¨Ìï¥ Ï†úÏô∏
            let s = parseInt(startInput.value, 10);
            let e = parseInt(endInput.value, 10);

            if (!Number.isFinite(e)) e = maxY;
            if (!Number.isFinite(s)) s = Math.max(1953, maxY - 10);

            e = Math.min(Math.max(1953, e), maxY);
            s = Math.min(Math.max(1953, s), maxY);
            if (s > e) s = e;

            startInput.min = '1953';
            endInput.min = '1953';
            startInput.max = String(maxY);
            endInput.max = String(maxY);
            startInput.value = String(s);
            endInput.value = String(e);
        }

        function initGDP() {
            const startDateInput = document.getElementById('gdp-start-date');
            const endDateInput = document.getElementById('gdp-end-date');
            
            if (startDateInput && endDateInput) {
                normalizeGDPYearInputsIfNeeded();

                const onRangeChange = () => {
                    normalizeGDPYearInputsIfNeeded();
                    if (validateGDPDateRange()) fetchGDPData();
                };
                startDateInput.addEventListener('change', onRangeChange);
                endDateInput.addEventListener('change', onRangeChange);
            }
            
            // Ï¥àÍ∏∞ ÏÉÅÌÉú ÏÑ§Ï†ï: Ï≤´ Î≤àÏß∏ ÏßÄÌëú(10101)ÏôÄ KRW ÏÑ†ÌÉù
            currentGDPIndicator = '10101';
            currentGDPCurrency = 'KRW';
            activeGDPItems = ['10101'];
            
            // Ï¥àÍ∏∞ Î°úÎìú Ïãú Ìï≠Î™©Î™Ö Í∞ÄÏ†∏Ïò§Í∏∞
            fetchGDPItemNames().then(() => {
            fetchGDPData();
            });
            window.gdpDataLoaded = true;
        }

        function validateGDPDateRange() {
            const startDateInput = document.getElementById('gdp-start-date');
            const endDateInput = document.getElementById('gdp-end-date');
            
            if (!startDateInput || !endDateInput) return false;
            
            const startY = parseInt(startDateInput.value, 10);
            const endY = parseInt(endDateInput.value, 10);
            if (!Number.isFinite(startY) || !Number.isFinite(endY)) return false;
            if (startY > endY) {
                alert('ÏãúÏûë Ïó∞ÎèÑÎäî Ï¢ÖÎ£å Ïó∞ÎèÑÎ≥¥Îã§ ÏïûÏÑúÏïº Ìï©ÎãàÎã§.');
                return false;
            }
            return true;
        }

        function setGDPPeriod(days) {
            // deprecated: GDPÎäî Î∂ÑÍ∏∞Î≥Ñ/Ïó∞ÎèÑÎ≥Ñ Î™®Îìú Î≤ÑÌäºÏúºÎ°ú Ï†úÏñ¥
            console.warn('setGDPPeriod is deprecated. Use GDP mode buttons (Q/Y).');
        }

        // ÏÑúÎ∏åÎ©îÎâ¥ÏóêÏÑú Ìï≠Î™© ÏÑ†ÌÉù Ïãú Ìå®ÎÑê ÌëúÏãú
        function selectGDPFromSubmenu(indicatorCode) {
            // ÏÑúÎ∏åÎ©îÎâ¥ Ïà®Í∏∞Í∏∞
            const gdpSubmenu = document.getElementById('gdp-submenu');
            if (gdpSubmenu) {
                gdpSubmenu.classList.remove('show');
            }
            
            // Ìå®ÎÑê ÌëúÏãú (Ïù¥ÎØ∏ ÌëúÏãúÎêòÏñ¥ ÏûàÏñ¥ÎèÑ Ïú†ÏßÄ)
            const gdpPanel = document.getElementById('gdp-panel');
            if (gdpPanel) {
                gdpPanel.style.display = 'block';
            }
            
            // Í∏∞Î≥∏ ÌÜµÌôîÎ•º KRWÎ°ú ÏÑ§Ï†ï
            currentGDPCurrency = 'KRW';
            
            // ÌÜµÌôî Î≤ÑÌäº ÏóÖÎç∞Ïù¥Ìä∏
            const krwBtn = document.getElementById('gdp-currency-krw');
            const usdBtn = document.getElementById('gdp-currency-usd');
            if (krwBtn) krwBtn.classList.add('active');
            if (usdBtn) usdBtn.classList.remove('active');
            
            // Ï¥àÍ∏∞ÌôîÍ∞Ä ÌïÑÏöîÌïòÎ©¥ Ïã§Ìñâ
            if (!window.gdpDataLoaded) {
                initGDP();
            }
            
            // ÏßÄÌëú ÏÑ†ÌÉù
            selectGDPIndicator(indicatorCode);
        }

        // GDP Ìå®ÎÑê ÎÇ¥ÏóêÏÑú ÌÜµÌôî Ï†ÑÌôò
        function switchGDPCurrencyInPanel(currency) {
            // ÌÜµÌôî Î≤ÑÌäº ÏóÖÎç∞Ïù¥Ìä∏
            const krwBtn = document.getElementById('gdp-currency-krw');
            const usdBtn = document.getElementById('gdp-currency-usd');
            
            if (currency === 'KRW') {
                if (krwBtn) krwBtn.classList.add('active');
                if (usdBtn) usdBtn.classList.remove('active');
            } else {
                if (krwBtn) krwBtn.classList.remove('active');
                if (usdBtn) usdBtn.classList.add('active');
            }
            
            // ÌÜµÌôî Ï†ÑÌôò
            switchGDPCurrency(currentGDPIndicator, currency);
        }

        function selectGDPIndicator(indicatorCode) {
            // ÏßÄÌëú ÏÑ†ÌÉù
            currentGDPIndicator = indicatorCode;
            
            // ÌòÑÏû¨ ÌÜµÌôîÏóê ÎßûÎäî item_codeÎ°ú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
            const itemCode = GDP_INDICATOR_MAP[indicatorCode][currentGDPCurrency];
            
            // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï†úÍ±∞ÌïòÍ≥† ÏÉà Ìï≠Î™©Îßå ÏÑ§Ï†ï (ÎàÑÏ†ÅÌïòÏßÄ ÏïäÏùå)
            activeGDPItems = [itemCode];
            
            // ÏÉà Ìï≠Î™©Ïùò Îç∞Ïù¥ÌÑ∞Îßå Í∞ÄÏ†∏Ïò§Í∏∞
            fetchGDPDataForItem(itemCode);
        }

        function switchGDPCurrency(indicatorCode, currency) {
            // ÌÜµÌôî Ï†ÑÌôò
            currentGDPCurrency = currency;
            currentGDPIndicator = indicatorCode;
            
            // ÌÜµÌôîÏóê ÎßûÎäî item_codeÎ°ú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
            const itemCode = GDP_INDICATOR_MAP[indicatorCode][currency];
            
            // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï†úÍ±∞ÌïòÍ≥† ÏÉà Ìï≠Î™©Îßå ÏÑ§Ï†ï
            activeGDPItems = [itemCode];
            
            // ÏÉà ÌÜµÌôîÏùò Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            fetchGDPDataForItem(itemCode);
        }

        // Í∏∞Ï°¥ Ìï®ÏàòÎì§ (ÌïòÏúÑ Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
        function toggleGDPItem(itemCode) {
            // item_codeÏóêÏÑú ÏßÄÌëú ÏΩîÎìúÏôÄ ÌÜµÌôî Ïó≠Ï∂îÏ†Å
            for (const [indicator, map] of Object.entries(GDP_INDICATOR_MAP)) {
                if (map.KRW === itemCode) {
                    selectGDPIndicator(indicator);
                    return;
                } else if (map.USD === itemCode) {
                    switchGDPCurrency(indicator, 'USD');
                    return;
                }
            }
        }

        function selectGDPItem(itemCode) {
            toggleGDPItem(itemCode);
        }

        function updateGDPItemLabels() {
            // HTMLÏùò Ìï≠Î™© Î≤ÑÌäº ÌÖçÏä§Ìä∏Î•º GDP_ITEM_LABELSÏóêÏÑú ÏóÖÎç∞Ïù¥Ìä∏
            // ÏÉàÎ°úÏö¥ Íµ¨Ï°∞ÏóêÏÑúÎäî ÏßÄÌëú Î≤ÑÌäºÏùò ÌÖçÏä§Ìä∏Îäî Í≥†Ï†ïÎêòÏñ¥ ÏûàÏúºÎØÄÎ°ú
            // ÌïÑÏöîÏãú Ïó¨Í∏∞ÏÑú ÏóÖÎç∞Ïù¥Ìä∏Ìï† Ïàò ÏûàÏùå
            // ÌòÑÏû¨Îäî Ìï≠Î™©Î™ÖÏù¥ ÌïòÎìúÏΩîÎî©ÎêòÏñ¥ ÏûàÏúºÎØÄÎ°ú Î≥ÑÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ Î∂àÌïÑÏöî
        }

        async function fetchGDPItemNames() {
            // Î™®Îì† GDP Ìï≠Î™©Î™ÖÏùÑ Ìïú Î≤àÏóê Í∞ÄÏ†∏Ïò§Í∏∞
            const itemCodes = ['10101', '1010101', '10102', '1010201', '10106', '1010601', '1010602', '1010603', '10107', '1010701'];
            const currentYear = new Date().getFullYear();
            const startDate = `${currentYear - 1}0101`;
            const endDate = `${currentYear - 1}1231`;
            
            for (const itemCode of itemCodes) {
                try {
                    const url = `${API_BASE}/market/indices?type=gdp&itemCode=${itemCode}&startDate=${startDate}&endDate=${endDate}&cycle=A`;
                    const data = await fetch(url).then(res => res.json());
                    if (!data.error && data.item_info && data.item_info.item_name) {
                        GDP_ITEM_LABELS[itemCode] = data.item_info.item_name;
                    }
                } catch (err) {
                    console.warn(`Failed to fetch item name for ${itemCode}:`, err);
                }
            }
            updateGDPItemLabels();
        }

        // Í∞úÎ≥Ñ Ìï≠Î™© Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ïú†ÏßÄ)
        async function fetchGDPDataForItem(itemCode) {
            if (!validateGDPDateRange()) return;
            
            const startDateInput = document.getElementById('gdp-start-date');
            const endDateInput = document.getElementById('gdp-end-date');
            
            if (!startDateInput || !endDateInput) return;
            
            normalizeGDPYearInputsIfNeeded();
            const sy = parseInt(startDateInput.value, 10);
            const ey = parseInt(endDateInput.value, 10);
            const startDate = `${sy}0101`;
            const endDate = `${ey}1231`;
            
            const chartContainer = document.getElementById('gdp-chart-container');
            if (chartContainer) {
                chartContainer.style.opacity = '0.5';
            }
            
            try {
                const url = `${API_BASE}/market/indices?type=gdp&itemCode=${itemCode}&startDate=${startDate}&endDate=${endDate}&cycle=A`;
                const data = await fetch(url).then(res => res.json());
                
                // API ÏùëÎãµÏóêÏÑú Ìï≠Î™©Î™Ö Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                if (!data.error && data.item_info && data.item_info.item_name) {
                    GDP_ITEM_LABELS[itemCode] = data.item_info.item_name;
                    updateGDPItemLabels();
                }
                
                // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï†úÍ±∞ÌïòÍ≥† ÏÉà Ìï≠Î™© Îç∞Ïù¥ÌÑ∞Îßå ÏÑ§Ï†ï
                gdpData = {};
                gdpDisplayData = {};
                
                    if (!data.error && data.StatisticSearch && data.StatisticSearch.row) {
                    const itemData = data.StatisticSearch.row.map(row => ({
                            date: row.TIME,
                            value: parseFloat(row.DATA_VALUE)
                        })).filter(item => !isNaN(item.value) && item.value > 0);
                    
                    // ÏÉà Ìï≠Î™© Îç∞Ïù¥ÌÑ∞Îßå ÏÑ§Ï†ï
                    gdpData[itemCode] = itemData;
                    gdpDisplayData[itemCode] = itemData;
                } else {
                    // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥Î°ú ÏÑ§Ï†ï
                    gdpData[itemCode] = [];
                    gdpDisplayData[itemCode] = [];
                }

                updateGDPChart();
                
                // Header stats
                const statsUrl = `${API_BASE}/market/indices/stats?type=gdp&itemCode=${itemCode}&startDate=${startDate}&endDate=${endDate}&cycle=A`;
                    const statsResponse = await fetch(statsUrl);
                    if (statsResponse.ok) {
                        const statsData = await statsResponse.json();
                    if (!statsData.error) updateGDPChartHeader(statsData);
                }
                
            } catch (err) {
                console.error('Failed to fetch GDP data:', err);
                alert('GDP Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + err.message);
            } finally {
                if (chartContainer) {
                    chartContainer.style.opacity = '1';
                }
            }
        }

        async function fetchGDPData() {
            // Í∏∞Ï°¥ Ìï®ÏàòÎäî Ï≤´ Î≤àÏß∏ Ìï≠Î™©Îßå Í∞ÄÏ†∏Ïò§ÎèÑÎ°ù Ïú†ÏßÄ (ÌïòÏúÑ Ìò∏ÌôòÏÑ±)
            if (!validateGDPDateRange()) return;
            
            const startDateInput = document.getElementById('gdp-start-date');
            const endDateInput = document.getElementById('gdp-end-date');
            
            if (!startDateInput || !endDateInput || activeGDPItems.length === 0) return;
            
            // Ï≤´ Î≤àÏß∏ Ìï≠Î™©Ïùò Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            await fetchGDPDataForItem(activeGDPItems[0]);
        }

        function calculateGDPStatsFromSeries(series, itemCode) {
            const values = (series || []).map(p => p.value).filter(v => Number.isFinite(v));
            if (values.length === 0) return { error: 'No data available' };
            const current = values[values.length - 1];
            const previous = values.length >= 2 ? values[values.length - 2] : current;
            const change = current - previous;
            const changePercent = previous !== 0 ? (change / previous) * 100 : 0;
            const high = Math.max(...values);
            const low = Math.min(...values);
            const average = values.reduce((s, v) => s + v, 0) / values.length;
            return {
                currency: itemCode,
                current, previous, change, changePercent,
                high, low, average
            };
        }

        function updateGDPChart() {
            // clear bar layer
            const barG = document.getElementById('gdp-bar-chart');
            if (barG) barG.innerHTML = '';
            const ptsG = document.getElementById('gdp-data-points');
            if (ptsG) ptsG.innerHTML = '';

            // Clear all paths
            const unusedPath = document.getElementById('path-gdp-unused');
            if (unusedPath) {
                unusedPath.setAttribute('d', '');
                unusedPath.classList.remove('visible');
            }
            
            if (!gdpDisplayData || Object.keys(gdpDisplayData).length === 0) {
                return;
            }
            
            // Render Y-axis
            renderGDPYAxisLabels();
            
            // Îã®Ïùº Ìï≠Î™©Îßå Î†åÎçîÎßÅ (ÎàÑÏ†ÅÌïòÏßÄ ÏïäÏùå)
            const itemCode = activeGDPItems[0];
            const data = (gdpDisplayData[itemCode] || []);
            if (data && data.length > 0) {
                renderGDPBarChart(itemCode, data);
            }
            
            // Render X-axis
            renderGDPXAxisLabels();
            
            // Setup interactivity
            setupGDPChartInteractivity();
        }

        function generateGDPSVGPath(data) {
            if (!data || data.length === 0) return '';
            
            const svg = document.getElementById('gdp-chart-svg');
            if (!svg) return '';
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = gdpYAxisRange.min;
            const maxValue = gdpYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            let pathData = '';
            data.forEach((point, index) => {
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            return pathData;
        }

        function renderGDPYAxisLabels() {
            const g = document.getElementById('gdp-y-axis-labels');
            if (!g) return;
            
            g.innerHTML = '';
            
            const allValues = [];
            Object.values(gdpDisplayData).forEach(data => {
                data.forEach(item => allValues.push(item.value));
            });
            
            if (allValues.length === 0) return;
            
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            const range = maxValue - minValue || 1;
            
            // Dynamic padding
            const paddingPercent = range < 100 ? 0.01 : 0.005;
            const paddedMin = Math.max(0, minValue - range * paddingPercent);
            const paddedMax = maxValue + range * paddingPercent;
            
            // 0Îã®ÏúÑÎ°ú Î∞òÏò¨Î¶ºÌïòÍ∏∞ ÏúÑÌïú Ìï®Ïàò
            const roundToNearest = (value, nearest) => {
                return Math.round(value / nearest) * nearest;
            };
            
            // Î≤îÏúÑÏóê Îî∞Îùº Ï†ÅÏ†àÌïú Îã®ÏúÑ Í≤∞Ï†ï (10, 100, 1000, 10000 Îì±)
            const magnitude = Math.pow(10, Math.floor(Math.log10(range)));
            const stepSize = magnitude;
            
            const roundedMin = roundToNearest(paddedMin, stepSize);
            const roundedMax = roundToNearest(paddedMax + stepSize, stepSize);
            
            gdpYAxisRange = { min: roundedMin, max: roundedMax };
            
            const svg = document.getElementById('gdp-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartHeight = height - padding.top - padding.bottom;
            
            const steps = 5;
            for (let i = 0; i <= steps; i++) {
                const value = roundedMax - (i / steps) * (roundedMax - roundedMin);
                const y = padding.top + (i / steps) * chartHeight;
                
                const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                t.setAttribute('x', String(padding.left - 10));
                t.setAttribute('y', String(y));
                t.setAttribute('text-anchor', 'end');
                t.setAttribute('dominant-baseline', 'middle');
                t.setAttribute('class', 'chart-yaxis-label');
                // Ï†ïÏàòÎßå ÌëúÏãú (ÏÜåÏàòÏ†ê Ï†úÍ±∞)
                t.textContent = Math.round(value).toLocaleString('ko-KR');
                g.appendChild(t);
            }
        }

        function renderGDPXAxisLabels() {
            const g = document.getElementById('gdp-x-axis-labels');
            if (!g) return;
            
            g.innerHTML = '';
            
            // Get first active item's data for X-axis
            const firstItem = activeGDPItems[0];
            if (!firstItem || !gdpDisplayData[firstItem] || gdpDisplayData[firstItem].length === 0) return;
            
            const data = gdpDisplayData[firstItem];
            const svg = document.getElementById('gdp-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const y = height - padding.bottom + 20;
            
            const n = Math.max(1, data.length);
            // ÎßâÎåÄ Í∑∏ÎûòÌîÑ Î†àÏù¥ÏïÑÏõÉ Í≥ÑÏÇ∞ (renderGDPBarChartÏôÄ ÎèôÏùºÌïú Î°úÏßÅ)
            const gap = Math.max(8, Math.round(chartWidth * 0.02));
            const barW = Math.max(10, (chartWidth - gap * (n - 1)) / n);
            
            // ÎßâÎåÄ Ï§ëÏã¨ ÏúÑÏπò Í≥ÑÏÇ∞ Ìï®Ïàò
            const getBarCenter = (index) => {
                return padding.left + index * (barW + gap) + barW / 2;
            };

            // ÎùºÎ≤® Í∞úÏàò Ï†úÏñ¥: 12Í∞ú Ïù¥ÌïòÎ©¥ Ï†ÑÎ∂Ä, ÎßéÏúºÎ©¥ ÌïµÏã¨ Ìè¨Ïù∏Ìä∏Îßå
            const idxSet = new Set();
            if (n <= 12) {
                for (let i = 0; i < n; i++) idxSet.add(i);
            } else {
                idxSet.add(0);
                idxSet.add(n - 1);
                idxSet.add(Math.floor(n / 2));
                idxSet.add(Math.floor(n / 4));
                idxSet.add(Math.floor(n * 3 / 4));
            }
            const labelIndices = Array.from(idxSet).sort((a, b) => a - b);
            
            labelIndices.forEach(index => {
                if (index >= data.length) return;
                
                const point = data[index];
                const x = getBarCenter(index);
                
                // Ïó∞Í∞Ñ: Ïó∞ÎèÑÎßå ÌëúÏãú
                let label = String(point.date).slice(0, 4);
                
                const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                t.setAttribute('x', String(x));
                t.setAttribute('y', String(y));
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'middle');
                t.setAttribute('class', 'chart-xaxis-label');
                t.textContent = label;
                g.appendChild(t);
            });
        }

        function renderGDPDataPoints() {
            const g = document.getElementById('gdp-data-points');
            if (!g) return;
            
            g.innerHTML = '';
            
            const itemCode = activeGDPItems[0];
            const data = gdpDisplayData[itemCode];
                if (!data || data.length === 0) return;
                
                const svg = document.getElementById('gdp-chart-svg');
                if (!svg) return;
                
                const { width, height } = getSvgViewBoxSize(svg);
                const padding = { top: 20, bottom: 30, left: 40, right: 20 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                const minValue = gdpYAxisRange.min;
                const maxValue = gdpYAxisRange.max;
                const valueRange = maxValue - minValue || 1;
                
                const colorMap = {
                    'GDP_TOTAL': 'var(--c-gdp-total)',
                    'GDP_CONSUMPTION': 'var(--c-gdp-consumption)',
                    'GDP_INVESTMENT': 'var(--c-gdp-investment)'
                };
                const color = colorMap[itemCode] || 'var(--accent-color)';
                
                data.forEach((point, index) => {
                    const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                    const normalizedValue = (point.value - minValue) / valueRange;
                    const y = padding.top + (1 - normalizedValue) * chartHeight;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', String(x));
                    circle.setAttribute('cy', String(y));
                    circle.setAttribute('r', '4');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '1');
                    g.appendChild(circle);
            });
        }

        function setupGDPChartInteractivity() {
            const svg = document.getElementById('gdp-chart-svg');
            const container = document.getElementById('gdp-chart-container');
            const tooltip = document.getElementById('gdp-chart-tooltip');
            const tooltipDate = document.getElementById('gdp-tooltip-date');
            const tooltipContent = document.getElementById('gdp-tooltip-content');

            if (!svg || !container || !tooltip || !tooltipDate || !tooltipContent) return;

            const itemCode = activeGDPItems[0];
            const series = gdpDisplayData[itemCode] || [];
            if (!Array.isArray(series) || series.length === 0) return;

            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;

            const show = (evt) => {
                const rect = svg.getBoundingClientRect();
                const px = evt.clientX - rect.left;
                const x = Math.max(padding.left, Math.min(width - padding.right, (px / rect.width) * width));
                const ratio = (x - padding.left) / (chartWidth || 1);
                const idx = Math.max(0, Math.min(series.length - 1, Math.round(ratio * (series.length - 1))));
                const p = series[idx];

                const label = (p.label || p.date || '').toString();
                tooltipDate.textContent = label.slice(0, 4);

                const prev = idx > 0 ? series[idx - 1] : null;
                const change = prev ? (p.value - prev.value) : 0;
                const pct = (prev && prev.value !== 0) ? (change / prev.value) * 100 : 0;

                tooltipContent.innerHTML = `
                    <div><strong>${GDP_ITEM_LABELS[itemCode] || itemCode}</strong></div>
                    <div style="margin-top:4px;">${formatGDPNumberWithEasyUnit(p.value, itemCode)} <span style="color:var(--text-sub);">(${formatGDPChange(change, 1)} / ${formatGDPChange(pct, 2)}% YoY)</span></div>
                `;

                tooltip.style.display = 'block';
                const tx = evt.clientX - container.getBoundingClientRect().left + 12;
                const ty = evt.clientY - container.getBoundingClientRect().top + 12;
                tooltip.style.left = `${tx}px`;
                tooltip.style.top = `${ty}px`;
            };

            const hide = () => {
                tooltip.style.display = 'none';
            };

            svg.onmousemove = show;
            svg.onmouseleave = hide;
        }

        function updateGDPChartHeader(stats) {
            const titleEl = document.getElementById('gdp-chart-main-title');
            const valueEl = document.getElementById('gdp-chart-main-value');
            const changeValueEl = document.getElementById('gdp-change-value');
            const changePercentEl = document.getElementById('gdp-change-percent');
            
            const itemCode = activeGDPItems[0];
            const itemLabel = GDP_ITEM_LABELS[itemCode] || itemCode;
            const currency = currentGDPCurrency === 'KRW' ? 'ÏõêÌôî' : 'Îã¨Îü¨';
            const unit = GDP_ITEM_UNITS[itemCode] || '';
            
            if (titleEl) {
                // ÌòïÏãù: "Ìï≠Î™©Î™Ö(ÌÜµÌôî)(Ïó∞Í∞Ñ) / Îã®ÏúÑ : Îã®ÏúÑÎ™Ö"
                titleEl.textContent = `${itemLabel}(${currency})(Ïó∞Í∞Ñ) / Îã®ÏúÑ : ${unit}`;
            }

            if (valueEl) valueEl.textContent = formatGDPNumberWithEasyUnit(stats.current, itemCode);

            if (changeValueEl && changePercentEl) {
                const isUp = stats.change > 0;
                const isDown = stats.change < 0;
                changeValueEl.textContent = formatGDPChange(stats.change, 1);
                changePercentEl.textContent = `(${formatGDPChange(stats.changePercent, 2)}%) YoY`;
                changeValueEl.className = `change-value ${isUp ? 'up' : (isDown ? 'down' : '')}`;
                changePercentEl.className = `change-percent ${isUp ? 'up' : (isDown ? 'down' : '')}`;
            }
        }

        function renderGDPBarChart(itemCode, data) {
            const g = document.getElementById('gdp-bar-chart');
            if (!g) return;
            g.innerHTML = ''; // Í∏∞Ï°¥ ÎßâÎåÄ Ï†úÍ±∞ (Îã®Ïùº Ìï≠Î™©Îßå ÌëúÏãú)

            const svg = document.getElementById('gdp-chart-svg');
            if (!svg) return;
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            const minValue = gdpYAxisRange.min;
            const maxValue = gdpYAxisRange.max;
            const valueRange = maxValue - minValue || 1;

            const colorMap = {
                // Î∂ÄÎ™® ÏΩîÎìú ÏÉâÏÉÅ
                '10101': 'var(--c-gdp-total)',
                '1010101': 'var(--c-gdp-total)',
                '10102': 'var(--c-gdp-consumption)',
                '1010201': 'var(--c-gdp-consumption)',
                '10106': 'var(--c-gdp-investment)',
                '1010601': 'var(--c-gdp-investment)',
                '1010602': 'var(--c-gdp-investment)',
                '1010603': 'var(--c-gdp-investment)',
                '10107': 'var(--accent-color)',
                '1010701': 'var(--accent-color)'
            };
            const fill = colorMap[itemCode] || 'var(--accent-color)';

            // Ïó∞ÎèÑÎ≥Ñ: Ïó∞ÎèÑ Í∞úÏàòÎßåÌÅº ÎßâÎåÄ Î†åÎçîÎßÅ
            const n = Math.max(1, data.length);
            const gap = Math.max(8, Math.round(chartWidth * 0.02));
            const barW = Math.max(10, (chartWidth - gap * (n - 1)) / n);

            data.forEach((p, i) => {
                const x = padding.left + i * (barW + gap);
                const normalizedValue = (p.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                const h = (padding.top + chartHeight) - y;

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', String(x));
                rect.setAttribute('y', String(y));
                rect.setAttribute('width', String(barW));
                rect.setAttribute('height', String(Math.max(0, h)));
                rect.setAttribute('rx', '6');
                rect.setAttribute('fill', fill);
                rect.setAttribute('opacity', '0.9');
                g.appendChild(rect);
            });
        }

        function processExchangeRateData(results) {
            // chartData Ï¥àÍ∏∞Ìôî
            chartData = {};
            
            results.forEach(result => {
                const { currency, data } = result;
                
                if (data.error) {
                    console.error(`Error for ${currency}:`, data.error);
                    return;
                }
                
                if (data.StatisticSearch && data.StatisticSearch.row) {
                    const rows = data.StatisticSearch.row;
                    
                    // ÎÇ†ÏßúÎ≥Ñ ÌôòÏú® Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
                    const values = rows.map(row => ({
                        date: row.TIME, // YYYYMMDD ÌòïÏãù
                        value: parseFloat(row.DATA_VALUE)
                    }));
                    
                    chartData[currency] = values;
                    
                    // ÏµúÏã† ÌôòÏú® Ï†ÄÏû• (Í≥ÑÏÇ∞Í∏∞Ïö©)
                    if (values.length > 0) {
                        const latest = values[values.length - 1];
                        const previous = values.length > 1 ? values[values.length - 2] : null;
                        
                        // Ï†ÑÏùº ÌôòÏú® Ï†ÄÏû•
                        if (previous) {
                            previousRates[currency] = previous.value;
                        }
                        
                        exchangeRates[currency] = latest.value;
                    }
                }
            });
            
            // Ìà¥ÌåÅ/Ïù∏ÌÑ∞ÎûôÏÖò + XÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅÏùÑ ÏúÑÌïú Ï∫êÏãú Ïû¨Íµ¨Ï∂ïÏùÑ Î®ºÏ†Ä ÏàòÌñâ
            // (renderXAxisLabels()Í∞Ä tooltipCache.allDatesÎ•º ÏÇ¨Ïö©ÌïòÎØÄÎ°ú ÏàúÏÑúÍ∞Ä Ï§ëÏöî)
            rebuildTooltipCache();
            
            // Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ (Ïó¨Í∏∞ÏÑú XÏ∂ï ÎùºÎ≤®ÎèÑ Ìï®Íªò Î†åÎçîÎßÅÎê®)
            updateChart();
            
            // Í≥ÑÏÇ∞Í∏∞ ÏóÖÎç∞Ïù¥Ìä∏
            updateCalculator();
            
            // ÌôòÏú® ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
            updateCurrencyRatesTable();

            // Ï∞®Ìä∏ Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Í∏∞Îä• ÏÑ§Ï†ï
            setupChartInteractivity();
            
            // Ï≤´ Î≤àÏß∏ ÌôúÏÑ± ÌÜµÌôîÏùò ÌÜµÍ≥Ñ Ï†ïÎ≥¥ ÌëúÏãú
            if (activeCurrencies.length > 0) {
                const primaryCurrency = activeCurrencies[0];
                const economyPanel = document.getElementById('economy-panel');
                if (economyPanel) {
                    const dateInputs = economyPanel.querySelectorAll('.date-input');
                    if (dateInputs.length >= 2) {
                        const startDate = formatDateForAPI(dateInputs[0].value);
                        const endDate = formatDateForAPI(dateInputs[1].value);
                        fetchExchangeRateStats(primaryCurrency, startDate, endDate)
                            .then(stats => {
                                if (stats) {
                                    updateChartHeader(primaryCurrency, stats);
                                }
                            });
                    }
                }
            }
        }

        // ----- Tooltip performance cache -----
        // tooltipCache.perCurrency[curr] = { map: { [YYYYMMDD]: {date, value} }, dates: [YYYYMMDD...] (sorted) }
        let tooltipCache = { allDates: [], perCurrency: {} };

        function rebuildTooltipCache() {
            const perCurrency = {};
            const allDatesSet = new Set();

            Object.keys(chartData || {}).forEach(curr => {
                const arr = chartData[curr] || [];
                if (!Array.isArray(arr) || arr.length === 0) return;

                const map = {};
                const dates = new Array(arr.length);
                for (let i = 0; i < arr.length; i++) {
                    const item = arr[i];
                    map[item.date] = item;
                    dates[i] = item.date;
                    allDatesSet.add(item.date);
                }
                dates.sort(); // YYYYMMDD Î¨∏ÏûêÏó¥ Ï†ïÎ†¨ == ÎÇ†Ïßú Ïò§Î¶ÑÏ∞®Ïàú
                perCurrency[curr] = { map, dates };
            });

            tooltipCache = {
                allDates: Array.from(allDatesSet).sort(),
                perCurrency
            };
        }

        function findClosestDate(sortedDates, targetDateStr) {
            if (!sortedDates || sortedDates.length === 0) return null;
            const target = parseInt(targetDateStr, 10);
            let lo = 0;
            let hi = sortedDates.length - 1;

            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const midVal = parseInt(sortedDates[mid], 10);
                if (midVal === target) return sortedDates[mid];
                if (midVal < target) lo = mid + 1;
                else hi = mid - 1;
            }

            // loÎäî ÏÇΩÏûÖ ÏúÑÏπò. hiÎäî lo-1
            const candA = sortedDates[Math.max(0, hi)];
            const candB = sortedDates[Math.min(sortedDates.length - 1, lo)];
            if (!candA) return candB || null;
            if (!candB) return candA || null;

            const diffA = Math.abs(parseInt(candA, 10) - target);
            const diffB = Math.abs(parseInt(candB, 10) - target);
            return diffA <= diffB ? candA : candB;
        }

        function getSvgViewBoxSize(svgEl) {
            try {
                const vb = (svgEl && svgEl.getAttribute) ? svgEl.getAttribute('viewBox') : null;
                if (vb) {
                    const parts = vb.trim().split(/\s+/).map(Number);
                    if (parts.length === 4 && parts.every(n => Number.isFinite(n))) {
                        return { width: parts[2], height: parts[3] };
                    }
                }
            } catch (e) {
                // ignore
            }
            return { width: 800, height: 300 };
        }

        function generateSVGPath(currency, data) {
            if (!data || data.length === 0) return '';
            
            const svg = document.querySelector('.chart-svg');
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // YÏ∂ï Î†àÏù¥Î∏îÏóêÏÑú Í≥ÑÏÇ∞Îêú Î≤îÏúÑ ÏÇ¨Ïö© (Ïã§Ï†ú Ï∂úÎ†•ÎêòÎäî Í∞í Î≤îÏúÑ)
            const minValue = yAxisRange.min;
            const maxValue = yAxisRange.max;
            const valueRange = maxValue - minValue || 1; // 0ÏúºÎ°ú ÎÇòÎàÑÍ∏∞ Î∞©ÏßÄ
            
            // Path Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            let pathData = '';
            data.forEach((point, index) => {
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                // YÏ∂ïÏùÄ ÏúÑÏóêÏÑú ÏïÑÎûòÎ°ú (Í∞íÏù¥ ÌÅ¥ÏàòÎ°ù ÏïÑÎûò)
                // YÏ∂ï Î†àÏù¥Î∏îÍ≥º ÎèôÏùºÌïú Î≤îÏúÑÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Ï†ïÍ∑úÌôî
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            return pathData;
        }

        // ----- X Axis Labels (period-aware, sparse) -----
        let currentRangeKey = null; // '1W' | '1M' | '3M' | '1Y' | null

        function inferRangeKeyFromInputs() {
            const inputs = document.querySelectorAll('.date-input');
            if (!inputs || inputs.length < 2) return '3M';
            const a = new Date(inputs[0].value);
            const b = new Date(inputs[1].value);
            if (isNaN(a.getTime()) || isNaN(b.getTime())) return '3M';
            const diffDays = Math.abs(Math.round((b.getTime() - a.getTime()) / (1000 * 60 * 60 * 24)));
            if (diffDays <= 8) return '1W';
            if (diffDays <= 45) return '1M';
            if (diffDays <= 120) return '3M';
            return '1Y';
        }

        function getActiveRangeKey() {
            if (currentRangeKey === '1W' || currentRangeKey === '1M' || currentRangeKey === '3M' || currentRangeKey === '1Y') {
                return currentRangeKey;
            }
            const btn = document.querySelector('.period-btn.active');
            const key = btn ? btn.textContent.trim() : null;
            if (key === '1W' || key === '1M' || key === '3M' || key === '1Y') return key;
            return inferRangeKeyFromInputs();
        }

        function parseYYYYMMDD(dateStr) {
            if (!dateStr || dateStr.length !== 8) return null;
            const y = parseInt(dateStr.slice(0, 4), 10);
            const m = parseInt(dateStr.slice(4, 6), 10) - 1;
            const d = parseInt(dateStr.slice(6, 8), 10);
            return new Date(y, m, d);
        }

        // Ï£ºÍ∏∞Ïóê Îî∞Îùº ÎÇ†ÏßúÎ•º ÌååÏã±ÌïòÎäî Ìï®Ïàò
        function parseInterestDate(dateStr, cycle) {
            if (!dateStr) return null;
            
            if (cycle === 'M') {
                // ÏõîÎ≥Ñ: YYYYMM -> Ìï¥Îãπ ÏõîÏùò Ï≤´Ïß∏ ÎÇ†Î°ú Î≥ÄÌôò
                if (dateStr.length === 6) {
                    const year = parseInt(dateStr.substring(0, 4), 10);
                    const month = parseInt(dateStr.substring(4, 6), 10) - 1;
                    return new Date(year, month, 1);
                }
            } else if (cycle === 'Q') {
                // Î∂ÑÍ∏∞Î≥Ñ: YYYYQn (Ïòà: 2024Q1) -> Ìï¥Îãπ Î∂ÑÍ∏∞ Ï≤´Ïß∏ ÎÇ†Î°ú Î≥ÄÌôò
                const match = dateStr.match(/^(\d{4})Q([1-4])$/);
                if (match) {
                    const year = parseInt(match[1], 10);
                    const quarter = parseInt(match[2], 10);
                    const month = (quarter - 1) * 3; // Q1=0, Q2=3, Q3=6, Q4=9
                    return new Date(year, month, 1);
                }
            } else if (cycle === 'A') {
                // Ïó∞ÎèÑÎ≥Ñ: YYYY -> Ìï¥Îãπ Ïó∞ÎèÑÏùò 1Ïõî 1ÏùºÎ°ú Î≥ÄÌôò
                if (dateStr.length === 4) {
                    const year = parseInt(dateStr, 10);
                    return new Date(year, 0, 1);
                }
            }
            
            return null;
        }

        // Ï£ºÍ∏∞Ïóê Îî∞Îùº ÎÇ†ÏßúÎ•º Ìè¨Îß∑ÌïòÎäî Ìï®Ïàò
        function formatInterestDate(dateObj, cycle) {
            if (!dateObj) return '';
            
            if (cycle === 'M') {
                // ÏõîÎ≥Ñ: YYYY/MM
                return `${dateObj.getFullYear()}/${String(dateObj.getMonth() + 1).padStart(2, '0')}`;
            } else if (cycle === 'Q') {
                // Î∂ÑÍ∏∞Î≥Ñ: YYYY Qn
                const quarter = Math.floor(dateObj.getMonth() / 3) + 1;
                return `${dateObj.getFullYear()} Q${quarter}`;
            } else if (cycle === 'A') {
                // Ïó∞ÎèÑÎ≥Ñ: YYYY
                return String(dateObj.getFullYear());
            }
            
            return '';
        }

        // Ï£ºÍ∏∞Ïóê Îî∞Îùº ÎÇ†ÏßúÎ•º ÎπÑÍµê/Ï†ïÎ†¨ÌïòÎäî Ìï®Ïàò
        function compareInterestDates(a, b, cycle) {
            const dateA = parseInterestDate(a, cycle);
            const dateB = parseInterestDate(b, cycle);
            
            if (!dateA || !dateB) {
                // ÌååÏã± Ïã§Ìå® Ïãú Î¨∏ÏûêÏó¥ ÎπÑÍµê
                return a.localeCompare(b);
            }
            
            return dateA.getTime() - dateB.getTime();
        }

        function weekdayKoShort(dateObj) {
            const arr = ['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'];
            return arr[dateObj.getDay()];
        }

        function toYYYYMMDD(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}${m}${day}`;
        }

        function daysInMonth(year, monthIndex) {
            // monthIndex: 0..11
            return new Date(year, monthIndex + 1, 0).getDate();
        }

        function makeDateSafe(year, monthIndex, dayOfMonth) {
            const dim = daysInMonth(year, monthIndex);
            return new Date(year, monthIndex, Math.min(dayOfMonth, dim));
        }

        function dedupeAndSortTargets(targets) {
            // targets: [{ idx, label }]
            const map = new Map();
            for (const t of targets) {
                if (t && Number.isFinite(t.idx)) map.set(t.idx, t); // idx Í∏∞Ï§Ä Ï§ëÎ≥µ Ï†úÍ±∞
            }
            return Array.from(map.values()).sort((a, b) => a.idx - b.idx);
        }

        function buildXAxisTargets(rangeKey, dates, endDateOverride = null) {
            // endDateOverrideÍ∞Ä Ï†úÍ≥µÎêòÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Ïùò ÎßàÏßÄÎßâ ÎÇ†Ïßú ÏÇ¨Ïö©
            let endDateStr, endObj;
            
            if (endDateOverride) {
                // YYYY-MM-DD ÌòïÏãùÏù¥Î©¥ YYYYMMDDÎ°ú Î≥ÄÌôò
                if (endDateOverride.includes('-')) {
                    endDateStr = endDateOverride.replace(/-/g, '');
                } else {
                    endDateStr = endDateOverride;
                }
                endObj = parseYYYYMMDD(endDateStr);
            } else {
                // Í∏∞Ï°¥ Î°úÏßÅ: Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Ïùò ÎßàÏßÄÎßâ ÎÇ†Ïßú ÏÇ¨Ïö©
                const n = dates.length;
                endDateStr = dates[n - 1];
                endObj = parseYYYYMMDD(endDateStr);
            }
            
            if (!endObj) return [];

            const indexMap = {};
            for (let i = 0; i < dates.length; i++) indexMap[dates[i]] = i;

            const targets = []; // { idx, label }
            const formatMD = (dObj) => {
                const month = String(dObj.getMonth() + 1).padStart(2, '0');
                const day = String(dObj.getDate()).padStart(2, '0');
                return `${month}.${day}`;
            };

            const snap = (targetStr) => {
                const closest = findClosestDate(dates, targetStr);
                if (!closest) return null;
                const idx = indexMap[closest];
                if (idx == null) return null;
                return { closest, idx };
            };

            if (rangeKey === '1W') {
                // ÏµúÏã† ÎÇ†Ïßú Í∏∞Ï§Ä -6Ïùº ~ 0Ïùº (Îã¨Î†• Í∏∞Ï§Ä) ÌÉÄÍ≤üÏùÑ ÎßåÎì§Í≥† Í∞ÄÏû• Í∞ÄÍπåÏö¥ Îç∞Ïù¥ÌÑ∞Î°ú Ïä§ÎÉÖ
                for (let dBack = 6; dBack >= 0; dBack--) {
                    const candidate = new Date(endObj.getFullYear(), endObj.getMonth(), endObj.getDate() - dBack);
                    const s = snap(toYYYYMMDD(candidate));
                    if (!s) continue;
                    const dObj = parseYYYYMMDD(s.closest);
                    if (!dObj) continue;
                    targets.push({ idx: s.idx, label: String(dObj.getDate()) });
                }
                // ÎßàÏßÄÎßâ Î†àÏù¥Î∏îÏù¥ Ìï≠ÏÉÅ Ïò§Îäò(Ï¢ÖÎ£åÏùº)Ïù¥ ÎêòÎèÑÎ°ù Î≥¥Ïû•
                if (endDateOverride) {
                    const todayIdx = dates.length - 1; // ÎßàÏßÄÎßâ Ïù∏Îç±Ïä§
                    const todayLabel = formatMD(endObj);
                    targets.push({ idx: todayIdx, label: todayLabel });
                }
                return dedupeAndSortTargets(targets);
            }

            if (rangeKey === '1M') {
                // ÏµúÏã† ÎÇ†Ïßú Í∏∞Ï§Ä 4Ï£ºÏ∞®: -21, -14, -7, 0Ïùº
                const offsets = [21, 14, 7, 0];
                for (const off of offsets) {
                    const candidate = new Date(endObj.getFullYear(), endObj.getMonth(), endObj.getDate() - off);
                    const s = snap(toYYYYMMDD(candidate));
                    if (!s) continue;
                    const dObj = parseYYYYMMDD(s.closest);
                    if (!dObj) continue;
                    targets.push({ idx: s.idx, label: formatMD(dObj) });
                }
                // ÎßàÏßÄÎßâ Î†àÏù¥Î∏îÏù¥ Ìï≠ÏÉÅ Ïò§Îäò(Ï¢ÖÎ£åÏùº)Ïù¥ ÎêòÎèÑÎ°ù Î≥¥Ïû•
                if (endDateOverride) {
                    const todayIdx = dates.length - 1;
                    const todayLabel = formatMD(endObj);
                    targets.push({ idx: todayIdx, label: todayLabel });
                }
                return dedupeAndSortTargets(targets);
            }

            if (rangeKey === '3M') {
                // ÏµúÏã† ÎÇ†ÏßúÏùò "Ïùº"ÏùÑ Ïú†ÏßÄÌïú Ï±Ñ 3Í∞úÏõî: -2, -1, 0Í∞úÏõî
                for (let mBack = 2; mBack >= 0; mBack--) {
                    const year = endObj.getFullYear();
                    const monthIndex = endObj.getMonth() - mBack;
                    const candidate = makeDateSafe(year, monthIndex, endObj.getDate());
                    const s = snap(toYYYYMMDD(candidate));
                    if (!s) continue;
                    const dObj = parseYYYYMMDD(s.closest);
                    if (!dObj) continue;
                    targets.push({ idx: s.idx, label: formatMD(dObj) });
                }
                // ÎßàÏßÄÎßâ Î†àÏù¥Î∏îÏù¥ Ìï≠ÏÉÅ Ïò§Îäò(Ï¢ÖÎ£åÏùº)Ïù¥ ÎêòÎèÑÎ°ù Î≥¥Ïû•
                if (endDateOverride) {
                    const todayIdx = dates.length - 1;
                    const todayLabel = formatMD(endObj);
                    targets.push({ idx: todayIdx, label: todayLabel });
                }
                return dedupeAndSortTargets(targets);
            }

            if (rangeKey === '1Y') {
                // ÏµúÏã† ÎÇ†ÏßúÏùò "Ïùº"ÏùÑ Ïú†ÏßÄÌïú Ï±Ñ 12Í∞úÏõî: -11..0Í∞úÏõî
                for (let mBack = 11; mBack >= 0; mBack--) {
                    const year = endObj.getFullYear();
                    const monthIndex = endObj.getMonth() - mBack;
                    const candidate = makeDateSafe(year, monthIndex, endObj.getDate());
                    const s = snap(toYYYYMMDD(candidate));
                    if (!s) continue;
                    const dObj = parseYYYYMMDD(s.closest);
                    if (!dObj) continue;
                    targets.push({ idx: s.idx, label: formatMD(dObj) });
                }
                // ÎßàÏßÄÎßâ Î†àÏù¥Î∏îÏù¥ Ìï≠ÏÉÅ Ïò§Îäò(Ï¢ÖÎ£åÏùº)Ïù¥ ÎêòÎèÑÎ°ù Î≥¥Ïû•
                if (endDateOverride) {
                    const todayIdx = dates.length - 1;
                    const todayLabel = formatMD(endObj);
                    targets.push({ idx: todayIdx, label: todayLabel });
                }
                return dedupeAndSortTargets(targets);
            }

            return [];
        }

        function renderYAxisLabels() {
            const svg = document.querySelector('.chart-svg');
            const g = document.getElementById('y-axis-labels');
            if (!svg || !g) return;

            // Í∏∞Ï°¥ ÎùºÎ≤® Ï†úÍ±∞
            g.innerHTML = '';

            // Î™®Îì† ÌôúÏÑ± ÌÜµÌôîÏùò Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏµúÏÜå/ÏµúÎåÄÍ∞í Í≥ÑÏÇ∞
            let minValue = Infinity;
            let maxValue = -Infinity;

            activeCurrencies.forEach(currency => {
                const data = chartData[currency];
                if (data && data.length > 0) {
                    const values = data.map(d => d.value);
                    const dataMin = Math.min(...values);
                    const dataMax = Math.max(...values);
                    minValue = Math.min(minValue, dataMin);
                    maxValue = Math.max(maxValue, dataMax);
                }
            });

            if (minValue === Infinity || maxValue === Infinity) {
                yAxisRange = { min: 0, max: 0 };
                return;
            }

            // Í∞í Î≤îÏúÑ Í≥ÑÏÇ∞
            const range = maxValue - minValue;
            
            // Îçî ÌÉÄÏù¥Ìä∏Ìïú ÎèôÏ†Å Ïó¨Î∞± Ï°∞Ï†ï: Î≥ÄÎèô Ï∂îÏù¥Î•º Îçî ÎìúÎùºÎßàÌã±ÌïòÍ≤å Î≥¥Ïù¥ÎèÑÎ°ù
            // ÏûëÏùÄ Î≤îÏúÑ(100 Ïù¥Ìïò): 1% Ïó¨Î∞±
            // Ï§ëÍ∞Ñ Î≤îÏúÑ(100-1000): 0.5% Ïó¨Î∞±  
            // ÌÅ∞ Î≤îÏúÑ(1000 Ïù¥ÏÉÅ): 0.3% Ïó¨Î∞±
            let paddingPercent = 0.01; // Í∏∞Î≥∏ 1%
            if (range > 1000) {
                paddingPercent = 0.003; // 0.3%
            } else if (range > 100) {
                paddingPercent = 0.005; // 0.5%
            }
            
            const padding = range * paddingPercent;
            
            // ÏµúÏÜåÍ∞íÏù¥ 0Î≥¥Îã§ ÏûëÏïÑÏßÄÏßÄ ÏïäÎèÑÎ°ù Î≥¥Ï†ï
            // Îã®, ÏµúÏÜåÍ∞íÏù¥ Î≤îÏúÑÏùò 5% Ïù¥ÌïòÏùº ÎïåÎßå 0ÏúºÎ°ú Í≥†Ï†ï (Îçî ÌÉÄÏù¥Ìä∏ÌïòÍ≤å)
            const calculatedMin = minValue - padding;
            const calculatedMax = maxValue + padding;
            
            // Ïã§Ï†ú YÏ∂ï Î≤îÏúÑ Ï†ÄÏû•
            // ÏµúÏÜåÍ∞íÏù¥ Î≤îÏúÑÏùò 5% Ïù¥ÌïòÏù¥Í≥† 0 Í∑ºÏ≤òÏùº ÎïåÎßå 0ÏúºÎ°ú Í≥†Ï†ï
            const minValueRatio = minValue / (maxValue || 1);
            if (calculatedMin < 0 || (minValueRatio < 0.05 && minValue < range * 0.1)) {
                // ÌïòÎã®ÏùÑ 0ÏúºÎ°ú Í≥†Ï†ïÌïòÎêò, Ïó¨Î∞±ÏùÑ ÏµúÏÜåÌôî
                yAxisRange.min = 0;
                // ÏÉÅÎã® Ïó¨Î∞±ÏùÄ Ïú†ÏßÄÌïòÎêò, ÌïòÎã®Ïù¥ 0Ïù¥ÎØÄÎ°ú Ï†ÑÏ≤¥ Î≤îÏúÑ Ï°∞Ï†ï
                yAxisRange.max = maxValue + padding + Math.abs(Math.min(0, calculatedMin));
            } else {
                // ÏµúÏÜåÍ∞íÏù¥ Ï∂©Î∂ÑÌûà ÌÅ¨Î©¥ Ïã§Ï†ú ÏµúÏÜåÍ∞íÏóê Í∞ÄÍπùÍ≤å ÏÑ§Ï†ï
                yAxisRange.min = calculatedMin;
                yAxisRange.max = calculatedMax;
            }
            
            // YÏ∂ï Î†àÏù¥Î∏îÏùÄ Ïã§Ï†ú Ï†ÄÏû•Îêú Î≤îÏúÑ ÏÇ¨Ïö©
            const { width, height } = getSvgViewBoxSize(svg);
            const padding_axis = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartHeight = height - padding_axis.top - padding_axis.bottom;

            // 5-7Í∞úÏùò Î†àÏù¥Î∏î ÏÉùÏÑ±
            const numLabels = 6;
            const step = (yAxisRange.max - yAxisRange.min) / (numLabels - 1);

            for (let i = 0; i < numLabels; i++) {
                const value = yAxisRange.max - (step * i);
                const y = padding_axis.top + (i / (numLabels - 1)) * chartHeight;

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', String(padding_axis.left - 10));
                label.setAttribute('y', String(y));
                label.setAttribute('class', 'chart-yaxis-label');
                label.textContent = value.toLocaleString('ko-KR', { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: 2 
                });
                g.appendChild(label);
            }
        }

        function renderXAxisLabels() {
            const svg = document.querySelector('.chart-svg');
            const g = document.getElementById('x-axis-labels');
            if (!svg || !g) return;

            // Í∏∞Ï°¥ ÎùºÎ≤® Ï†úÍ±∞
            g.innerHTML = '';

            const dates = (tooltipCache && tooltipCache.allDates) ? tooltipCache.allDates : [];
            if (!dates || dates.length === 0) return;

            const rangeKey = getActiveRangeKey();
            
            // ÎÇ†Ïßú ÏûÖÎ†• ÌïÑÎìúÏóêÏÑú Ï¢ÖÎ£åÏùº(Ïò§Îäò) Í∞ÄÏ†∏Ïò§Í∏∞
            const dateInputs = document.querySelectorAll('.date-input');
            let endDateOverride = null;
            if (dateInputs.length >= 2 && dateInputs[1].value) {
                endDateOverride = dateInputs[1].value; // YYYY-MM-DD ÌòïÏãù
            }
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { left: 40, right: 20, top: 20, bottom: 30 };
            const chartWidth = width - padding.left - padding.right;

            // ÌïòÎã® ÎùºÎ≤® y ÏúÑÏπò (viewBox Í∏∞Ï§Ä)
            const y = height - padding.bottom + 15;

            const targets = buildXAxisTargets(rangeKey, dates, endDateOverride);
            const n = dates.length;

            // Î†åÎçîÎßÅ
            for (const tInfo of targets) {
                const i = tInfo.idx;
                const x = padding.left + (i / (n - 1 || 1)) * chartWidth;
                const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                t.setAttribute('x', x.toFixed(2));
                t.setAttribute('y', String(y));
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'middle');
                t.setAttribute('class', 'chart-xaxis-label');
                t.textContent = tInfo.label;
                g.appendChild(t);
            }
        }

        function updateChart() {
            // Î™®Îì† ÌÜµÌôî path Ï¥àÍ∏∞Ìôî
            const allCurrencies = ['USD', 'EUR', 'JPY', 'CNY', 'GBP', 'CHF', 'HKD', 'CAD', 'RUB'];
            allCurrencies.forEach(curr => {
                const path = document.getElementById(`path-${curr}`);
                if (path) {
                    path.setAttribute('d', '');
                    path.classList.remove('visible');
                }
            });
            
            // YÏ∂ï ÎùºÎ≤®ÏùÑ Î®ºÏ†Ä Î†åÎçîÎßÅÌïòÏó¨ Î≤îÏúÑ Í≥ÑÏÇ∞
            renderYAxisLabels();
            
            // ÌôúÏÑ±ÌôîÎêú ÌÜµÌôîÎßå ÌëúÏãú (YÏ∂ï Î≤îÏúÑÍ∞Ä Í≥ÑÏÇ∞Îêú ÌõÑ)
            activeCurrencies.forEach(currency => {
                if (!CURRENCY_MAPPING[currency]) return;
                
                const path = document.getElementById(`path-${currency}`);
                if (!path) return;
                
                const data = chartData[currency];
                if (data && data.length > 0) {
                    const pathData = generateSVGPath(currency, data);
                    path.setAttribute('d', pathData);
                    path.classList.add('visible');
                }
            });
            
            // XÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ (Í∏∞Í∞ÑÎ≥Ñ ÎåÄÌëú Í∏∞Ï§ÄÏ†êÎßå ÌëúÏãú)
            renderXAxisLabels();
        }

        // Toggle Logic
        function toggleCurrency(curr) {
            const btn = document.querySelector(`.chip[data-curr="${curr}"]`);
            if (!btn) return;
            
            btn.classList.toggle('active');
            const isActive = btn.classList.contains('active');
            
            // activeCurrencies Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏
            if (isActive) {
                if (!activeCurrencies.includes(curr)) {
                    activeCurrencies.push(curr);
                }
            } else {
                activeCurrencies = activeCurrencies.filter(c => c !== curr);
            }
            
            // ÌÜµÌôîÍ∞Ä ÌïòÎÇòÎßå ÏÑ†ÌÉùÎêòÏóàÏùÑ Îïå ÌôòÏú® Í≥ÑÏÇ∞Í∏∞ ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏
            if (activeCurrencies.length === 1) {
                const selectedCurrency = activeCurrencies[0];
                const currSelect = document.getElementById('curr-from');
                if (currSelect && currSelect.value !== selectedCurrency) {
                    currSelect.value = selectedCurrency;
                    calculate(); // Í≥ÑÏÇ∞Í∏∞ ÏóÖÎç∞Ïù¥Ìä∏
                }
            }
            
            // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ API Ìò∏Ï∂ú
            if (isActive && (!chartData[curr] || chartData[curr].length === 0)) {
                fetchExchangeRateData();
            } else {
                // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ Ï¶âÏãú Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
                updateChart();
                
                // ÌôúÏÑ± ÌÜµÌôîÍ∞Ä ÏûàÏúºÎ©¥ Ï≤´ Î≤àÏß∏ ÌÜµÌôîÏùò ÌÜµÍ≥Ñ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                if (activeCurrencies.length > 0) {
                    const primaryCurrency = activeCurrencies[0];
                    const economyPanel = document.getElementById('economy-panel');
                    if (economyPanel) {
                        const dateInputs = economyPanel.querySelectorAll('.date-input');
                        if (dateInputs.length >= 2) {
                            const startDate = formatDateForAPI(dateInputs[0].value);
                            const endDate = formatDateForAPI(dateInputs[1].value);
                            fetchExchangeRateStats(primaryCurrency, startDate, endDate)
                                .then(stats => {
                                    if (stats) {
                                        updateChartHeader(primaryCurrency, stats);
                                    }
                                });
                        }
                    }
                }
            }
        }

        // ÎÇ†Ïßú Ìè¨Îß∑ Ìï®Ïàò
        function formatDate(dateStr) {
            // YYYYMMDD ÌòïÏãùÏùÑ YYYY-MM-DDÎ°ú Î≥ÄÌôò
            if (dateStr && dateStr.length === 8) {
                return `${dateStr.substring(0,4)}-${dateStr.substring(4,6)}-${dateStr.substring(6,8)}`;
            }
            return dateStr;
        }

        // ÎßàÏö∞Ïä§ ÏúÑÏπòÏóêÏÑú ÎÇ†Ïßú Ï∞æÍ∏∞
        function getDateFromMouseX(mouseX, chartRect) {
            const svg = document.querySelector('.chart-svg');
            if (!svg) return null;
            
            const svgRect = svg.getBoundingClientRect();
            const { width: vbW } = getSvgViewBoxSize(svg);
            const padding = { left: 40, right: 20 };
            // viewBox paddingÏùÑ Ïã§Ï†ú ÌîΩÏÖÄ Ìè≠ÏúºÎ°ú ÌôòÏÇ∞
            const padLeftPx = (padding.left / vbW) * svgRect.width;
            const padRightPx = (padding.right / vbW) * svgRect.width;
            const chartWidthPx = Math.max(1, svgRect.width - padLeftPx - padRightPx);
            
            // ÎßàÏö∞Ïä§ X Ï¢åÌëúÎ•º SVG Ï¢åÌëúÍ≥ÑÎ°ú Î≥ÄÌôò
            const relativeX = mouseX - svgRect.left - padLeftPx;
            const ratio = Math.max(0, Math.min(1, relativeX / chartWidthPx));
            
            // Ï∫êÏãúÎêú Ï†ÑÏ≤¥ ÎÇ†Ïßú ÏÇ¨Ïö© (mousemoveÎßàÎã§ Ï†ïÎ†¨/Set ÏÉùÏÑ± Î∞©ÏßÄ)
            const allDates = (tooltipCache && tooltipCache.allDates) ? tooltipCache.allDates : [];
            
            if (allDates.length === 0) return null;
            
            const index = Math.floor(ratio * (allDates.length - 1));
            return allDates[index];
        }

        // Ìà¥ÌåÅ ÌëúÏãú
        function showTooltip(event, date) {
            const tooltip = document.getElementById('chart-tooltip');
            const tooltipDate = document.getElementById('tooltip-date');
            const tooltipContent = document.getElementById('tooltip-content');
            
            if (!tooltip || !tooltipDate || !tooltipContent || !date || !chartData) return;
            
            // ÎÇ†Ïßú ÌëúÏãú
            const formattedDate = formatDate(date);
            const dateObj = parseYYYYMMDD(date);
            tooltipDate.textContent = dateObj ? `${formattedDate} (${weekdayKoShort(dateObj)})` : formattedDate;
            
            // ÌôúÏÑ±ÌôîÎêú ÌÜµÌôîÎì§Ïùò ÌôòÏú® ÌëúÏãú
            let content = '';
            activeCurrencies.forEach(currency => {
                const c = tooltipCache && tooltipCache.perCurrency ? tooltipCache.perCurrency[currency] : null;
                if (c && c.dates && c.dates.length > 0) {
                    // exact -> closest (O(1) map + O(log n) Ïù¥ÏßÑÌÉêÏÉâ)
                    let item = c.map[date];
                    if (!item) {
                        const closest = findClosestDate(c.dates, date);
                        item = closest ? c.map[closest] : null;
                    }
                    
                    if (item) {
                        const color = getComputedStyle(document.documentElement)
                            .getPropertyValue(`--c-${currency.toLowerCase()}`).trim();
                        
                        content += `
                            <div class="chart-tooltip-item">
                                <div class="chart-tooltip-currency">
                                    <div class="chart-tooltip-dot" style="background: ${color}"></div>
                                    <span>${currency}</span>
                                </div>
                                <span class="chart-tooltip-value">${parseFloat(item.value).toLocaleString('ko-KR')} Ïõê</span>
                            </div>
                        `;
                    }
                }
            });
            
            if (!content) {
                hideTooltip();
                return;
            }
            
            tooltipContent.innerHTML = content;
            
            // Ìà¥ÌåÅÏùÑ Î®ºÏ†Ä ÌëúÏãúÌï¥ÏÑú ÌÅ¨Í∏∞Î•º Ï∏°Ï†ï
            tooltip.style.visibility = 'hidden';
            tooltip.classList.add('visible');
            
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const padding = 10; // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ Ïó¨Î∞±
            
            // Í∏∞Î≥∏ ÏúÑÏπò (ÎßàÏö∞Ïä§ Ïò§Î•∏Ï™Ω ÏïÑÎûò)
            let left = event.clientX + 15;
            let top = event.clientY + 15;
            
            // Ïö∞Ï∏° Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Ï°∞Ï†ï
            if (left + tooltipRect.width > viewportWidth - padding) {
                // ÏôºÏ™ΩÏúºÎ°ú Ïù¥Îèô
                left = event.clientX - tooltipRect.width - 15;
            }
            
            // Ï¢åÏ∏° Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Ï°∞Ï†ï
            if (left < padding) {
                // Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïù¥ÎèôÌïòÍ±∞ÎÇò ÌôîÎ©¥ ÏôºÏ™Ω ÎÅùÏóê Í≥†Ï†ï
                if (event.clientX + tooltipRect.width + 15 <= viewportWidth - padding) {
                    left = event.clientX + 15;
                } else {
                    left = padding;
                }
            }
            
            // ÌïòÎã® Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Ï°∞Ï†ï
            if (top + tooltipRect.height > viewportHeight - padding) {
                // ÏúÑÎ°ú Ïù¥Îèô
                top = event.clientY - tooltipRect.height - 15;
            }
            
            // ÏÉÅÎã® Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Ï°∞Ï†ï
            if (top < padding) {
                // ÏïÑÎûòÎ°ú Ïù¥ÎèôÌïòÍ±∞ÎÇò ÌôîÎ©¥ ÏÉÅÎã® ÎÅùÏóê Í≥†Ï†ï
                if (event.clientY + tooltipRect.height + 15 <= viewportHeight - padding) {
                    top = event.clientY + 15;
                } else {
                    top = padding;
                }
            }
            
            // ÏµúÏ¢Ö Í≤ÄÏ¶ù Î∞è Í∞ïÏ†ú Ï°∞Ï†ï (Î™®Îì† Î∞©Ìñ•Ïù¥ Î∂àÍ∞ÄÎä•Ìïú Í≤ΩÏö∞)
            if (left < padding) left = padding;
            if (left + tooltipRect.width > viewportWidth - padding) {
                left = viewportWidth - padding - tooltipRect.width;
            }
            if (top < padding) top = padding;
            if (top + tooltipRect.height > viewportHeight - padding) {
                top = viewportHeight - padding - tooltipRect.height;
            }
            
            // fixed + transformÏúºÎ°ú Ïù¥Îèô(Î†àÏù¥ÏïÑÏõÉ/Î¶¨ÌîåÎ°úÏö∞ ÏµúÏÜåÌôî)
            tooltip.style.transform = `translate3d(${left}px, ${top}px, 0)`;
            tooltip.style.visibility = 'visible';
        }

        // Ìà¥ÌåÅ Ïà®Í∏∞Í∏∞
        function hideTooltip() {
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
                tooltip.style.visibility = 'hidden';
            }
        }

        // Ìà¥ÌåÅÏùÑ bodyÎ°ú Ïù¥Îèô(Portal)Ìï¥ÏÑú overflow/transform ÏòÅÌñ• ÏôÑÏ†ÑÌûà Ï∞®Îã®
        function ensureTooltipInBody() {
            const tooltip = document.getElementById('chart-tooltip');
            if (!tooltip) return;
            if (tooltip.parentElement !== document.body) {
                document.body.appendChild(tooltip);
            }
        }

        // Ï∞®Ìä∏Ïóê ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä
        function setupChartInteractivity() {
            // Ïù¥ÎØ∏ ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏúºÎ©¥ Ïä§ÌÇµ
            if (chartInteractivitySetup) return;
            
            const chartContainer = document.getElementById('chart-container');
            const svg = document.querySelector('.chart-svg');
            
            if (!chartContainer || !svg) return;

            // Portal Î≥¥Ïû•
            ensureTooltipInBody();
            
            // mousemove rAF Ïä§Î°úÌãÄÎßÅ (Í≥†ÎπàÎèÑ Ïù¥Î≤§Ìä∏ ÎπÑÏö© Ï†àÍ∞ê)
            let rafId = null;
            let lastPoint = null;
            const handleMove = () => {
                rafId = null;
                if (!lastPoint) return;

                if (!tooltipCache || !tooltipCache.allDates || tooltipCache.allDates.length === 0) {
                    hideTooltip();
                    return;
                }

                const fakeEvent = { clientX: lastPoint.x, clientY: lastPoint.y };
                const date = getDateFromMouseX(lastPoint.x, chartContainer.getBoundingClientRect());
                if (date) showTooltip(fakeEvent, date);
                else hideTooltip();
            };

            chartContainer.addEventListener('mousemove', (event) => {
                lastPoint = { x: event.clientX, y: event.clientY };
                if (rafId) return;
                rafId = requestAnimationFrame(handleMove);
            });
            
            // ÎßàÏö∞Ïä§Í∞Ä Ï∞®Ìä∏ ÏòÅÏó≠ÏùÑ Î≤óÏñ¥ÎÇ† Îïå
            chartContainer.addEventListener('mouseleave', () => {
                hideTooltip();
            });

            // Ïä§ÌÅ¨Î°§/Î¶¨ÏÇ¨Ïù¥Ï¶à Ïãú Ìà¥ÌåÅ Ïà®ÍπÄ(Î†àÏù¥ÏïÑÏõÉ Î≥ÄÎèôÏúºÎ°ú Ïù∏Ìïú ÏûîÏÉÅ/Ïò§ÌîÑÏÖã Î∞©ÏßÄ)
            window.addEventListener('scroll', hideTooltip, true);
            window.addEventListener('resize', hideTooltip);
            
            chartInteractivitySetup = true;
        }

        // 4. Currency Rates Table Logic
        function updateCurrencyRatesTable() {
            const grid = document.getElementById('currency-rates-grid');
            if (!grid) return;
            
            const currencies = ['USD', 'EUR', 'JPY', 'CNY', 'GBP', 'CHF', 'HKD', 'CAD', 'RUB'];
            
            grid.innerHTML = currencies.map(currency => {
                const currentRate = exchangeRates[currency];
                const previousRate = previousRates[currency];
                
                if (!currentRate) {
                    return `
                        <div class="currency-rate-item">
                            <div class="currency-rate-header">
                                <span class="currency-code">${currency}</span>
                            </div>
                            <div class="currency-value">-</div>
                            <div class="currency-change">
                                <span style="color: var(--text-sub);">Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå</span>
                            </div>
                        </div>
                    `;
                }
                
                // Ï†ÑÏùº ÎåÄÎπÑ Í≥ÑÏÇ∞ (Î¨¥Ï°∞Í±¥ Ï†ÑÏùºÍ≥º ÎπÑÍµê)
                let change = 0;
                let changePercent = 0;
                let isUp = false;
                
                if (previousRate && !isNaN(previousRate) && previousRate > 0) {
                    // Ï†ÑÏùº ÌôòÏú®Ïù¥ ÏûàÏúºÎ©¥ Î¨¥Ï°∞Í±¥ Ï†ÑÏùº ÎåÄÎπÑ Í≥ÑÏÇ∞
                    change = currentRate - previousRate;
                    changePercent = (change / previousRate) * 100;
                    isUp = change > 0;
                } else {
                    // Ï†ÑÏùº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Î≥ÄÌôîÎüâ 0ÏúºÎ°ú ÌëúÏãú
                    change = 0;
                    changePercent = 0;
                    isUp = false;
                }
                
                // Î≥ÄÌôîÎüâÏù¥ 0Ïù¥Î©¥ Ï§ëÎ¶Ω ÌëúÏãú, ÏïÑÎãàÎ©¥ ÏÉÅÏäπ/ÌïòÎùΩ ÌëúÏãú
                const changeClass = change === 0 ? '' : (isUp ? 'up' : 'down');
                const changeIcon = change === 0 ? '' : (isUp ? '‚ñ≤' : '‚ñº');
                const changeSign = change === 0 ? '' : (isUp ? '+' : '');
                
                // Î≥ÄÌôîÎüâ ÌëúÏãú ÌÖçÏä§Ìä∏
                let changeText = '';
                if (previousRate && !isNaN(previousRate) && previousRate > 0) {
                    // Ï†ÑÏùº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ Î≥ÄÌôîÎüâ ÌëúÏãú
                    changeText = `
                        <span class="currency-change-icon">${changeIcon}</span>
                        <span class="currency-change-value">
                            ${changeSign}${Math.abs(change).toFixed(2)}
                        </span>
                        <span class="currency-change-percent">
                            (${changeSign}${Math.abs(changePercent).toFixed(2)}%)
                        </span>
                    `;
                } else {
                    // Ï†ÑÏùº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ "-" ÌëúÏãú
                    changeText = '<span style="color: var(--text-sub);">-</span>';
                }
                
                return `
                    <div class="currency-rate-item">
                        <div class="currency-rate-header">
                            <span class="currency-code">${currency}</span>
                        </div>
                        <div class="currency-value">${currentRate.toLocaleString('ko-KR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                        <div class="currency-change ${changeClass}">
                            ${changeText}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 5. Calculator Logic
        const amountFrom = document.getElementById('amount-from');
        const amountTo = document.getElementById('amount-to');
        const currSelect = document.getElementById('curr-from');

        function updateCalculator() {
            // exchangeRatesÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÎ©¥ Í≥ÑÏÇ∞Í∏∞ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            if (amountFrom && amountTo && currSelect) {
                calculate();
            }
        }

        function calculate() {
            if (!amountFrom || !amountTo || !currSelect) return;
            
            const val = parseFloat(amountFrom.value) || 0;
            const curr = currSelect.value;
            
            // exchangeRatesÏóêÏÑú ÌôòÏú® Í∞ÄÏ†∏Ïò§Í∏∞
            const rate = exchangeRates[curr];
            
            if (rate && !isNaN(val)) {
                amountTo.value = (val * rate).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
            } else {
                amountTo.value = '-';
            }
        }

        if(amountFrom) {
            amountFrom.addEventListener('input', calculate);
            if (currSelect) {
                currSelect.addEventListener('change', calculate);
            }
        }

        // 5. Event Binding & Initialization
        document.addEventListener('DOMContentLoaded', () => {
            // ÎÇ†Ïßú ÏûÖÎ†• Ï¥àÍ∏∞Ìôî
            initDateInputs();
            
            // ÌòÑÏû¨ period ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî Î∞è Period Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ (Exchange Rate Ìå®ÎÑê ÎÇ¥Ïùò Î≤ÑÌäºÎßå)
            const economyPanel = document.getElementById('economy-panel');
            const activeBtn = economyPanel ? economyPanel.querySelector('.period-btn.active') : null;
            const initialKey = activeBtn ? activeBtn.textContent.trim() : null;
            currentRangeKey = (initialKey === '1W' || initialKey === '1M' || initialKey === '3M' || initialKey === '1Y') ? initialKey : null;
            
            // Period Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ (Exchange Rate Ìå®ÎÑê ÎÇ¥Ïùò Î≤ÑÌäºÎßå)
            if (economyPanel) {
                economyPanel.querySelectorAll('.period-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // Exchange Rate Ìå®ÎÑê ÎÇ¥Ïùò Î™®Îì† Î≤ÑÌäºÏóêÏÑú active Ï†úÍ±∞
                        economyPanel.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
                        // ÌÅ¥Î¶≠Ìïú Î≤ÑÌäºÏóê active Ï∂îÍ∞Ä
                        e.target.classList.add('active');
                        
                        // PeriodÏóê Îî∞Îùº ÎÇ†Ïßú ÏÑ§Ï†ï
                        const period = e.target.textContent.trim();
                        currentRangeKey = period;
                        handlePeriodClick(period);
                    });
                });
                
                // ÎÇ†Ïßú ÏûÖÎ†• Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏ (Exchange Rate Ìå®ÎÑê ÎÇ¥Ïùò ÏûÖÎ†• ÌïÑÎìúÎßå)
                economyPanel.querySelectorAll('.date-input').forEach(input => {
                    input.addEventListener('change', () => {
                        if (validateDateRange()) {
                            // Period Î≤ÑÌäº active ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî (ÏàòÎèô ÎÇ†Ïßú ÏÑ†ÌÉù)
                            economyPanel.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
                            currentRangeKey = null; // ÏûÖÎ†•Í∞í Í∏∞Î∞ò Ï∂îÎ°†ÏúºÎ°ú Ï†ÑÌôò
                            fetchExchangeRateData();
                        }
                    });
                });
            }
            
            // Ï¥àÍ∏∞ ÌÜµÌôî ÏÑ†ÌÉù ÏÉÅÌÉú ÌôïÏù∏ Î∞è ÏÑ§Ï†ï (USDÎßå ÏÑ†ÌÉù)
            document.querySelectorAll('.chip').forEach(chip => {
                const curr = chip.getAttribute('data-curr');
                if (curr === 'USD') {
                    chip.classList.add('active');
                    // activeCurrenciesÏóê USDÍ∞Ä ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
                    if (!activeCurrencies.includes('USD')) {
                        activeCurrencies.push('USD');
                    }
                } else {
                    chip.classList.remove('active');
                    // activeCurrenciesÏóêÏÑú Ï†úÍ±∞
                    activeCurrencies = activeCurrencies.filter(c => c !== curr);
                }
            });
            
            // activeCurrenciesÍ∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ USDÎ°ú Ï¥àÍ∏∞Ìôî
            if (activeCurrencies.length === 0) {
                activeCurrencies = ['USD'];
            }
            
            // Ï¥àÍ∏∞ Í≥ÑÏÇ∞Í∏∞ ÏÑ§Ï†ï (USD Í∏∞Ï§Ä)
            const currSelect = document.getElementById('curr-from');
            if (currSelect) {
                currSelect.value = 'USD';
            }
            
            // Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            if (validateDateRange()) {
                fetchExchangeRateData();
            }
            
            // Î™®Îì† ÌÜµÌôîÏùò ÌòÑÏû¨ ÌôòÏú® Í∞ÄÏ†∏Ïò§Í∏∞ (Ï£ºÏöî ÌÜµÌôîÎ≥Ñ ÌòÑÏû¨ ÌôòÏú® ÌÖåÏù¥Î∏îÏö©)
            fetchAllCurrencyRates();
            
            // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Î™®Îì† ÌÜµÌôî ÌôòÏú® ÏóÖÎç∞Ïù¥Ìä∏ (5Î∂ÑÎßàÎã§)
            setInterval(() => {
                fetchAllCurrencyRates();
            }, 5 * 60 * 1000); // 5Î∂Ñ = 300,000ms
            
            // Ï¥àÍ∏∞ ÌÖåÏù¥Î∏î Î†åÎçîÎßÅ
            updateCurrencyRatesTable();
            
            // ============================================================
            // Ìï®ÏàòÎì§ÏùÑ window Í∞ùÏ≤¥Ïóê ÎÖ∏Ï∂ú (ÌÖåÏä§Ìä∏ Î∞è Ïô∏Î∂Ä Ï†ëÍ∑ºÏö©)
            // DOMContentLoaded ÌõÑ Î∞îÏù∏Îî©ÌïòÏó¨ Î™®Îì† Ìï®ÏàòÍ∞Ä Ï†ïÏùòÎêú ÌõÑ Ïã§ÌñâÎê®
            // ============================================================
            try {
                window.switchTab = switchTab;
                window.switchProduct = switchProduct;
                window.toggleCurrency = toggleCurrency;
                window.updateChart = updateChart;
                window.initInterestRates = initInterestRates;
                window.initInflation = initInflation;
                window.initGDP = initGDP;
                window.initTrade = initTrade;
                window.initGlobalAlarmMap = initGlobalAlarmMap;
                // loadGoogleMapsAPIÎäî head scriptÏóêÏÑú Ïù¥ÎØ∏ Ï†ÑÏó≠ÏúºÎ°ú Ï†ïÏùòÎê®
                
                // ÎîîÎ≤ÑÍπÖ: Ìï®Ïàò Î∞îÏù∏Îî© ÌôïÏù∏
                console.log('‚úÖ Ìï®Ïàò Î∞îÏù∏Îî© ÏôÑÎ£å:', {
                    switchTab: typeof window.switchTab,
                    switchProduct: typeof window.switchProduct,
                    toggleCurrency: typeof window.toggleCurrency,
                    updateChart: typeof window.updateChart,
                    initInterestRates: typeof window.initInterestRates,
                    initInflation: typeof window.initInflation,
                    initGDP: typeof window.initGDP,
                    initTrade: typeof window.initTrade,
                    initGlobalAlarmMap: typeof window.initGlobalAlarmMap
                });
            } catch (error) {
                console.error('‚ùå Ìï®Ïàò Î∞îÏù∏Îî© Ïã§Ìå®:', error);
            }
        });

        // ============================================
        // Economy Growth Rate Functions
        // ============================================
        
        function initGDPGrowth() {
            const startDateInput = document.getElementById('gdp-growth-start-date');
            const endDateInput = document.getElementById('gdp-growth-end-date');
            
            if (startDateInput && endDateInput) {
                const end = new Date();
                const start = new Date();
                // Î∂ÑÍ∏∞Î≥Ñ Í∏∞Î≥∏Í∞í: ÌòÑÏû¨ Î∂ÑÍ∏∞Î•º Ìè¨Ìï®Ìï¥ÏÑú Í≥ºÍ±∞ 8Î∂ÑÍ∏∞
                start.setFullYear(end.getFullYear() - 2);
                start.setMonth(0); // 1Ïõî
                start.setDate(1);
                
                endDateInput.value = end.toISOString().split('T')[0];
                startDateInput.value = start.toISOString().split('T')[0];
                startDateInput.max = endDateInput.value;
                endDateInput.max = endDateInput.value;
                
                startDateInput.addEventListener('change', () => {
                    if (validateGDPGrowthDateRange()) {
                        fetchGDPGrowthData();
                    }
                });
                
                endDateInput.addEventListener('change', () => {
                    if (validateGDPGrowthDateRange()) {
                        fetchGDPGrowthData();
                    }
                });
            }
            
            // Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎìú
            fetchGDPGrowthCountryList().then(() => {
                initGDPGrowthCountryChips();
            }).catch(err => {
                console.error('Failed to load GDP growth country list:', err);
            });
            
            // Initial data fetch
            fetchGDPGrowthData();
            window.gdpGrowthDataLoaded = true;
        }
        
        async function fetchGDPGrowthCountryList() {
            try {
                const url = `${API_BASE}/market/categories?category=gdp-growth-international`;
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.items && Object.keys(data.items).length > 0) {
                        gdpGrowthCountryMapping = data.items;
                        gdpGrowthCountryListLoaded = true;
                        return gdpGrowthCountryMapping;
                    }
                }
                
                throw new Error('Failed to fetch country list from categories endpoint');
                
            } catch (err) {
                console.error('Failed to fetch GDP growth country list:', err);
                throw err;
            }
        }
        
        function initGDPGrowthCountryChips() {
            const chipsContainer = document.getElementById('gdp-growth-country-chips');
            if (!chipsContainer) return;
            
            chipsContainer.innerHTML = '';
            
            const itemCodes = Object.keys(gdpGrowthCountryMapping);
            if (itemCodes.length === 0) {
                chipsContainer.innerHTML = '<span style="color: var(--text-sub); font-size: 0.8rem;">Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎî© Ï§ë...</span>';
                return;
            }
            
            itemCodes.forEach(itemCode => {
                const countryInfo = gdpGrowthCountryMapping[itemCode];
                const chip = document.createElement('button');
                chip.className = 'chip';
                chip.setAttribute('data-item-code', itemCode);
                chip.setAttribute('title', countryInfo.name);
                
                const isActive = activeGDPGrowthCountries.includes(itemCode);
                if (isActive) {
                    chip.classList.add('active');
                }
                
                chip.appendChild(document.createTextNode(countryInfo.name));
                chip.addEventListener('click', () => toggleGDPGrowthCountry(itemCode));
                
                chipsContainer.appendChild(chip);
            });
        }
        
        function toggleGDPGrowthCountry(itemCode) {
            const index = activeGDPGrowthCountries.indexOf(itemCode);
            if (index > -1) {
                activeGDPGrowthCountries.splice(index, 1);
            } else {
                activeGDPGrowthCountries.push(itemCode);
            }
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            const chip = document.querySelector(`#gdp-growth-country-chips [data-item-code="${itemCode}"]`);
            if (chip) {
                if (activeGDPGrowthCountries.includes(itemCode)) {
                    chip.classList.add('active');
                } else {
                    chip.classList.remove('active');
                }
            }
            
            // Îç∞Ïù¥ÌÑ∞ Ïû¨Ï°∞Ìöå
            if (validateGDPGrowthDateRange()) {
                fetchGDPGrowthData();
            } else {
                updateGDPGrowthChart();
            }
        }
        
        function validateGDPGrowthDateRange() {
            const startDateInput = document.getElementById('gdp-growth-start-date');
            const endDateInput = document.getElementById('gdp-growth-end-date');
            
            if (!startDateInput || !endDateInput) return false;
            
            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);
            
            if (startDate > endDate) {
                alert('ÏãúÏûëÏùºÏùÄ Ï¢ÖÎ£åÏùºÎ≥¥Îã§ ÏïûÏÑúÏïº Ìï©ÎãàÎã§.');
                return false;
            }
            
            return true;
        }
        
        async function fetchGDPGrowthData() {
            if (!validateGDPGrowthDateRange()) return;
            
            const startDateInput = document.getElementById('gdp-growth-start-date');
            const endDateInput = document.getElementById('gdp-growth-end-date');
            
            if (!startDateInput || !endDateInput) return;
            
            const startDate = formatDateForAPI(startDateInput.value);
            const endDate = formatDateForAPI(endDateInput.value);
            
            const chartContainer = document.getElementById('gdp-growth-chart-container');
            if (chartContainer) {
                chartContainer.style.opacity = '0.5';
            }
            
            try {
                gdpGrowthCountryData = {};
                
                if (activeGDPGrowthCountries.length === 0) {
                    updateGDPGrowthChart();
                    if (chartContainer) {
                        chartContainer.style.opacity = '1';
                    }
                    return;
                }
                
                // Í∞Å Íµ≠Í∞ÄÎ≥ÑÎ°ú API Ìò∏Ï∂ú
                const fetchPromises = activeGDPGrowthCountries.map(async (itemCode) => {
                    const url = `${API_BASE}/market/indices?type=gdp-growth-international&itemCode=${itemCode}&startDate=${startDate}&endDate=${endDate}&cycle=${gdpGrowthCycle}`;
                    
                    try {
                        const response = await fetch(url);
                        const json = await response.json();
                        return { itemCode, data: json };
                    } catch (err) {
                        console.error(`Failed to fetch ${itemCode}:`, err);
                        return { itemCode, data: { error: err.message } };
                    }
                });
                
                const results = await Promise.all(fetchPromises);
                
                results.forEach(({ itemCode, data }) => {
                    if (!data.error && data.StatisticSearch?.row) {
                        gdpGrowthCountryData[itemCode] = data.StatisticSearch.row.map(row => ({
                            date: row.TIME,
                            value: parseFloat(row.DATA_VALUE)
                        })).filter(item => !isNaN(item.value));
                    } else {
                        gdpGrowthCountryData[itemCode] = [];
                    }
                });
                
                // Îç∞Ïù¥ÌÑ∞ Ï†ïÎ†¨ Î∞è Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
                Object.keys(gdpGrowthCountryData).forEach(itemCode => {
                    gdpGrowthCountryData[itemCode].sort((a, b) => {
                        // YYYYQn ÌòïÏãù Ï†ïÎ†¨
                        const aMatch = a.date.match(/^(\d{4})Q([1-4])$/);
                        const bMatch = b.date.match(/^(\d{4})Q([1-4])$/);
                        if (aMatch && bMatch) {
                            const aYear = parseInt(aMatch[1]);
                            const aQ = parseInt(aMatch[2]);
                            const bYear = parseInt(bMatch[1]);
                            const bQ = parseInt(bMatch[2]);
                            if (aYear !== bYear) return aYear - bYear;
                            return aQ - bQ;
                        }
                        return a.date.localeCompare(b.date);
                    });
                });
                
                updateGDPGrowthChart();
                updateGDPGrowthChartHeader();
                
            } catch (err) {
                console.error('Failed to fetch GDP growth data:', err);
            } finally {
                if (chartContainer) {
                    chartContainer.style.opacity = '1';
                }
            }
        }
        
        function updateGDPGrowthChart() {
            const svg = document.getElementById('gdp-growth-chart-svg');
            const pathsGroup = document.getElementById('gdp-growth-paths-group');
            const pointsGroup = document.getElementById('gdp-growth-data-points');
            
            if (!svg || !pathsGroup || !pointsGroup) return;
            
            pathsGroup.innerHTML = '';
            pointsGroup.innerHTML = '';
            
            if (activeGDPGrowthCountries.length === 0) {
                renderGDPGrowthYAxisLabels();
                renderGDPGrowthXAxisLabels();
                return;
            }
            
            // Î™®Îì† Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ Î≥ëÌï©ÌïòÏó¨ Í≥µÌÜµ ÎÇ†Ïßú Î™©Î°ù ÏÉùÏÑ±
            const allDates = new Set();
            Object.values(gdpGrowthCountryData).forEach(data => {
                data.forEach(item => allDates.add(item.date));
            });
            const sortedDates = Array.from(allDates).sort((a, b) => {
                const aMatch = a.match(/^(\d{4})Q([1-4])$/);
                const bMatch = b.match(/^(\d{4})Q([1-4])$/);
                if (aMatch && bMatch) {
                    const aYear = parseInt(aMatch[1]);
                    const aQ = parseInt(aMatch[2]);
                    const bYear = parseInt(bMatch[1]);
                    const bQ = parseInt(bMatch[2]);
                    if (aYear !== bYear) return aYear - bYear;
                    return aQ - bQ;
                }
                return a.localeCompare(b);
            });
            
            if (sortedDates.length === 0) {
                renderGDPGrowthYAxisLabels();
                renderGDPGrowthXAxisLabels();
                return;
            }
            
            // YÏ∂ï Î≤îÏúÑ Í≥ÑÏÇ∞
            const allValues = [];
            Object.values(gdpGrowthCountryData).forEach(data => {
                data.forEach(item => {
                    if (!isNaN(item.value)) {
                        allValues.push(item.value);
                    }
                });
            });
            
            if (allValues.length > 0) {
                const minValue = Math.min(...allValues);
                const maxValue = Math.max(...allValues);
                const range = maxValue - minValue || 1;
                const paddingPercent = 0.1;
                gdpGrowthYAxisRange = {
                    min: minValue - range * paddingPercent,
                    max: maxValue + range * paddingPercent
                };
            }
            
            // YÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ
            renderGDPGrowthYAxisLabels();
            
            // Í∞Å Íµ≠Í∞ÄÎ≥Ñ Í≤ΩÎ°ú Î†åÎçîÎßÅ
            activeGDPGrowthCountries.forEach(itemCode => {
                const countryData = gdpGrowthCountryData[itemCode] || [];
                if (countryData.length === 0) return;
                
                // Îç∞Ïù¥ÌÑ∞Î•º Í≥µÌÜµ ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨
                const sortedData = sortedDates.map(date => {
                    const found = countryData.find(item => item.date === date);
                    return found || { date, value: null };
                }).filter(item => item.value !== null);
                
                if (sortedData.length > 0) {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.classList.add('chart-path');
                    path.setAttribute('stroke', getGDPGrowthCountryColor(itemCode));
                    path.setAttribute('stroke-width', '2.5');
                    path.setAttribute('fill', 'none');
                    
                    const pathData = generateGDPGrowthSVGPath(sortedData);
                    path.setAttribute('d', pathData);
                    path.classList.add('visible');
                    
                    pathsGroup.appendChild(path);
                }
            });
            
            // Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ Î†åÎçîÎßÅ
            renderGDPGrowthDataPoints(sortedDates);
            
            // XÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ
            renderGDPGrowthXAxisLabels(sortedDates);
            
            // Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Í∏∞Îä• ÏÑ§Ï†ï
            setupGDPGrowthChartInteractivity();
        }
        
        function generateGDPGrowthSVGPath(data) {
            if (!data || data.length === 0) return '';
            
            const svg = document.getElementById('gdp-growth-chart-svg');
            if (!svg) return '';
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = gdpGrowthYAxisRange.min;
            const maxValue = gdpGrowthYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            let pathData = '';
            data.forEach((point, index) => {
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            return pathData;
        }
        
        function renderGDPGrowthYAxisLabels() {
            const yAxisGroup = document.getElementById('gdp-growth-y-axis-labels');
            if (!yAxisGroup) return;
            
            yAxisGroup.innerHTML = '';
            
            const minValue = gdpGrowthYAxisRange.min;
            const maxValue = gdpGrowthYAxisRange.max;
            const steps = 5;
            
            for (let i = 0; i <= steps; i++) {
                const value = maxValue - (i / steps) * (maxValue - minValue);
                const y = 20 + (i / steps) * 330;
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', '30');
                label.setAttribute('y', y);
                label.setAttribute('class', 'chart-yaxis-label');
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('dominant-baseline', 'middle');
                label.textContent = value.toFixed(2) + '%';
                
                yAxisGroup.appendChild(label);
            }
        }
        
        function renderGDPGrowthXAxisLabels(sortedDates) {
            const xAxisGroup = document.getElementById('gdp-growth-x-axis-labels');
            if (!xAxisGroup || !sortedDates || sortedDates.length === 0) return;
            
            xAxisGroup.innerHTML = '';
            
            const svg = document.getElementById('gdp-growth-chart-svg');
            if (!svg) return;
            
            const { width } = getSvgViewBoxSize(svg);
            const padding = { left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            
            const labelInterval = Math.max(1, Math.floor(sortedDates.length / 8));
            
            sortedDates.forEach((date, index) => {
                if (index % labelInterval !== 0 && index !== sortedDates.length - 1) return;
                
                const x = padding.left + (index / (sortedDates.length - 1 || 1)) * chartWidth;
                const y = 370;
                
                let labelText = '';
                const match = date.match(/^(\d{4})Q([1-4])$/);
                if (match) {
                    const year = match[1];
                    const quarter = match[2];
                    labelText = `${year.substring(2)}Q${quarter}`;
                } else {
                    labelText = date;
                }
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', y);
                label.setAttribute('class', 'chart-xaxis-label');
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('dominant-baseline', 'middle');
                label.textContent = labelText;
                
                xAxisGroup.appendChild(label);
            });
        }
        
        function renderGDPGrowthDataPoints(sortedDates) {
            const pointsGroup = document.getElementById('gdp-growth-data-points');
            if (!pointsGroup) return;
            
            const svg = document.getElementById('gdp-growth-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = gdpGrowthYAxisRange.min;
            const maxValue = gdpGrowthYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            activeGDPGrowthCountries.forEach(itemCode => {
                const countryData = gdpGrowthCountryData[itemCode] || [];
                const countryColor = getGDPGrowthCountryColor(itemCode);
                
                const sortedData = sortedDates.map(date => {
                    const found = countryData.find(item => item.date === date);
                    return found || { date, value: null };
                }).filter(item => item.value !== null);
                
                sortedData.forEach((point, index) => {
                    const x = padding.left + (index / (sortedData.length - 1 || 1)) * chartWidth;
                    const normalizedValue = (point.value - minValue) / valueRange;
                    const y = padding.top + (1 - normalizedValue) * chartHeight;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', '4');
                    circle.setAttribute('fill', countryColor);
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '1.5');
                    circle.setAttribute('data-date', point.date);
                    circle.setAttribute('data-value', point.value);
                    circle.setAttribute('data-country', itemCode);
                    circle.classList.add('data-point');
                    pointsGroup.appendChild(circle);
                });
            });
        }
        
        function getGDPGrowthCountryColor(itemCode) {
            // Í∞ÑÎã®Ìïú ÏÉâÏÉÅ Îß§Ìïë (ÌïÑÏöîÏãú ÌôïÏû•)
            const colors = [
                'var(--c-interest-kor)', 'var(--c-interest-usa)', 'var(--c-interest-jpn)',
                'var(--c-interest-chn)', 'var(--c-interest-gbr)', 'var(--c-interest-deu)',
                'var(--c-interest-fra)', 'var(--c-interest-ita)', 'var(--c-interest-can)',
                'var(--c-interest-aus)', 'var(--c-interest-bra)', 'var(--c-interest-ind)'
            ];
            const index = Object.keys(gdpGrowthCountryMapping).indexOf(itemCode);
            return colors[index % colors.length] || 'var(--accent-color)';
        }
        
        function updateGDPGrowthChartHeader() {
            if (activeGDPGrowthCountries.length === 0) {
                const titleEl = document.getElementById('gdp-growth-chart-main-title');
                const valueEl = document.getElementById('gdp-growth-chart-main-value');
                if (titleEl) titleEl.textContent = 'Economy Growth Rate';
                if (valueEl) valueEl.textContent = '-';
                return;
            }
            
            // Ï≤´ Î≤àÏß∏ Íµ≠Í∞ÄÏùò Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            const firstCountry = activeGDPGrowthCountries[0];
            const firstCountryData = gdpGrowthCountryData[firstCountry] || [];
            
            if (firstCountryData.length === 0) {
                const titleEl = document.getElementById('gdp-growth-chart-main-title');
                const valueEl = document.getElementById('gdp-growth-chart-main-value');
                const countryInfo = gdpGrowthCountryMapping[firstCountry];
                const countryName = countryInfo ? countryInfo.name : firstCountry;
                if (titleEl) titleEl.textContent = `${countryName} Economy Growth Rate`;
                if (valueEl) valueEl.textContent = '-';
                return;
            }
            
            const values = firstCountryData.map(item => item.value).filter(v => !isNaN(v));
            if (values.length === 0) return;
            
            const current = values[values.length - 1];
            const high = Math.max(...values);
            const low = Math.min(...values);
            const average = values.reduce((sum, v) => sum + v, 0) / values.length;
            
            const countryInfo = gdpGrowthCountryMapping[firstCountry];
            const countryName = countryInfo ? countryInfo.name : firstCountry;
            
            const titleEl = document.getElementById('gdp-growth-chart-main-title');
            const valueEl = document.getElementById('gdp-growth-chart-main-value');
            const highEl = document.getElementById('gdp-growth-stat-high');
            const lowEl = document.getElementById('gdp-growth-stat-low');
            const avgEl = document.getElementById('gdp-growth-stat-average');
            
            if (titleEl) titleEl.textContent = `${countryName} Economy Growth Rate`;
            if (valueEl) valueEl.textContent = current.toFixed(2) + '%';
            if (highEl) highEl.textContent = high.toFixed(2) + '%';
            if (lowEl) lowEl.textContent = low.toFixed(2) + '%';
            if (avgEl) avgEl.textContent = average.toFixed(2) + '%';
        }
        
        let gdpGrowthMouseMoveHandler = null;
        let gdpGrowthMouseLeaveHandler = null;
        
        function setupGDPGrowthChartInteractivity() {
            const chartContainer = document.getElementById('gdp-growth-chart-container');
            const svg = document.getElementById('gdp-growth-chart-svg');
            
            if (!chartContainer || !svg) return;
            
            const tooltip = document.getElementById('gdp-growth-chart-tooltip');
            if (tooltip && tooltip.parentElement !== document.body) {
                document.body.appendChild(tooltip);
            }
            
            if (gdpGrowthMouseMoveHandler) {
                chartContainer.removeEventListener('mousemove', gdpGrowthMouseMoveHandler);
            }
            if (gdpGrowthMouseLeaveHandler) {
                chartContainer.removeEventListener('mouseleave', gdpGrowthMouseLeaveHandler);
            }
            
            let rafId = null;
            
            gdpGrowthMouseMoveHandler = (e) => {
                if (rafId) return;
                rafId = requestAnimationFrame(() => {
                    rafId = null;
                    
                    const allDates = new Set();
                    Object.values(gdpGrowthCountryData).forEach(data => {
                        data.forEach(item => allDates.add(item.date));
                    });
                    const sortedDates = Array.from(allDates).sort((a, b) => {
                        const aMatch = a.match(/^(\d{4})Q([1-4])$/);
                        const bMatch = b.match(/^(\d{4})Q([1-4])$/);
                        if (aMatch && bMatch) {
                            const aYear = parseInt(aMatch[1]);
                            const aQ = parseInt(aMatch[2]);
                            const bYear = parseInt(bMatch[1]);
                            const bQ = parseInt(bMatch[2]);
                            if (aYear !== bYear) return aYear - bYear;
                            return aQ - bQ;
                        }
                        return a.localeCompare(b);
                    });
                    
                    if (sortedDates.length === 0) {
                        hideGDPGrowthTooltip();
                        return;
                    }
                    
                    const rect = chartContainer.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const svgX = (x / rect.width) * 1200;
                    
                    const padding = { left: 40, right: 20 };
                    const chartWidth = 1200 - padding.left - padding.right;
                    const dataIndex = Math.round(((svgX - padding.left) / chartWidth) * (sortedDates.length - 1));
                    
                    if (dataIndex >= 0 && dataIndex < sortedDates.length) {
                        const date = sortedDates[dataIndex];
                        showGDPGrowthTooltip(e, date);
                    } else {
                        hideGDPGrowthTooltip();
                    }
                });
            };
            
            gdpGrowthMouseLeaveHandler = () => {
                hideGDPGrowthTooltip();
            };
            
            chartContainer.addEventListener('mousemove', gdpGrowthMouseMoveHandler);
            chartContainer.addEventListener('mouseleave', gdpGrowthMouseLeaveHandler);
        }
        
        function showGDPGrowthTooltip(event, date) {
            const tooltip = document.getElementById('gdp-growth-chart-tooltip');
            const tooltipDate = document.getElementById('gdp-growth-tooltip-date');
            const tooltipContent = document.getElementById('gdp-growth-tooltip-content');
            
            if (!tooltip || !tooltipDate || !tooltipContent) return;
            
            const match = date.match(/^(\d{4})Q([1-4])$/);
            let formattedDate = date;
            if (match) {
                const year = match[1];
                const quarter = match[2];
                formattedDate = `Q${quarter}-${year}`;
            }
            
            tooltipDate.textContent = formattedDate;
            
            let contentHtml = '';
            activeGDPGrowthCountries.forEach(itemCode => {
                const countryData = gdpGrowthCountryData[itemCode];
                if (!countryData) return;
                
                const item = countryData.find(d => d.date === date);
                if (item) {
                    const countryInfo = gdpGrowthCountryMapping[itemCode];
                    const countryName = countryInfo ? countryInfo.name : itemCode;
                    const countryColor = getGDPGrowthCountryColor(itemCode);
                    
                    const tempEl = document.createElement('div');
                    tempEl.style.color = countryColor;
                    document.body.appendChild(tempEl);
                    const computedColor = window.getComputedStyle(tempEl).color;
                    document.body.removeChild(tempEl);
                    
                    contentHtml += `
                        <div class="chart-tooltip-item">
                            <div class="chart-tooltip-currency">
                                <div class="chart-tooltip-dot" style="background: ${computedColor};"></div>
                                <span>${countryName}</span>
                            </div>
                            <span class="chart-tooltip-value">${item.value.toFixed(2)}%</span>
                        </div>
                    `;
                }
            });
            
            tooltipContent.innerHTML = contentHtml;
            
            // Position tooltip
            const rect = tooltip.getBoundingClientRect();
            const tooltipWidth = rect.width;
            const tooltipHeight = rect.height;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            let left = event.clientX + 10;
            let top = event.clientY + 10;
            
            if (left + tooltipWidth > viewportWidth) {
                left = event.clientX - tooltipWidth - 10;
            }
            if (top + tooltipHeight > viewportHeight) {
                top = event.clientY - tooltipHeight - 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideGDPGrowthTooltip() {
            const tooltip = document.getElementById('gdp-growth-chart-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        // ============================================
        // Trade Statistics Functions
        // ============================================

        function initTrade() {
            const startDateInput = document.getElementById('trade-start-date');
            const endDateInput = document.getElementById('trade-end-date');
            
            if (startDateInput && endDateInput) {
                const end = new Date();
                const start = new Date();
                // ÏõîÎ≥Ñ Í∏∞Î≥∏Í∞í: ÌòÑÏû¨ ÏõîÏùÑ Ìè¨Ìï®Ìï¥ÏÑú Í≥ºÍ±∞ 12Í∞úÏõî
                start.setMonth(end.getMonth() - 11);
                start.setDate(1);
                
                startDateInput.value = start.toISOString().split('T')[0];
                endDateInput.value = end.toISOString().split('T')[0];
                startDateInput.max = endDateInput.value;
                endDateInput.max = endDateInput.value;
                
                // ÏãúÏûëÏùº Î≥ÄÍ≤Ω Ïãú Ï¢ÖÎ£åÏùº ÏµúÎåÄÍ∞í ÏóÖÎç∞Ïù¥Ìä∏ (ÏµúÎåÄ 2ÎÖÑ Ï†úÌïú)
                startDateInput.addEventListener('change', () => {
                    const startDate = new Date(startDateInput.value);
                    const maxEndDate = new Date(startDate);
                    maxEndDate.setFullYear(maxEndDate.getFullYear() + 2); // 2ÎÖÑ ÌõÑ
                    const today = new Date();
                    const finalMaxDate = maxEndDate > today ? today : maxEndDate;
                    endDateInput.max = finalMaxDate.toISOString().split('T')[0];
                    
                    // Ï¢ÖÎ£åÏùºÏù¥ ÏµúÎåÄÍ∞íÏùÑ Ï¥àÍ≥ºÌïòÎ©¥ Ï°∞Ï†ï
                    const endDate = new Date(endDateInput.value);
                    if (endDate > finalMaxDate) {
                        endDateInput.value = finalMaxDate.toISOString().split('T')[0];
                    }
                    
                    if (validateTradeDateRange()) {
                        fetchTradeData();
                    }
                });
                
                endDateInput.addEventListener('change', () => {
                    // Ï¢ÖÎ£åÏùº Î≥ÄÍ≤Ω Ïãú ÏãúÏûëÏùº ÏµúÏÜåÍ∞í ÏóÖÎç∞Ïù¥Ìä∏ (ÏµúÎåÄ 2ÎÖÑ Ï†úÌïú)
                    const endDate = new Date(endDateInput.value);
                    const minStartDate = new Date(endDate);
                    minStartDate.setFullYear(minStartDate.getFullYear() - 2); // 2ÎÖÑ Ï†Ñ
                    startDateInput.min = minStartDate.toISOString().split('T')[0];
                    
                    // ÏãúÏûëÏùºÏù¥ ÏµúÏÜåÍ∞í ÎØ∏ÎßåÏù¥Î©¥ Ï°∞Ï†ï
                    const startDate = new Date(startDateInput.value);
                    if (startDate < minStartDate) {
                        startDateInput.value = minStartDate.toISOString().split('T')[0];
                    }
                    
                    if (validateTradeDateRange()) {
                        fetchTradeData();
                    }
                });
            }
            
            // Cycle buttons event listeners
            document.querySelectorAll('.trade-cycle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.trade-cycle-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    tradeCycle = this.getAttribute('data-cycle');
                    
                    const end = new Date();
                    const start = new Date();
                    
                    if (tradeCycle === 'M') {
                        start.setMonth(end.getMonth() - 11);
                        start.setDate(1);
                    } else if (tradeCycle === 'Q') {
                        start.setFullYear(end.getFullYear() - 2);
                    }
                    
                    const startDateInput = document.getElementById('trade-start-date');
                    const endDateInput = document.getElementById('trade-end-date');
                    
                    if (startDateInput && endDateInput) {
                        startDateInput.value = start.toISOString().split('T')[0];
                        endDateInput.value = end.toISOString().split('T')[0];
                    }
                    
                    fetchTradeData();
                });
            });
            
            // Initialize indicators: ÏàòÏ∂ú/ÏàòÏûÖ Î™®Îëê ÌôúÏÑ±Ìôî
            activeTradeIndicators = ['EXPORT', 'IMPORT'];
            const exportChip = document.getElementById('chip-trade-export');
            const importChip = document.getElementById('chip-trade-import');
            if (exportChip) exportChip.classList.add('active');
            if (importChip) importChip.classList.add('active');
            
            // Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎìú
            fetchTradeCountryList().then(() => {
                initTradeCountryChips();
            }).catch(err => {
                console.error('Failed to load trade country list:', err);
            });
            
            // Initial data fetch
            fetchTradeData();
            window.tradeDataLoaded = true;
        }
        
        // International Trade Functions
        async function fetchTradeCountryList() {
            try {
                // ÏàòÏ∂ú Ïπ¥ÌÖåÍ≥†Î¶¨ÏóêÏÑú Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                const url = `${API_BASE}/market/categories?category=export-international`;
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.items && Object.keys(data.items).length > 0) {
                        tradeCountryMapping = data.items;
                        return tradeCountryMapping;
                    }
                }
                
                throw new Error('Failed to fetch country list from categories endpoint');
                
            } catch (err) {
                console.error('Failed to fetch trade country list:', err);
                throw err;
            }
        }
        
        function initTradeCountryChips() {
            const chipsContainer = document.getElementById('trade-country-chips');
            if (!chipsContainer) return;
            
            chipsContainer.innerHTML = '';
            
            const itemCodes = Object.keys(tradeCountryMapping);
            if (itemCodes.length === 0) {
                chipsContainer.innerHTML = '<span style="color: var(--text-sub); font-size: 0.8rem;">Íµ≠Í∞Ä Î¶¨Ïä§Ìä∏ Î°úÎî© Ï§ë...</span>';
                return;
            }
            
            itemCodes.forEach(itemCode => {
                const countryInfo = tradeCountryMapping[itemCode];
                const chip = document.createElement('button');
                chip.className = 'chip';
                chip.setAttribute('data-item-code', itemCode);
                chip.setAttribute('title', countryInfo.name);
                
                const isActive = activeTradeCountry === itemCode;
                if (isActive) {
                    chip.classList.add('active');
                }
                
                chip.appendChild(document.createTextNode(countryInfo.name));
                chip.addEventListener('click', () => toggleTradeCountry(itemCode));
                
                chipsContainer.appendChild(chip);
            });
        }
        
        function toggleTradeCountry(itemCode) {
            // Îã®Ïùº ÏÑ†ÌÉù: Ïù¥Ï†Ñ ÏÑ†ÌÉù Ìï¥Ï†ú ÌõÑ ÏÉàÎ°ú ÏÑ†ÌÉù
            if (activeTradeCountry === itemCode) {
                // Í∞ôÏùÄ Íµ≠Í∞ÄÎ•º Îã§Ïãú ÌÅ¥Î¶≠ÌïòÎ©¥ Ìï¥Ï†ú
                activeTradeCountry = null;
                tradeCountryData = { EXPORT: [], IMPORT: [], BALANCE: [] };
            } else {
                activeTradeCountry = itemCode;
            }
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            document.querySelectorAll('#trade-country-chips .chip').forEach(chip => {
                const chipItemCode = chip.getAttribute('data-item-code');
                if (chipItemCode === itemCode) {
                    if (activeTradeCountry === itemCode) {
                        chip.classList.add('active');
                    } else {
                        chip.classList.remove('active');
                    }
                } else {
                    chip.classList.remove('active');
                }
            });
            
            // Îç∞Ïù¥ÌÑ∞ Ïû¨Ï°∞Ìöå
            if (validateTradeDateRange()) {
                fetchTradeData();
            } else {
                updateTradeChart();
            }
        }

        function validateTradeDateRange() {
            const startDateInput = document.getElementById('trade-start-date');
            const endDateInput = document.getElementById('trade-end-date');
            
            if (!startDateInput || !endDateInput) return false;
            
            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);
            
            if (startDate > endDate) {
                alert('ÏãúÏûëÏùºÏùÄ Ï¢ÖÎ£åÏùºÎ≥¥Îã§ ÏïûÏÑúÏïº Ìï©ÎãàÎã§.');
                return false;
            }
            
            return true;
        }

        async function fetchTradeData() {
            if (!validateTradeDateRange()) return;
            
            const startDateInput = document.getElementById('trade-start-date');
            const endDateInput = document.getElementById('trade-end-date');
            
            if (!startDateInput || !endDateInput) return;
            
            const startDate = formatDateForAPI(startDateInput.value);
            const endDate = formatDateForAPI(endDateInput.value);
            
            const chartContainer = document.getElementById('trade-chart-container');
            if (chartContainer) {
                chartContainer.style.opacity = '0.5';
            }
            
            try {
                tradeData = { EXPORT: [], IMPORT: [] };
                tradeDataKRW = { EXPORT: [], IMPORT: [] };
                
                // Fetch export and import data
                // NOTE: ECOS ÌÜµÍ≥ÑÌëú 301Y013ÏùÄ Î∞±ÎßåÎã¨Îü¨ Îã®ÏúÑÎßå Ï†úÍ≥µ (USDÎßå ÏßÄÏõê)
                const exportItemCode = 'EXPORT_USD';
                const importItemCode = 'IMPORT_USD';
                
                const exportUrl = `${API_BASE}/market/indices?type=trade&itemCode=${exportItemCode}&startDate=${startDate}&endDate=${endDate}&cycle=${tradeCycle}`;
                const importUrl = `${API_BASE}/market/indices?type=trade&itemCode=${importItemCode}&startDate=${startDate}&endDate=${endDate}&cycle=${tradeCycle}`;
                
                // ÌôòÏú® Îç∞Ïù¥ÌÑ∞ÎèÑ Ìï®Íªò Í∞ÄÏ†∏Ïò§Í∏∞ (KRW Î≥ÄÌôòÏö©)
                await fetchTradeExchangeRates(startDate, endDate);
                
                const [exportResponse, importResponse] = await Promise.all([
                    fetch(exportUrl),
                    fetch(importUrl)
                ]);
                
                if (exportResponse.ok) {
                    const exportData = await exportResponse.json();
                    if (!exportData.error && exportData.StatisticSearch?.row) {
                        tradeData.EXPORT = exportData.StatisticSearch.row.map(row => ({
                            date: row.TIME,
                            value: parseFloat(row.DATA_VALUE)
                        })).filter(item => !isNaN(item.value) && item.value > 0);
                        
                        // KRW Î≥ÄÌôòÍ∞í Í≥ÑÏÇ∞
                        tradeDataKRW.EXPORT = tradeData.EXPORT.map(item => {
                            const rate = getExchangeRateForDate(item.date);
                            if (rate) {
                                // Î∞±Îßå USD ‚Üí ÏñµÏõê Î≥ÄÌôò
                                // 1. Î∞±Îßå USD √ó 1,000,000 = USD
                                // 2. USD √ó ÌôòÏú® = ÏõêÌôî
                                // 3. ÏõêÌôî √∑ 100,000,000 = ÏñµÏõê
                                const krwValue = (item.value * 1000000 * rate) / 100000000;
                                return { ...item, value: krwValue };
                            }
                            return null;
                        }).filter(item => item !== null);
                    }
                }
                
                if (importResponse.ok) {
                    const importData = await importResponse.json();
                    if (!importData.error && importData.StatisticSearch?.row) {
                        tradeData.IMPORT = importData.StatisticSearch.row.map(row => ({
                            date: row.TIME,
                            value: parseFloat(row.DATA_VALUE)
                        })).filter(item => !isNaN(item.value) && item.value > 0);
                        
                        // KRW Î≥ÄÌôòÍ∞í Í≥ÑÏÇ∞
                        tradeDataKRW.IMPORT = tradeData.IMPORT.map(item => {
                            const rate = getExchangeRateForDate(item.date);
                            if (rate) {
                                // Î∞±Îßå USD ‚Üí ÏñµÏõê Î≥ÄÌôò
                                const krwValue = (item.value * 1000000 * rate) / 100000000;
                                return { ...item, value: krwValue };
                            }
                            return null;
                        }).filter(item => item !== null);
                    }
                }
                
                // Sort data by date
                tradeData.EXPORT.sort((a, b) => a.date.localeCompare(b.date));
                tradeData.IMPORT.sort((a, b) => a.date.localeCompare(b.date));
                tradeDataKRW.EXPORT.sort((a, b) => a.date.localeCompare(b.date));
                tradeDataKRW.IMPORT.sort((a, b) => a.date.localeCompare(b.date));
                
                // Î¨¥Ïó≠ÏàòÏßÄ Í≥ÑÏÇ∞
                calculateTradeBalance();
                
                // ÏÑ†ÌÉùÎêú Íµ≠Í∞ÄÏùò Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
                if (activeTradeCountry) {
                    try {
                        const countryExportUrl = `${API_BASE}/market/indices?type=export-international&itemCode=${activeTradeCountry}&startDate=${startDate}&endDate=${endDate}&cycle=${tradeCycle}`;
                        const countryImportUrl = `${API_BASE}/market/indices?type=import-international&itemCode=${activeTradeCountry}&startDate=${startDate}&endDate=${endDate}&cycle=${tradeCycle}`;
                        
                        const [countryExportResponse, countryImportResponse] = await Promise.all([
                            fetch(countryExportUrl),
                            fetch(countryImportUrl)
                        ]);
                        
                        tradeCountryData = { EXPORT: [], IMPORT: [], BALANCE: [] };
                        
                        if (countryExportResponse.ok) {
                            const countryExportData = await countryExportResponse.json();
                            if (!countryExportData.error && countryExportData.StatisticSearch?.row) {
                                tradeCountryData.EXPORT = countryExportData.StatisticSearch.row.map(row => ({
                                    date: row.TIME,
                                    value: parseFloat(row.DATA_VALUE)
                                })).filter(item => !isNaN(item.value) && item.value > 0);
                            }
                        }
                        
                        if (countryImportResponse.ok) {
                            const countryImportData = await countryImportResponse.json();
                            if (!countryImportData.error && countryImportData.StatisticSearch?.row) {
                                tradeCountryData.IMPORT = countryImportData.StatisticSearch.row.map(row => ({
                                    date: row.TIME,
                                    value: parseFloat(row.DATA_VALUE)
                                })).filter(item => !isNaN(item.value) && item.value > 0);
                            }
                        }
                        
                        // Íµ≠Í∞Ä Î¨¥Ïó≠ÏàòÏßÄ Í≥ÑÏÇ∞
                        const exportMap = new Map();
                        tradeCountryData.EXPORT.forEach(item => exportMap.set(item.date, item.value));
                        const importMap = new Map();
                        tradeCountryData.IMPORT.forEach(item => importMap.set(item.date, item.value));
                        
                        const allDates = new Set([...exportMap.keys(), ...importMap.keys()]);
                        tradeCountryData.BALANCE = Array.from(allDates).map(date => ({
                            date: date,
                            value: (exportMap.get(date) || 0) - (importMap.get(date) || 0)
                        })).sort((a, b) => a.date.localeCompare(b.date));
                        
                    } catch (err) {
                        console.error('Failed to fetch country trade data:', err);
                        tradeCountryData = { EXPORT: [], IMPORT: [], BALANCE: [] };
                    }
                } else {
                    tradeCountryData = { EXPORT: [], IMPORT: [], BALANCE: [] };
                }
                
                // ÌÜµÌôîÏóê Îî∞Îùº Ï∞®Ìä∏ Î∞è Ìó§Îçî ÏóÖÎç∞Ïù¥Ìä∏
                updateTradeChart();
                const statsData = calculateTradeStats(tradeCurrency);
                updateTradeChartHeader(statsData);
                
            } catch (err) {
                console.error('Failed to fetch trade data:', err);
                alert('ÏàòÏ∂úÏûÖ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + err.message);
            } finally {
                if (chartContainer) {
                    chartContainer.style.opacity = '1';
                }
            }
        }

        /**
         * ÏàòÏ∂úÏûÖ ÌÜµÍ≥Ñ Í∏∞Í∞ÑÏóê Ìï¥ÎãπÌïòÎäî ÌôòÏú® Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
         */
        async function fetchTradeExchangeRates(startDate, endDate) {
            try {
                // ÌôòÏú® APIÎäî Ìï≠ÏÉÅ ÏùºÎ≥Ñ(D) Îç∞Ïù¥ÌÑ∞Îßå Ï†úÍ≥µÌïòÎØÄÎ°ú cycle=DÎ°ú Í≥†Ï†ï
                // ÏõîÎ≥Ñ/Î∂ÑÍ∏∞Î≥Ñ ÏàòÏ∂úÏûÖ Îç∞Ïù¥ÌÑ∞Ïùò Í≤ΩÏö∞ Ìï¥Îãπ Í∏∞Í∞ÑÏùò ÌôòÏú®ÏùÑ ÏßëÍ≥ÑÌïòÏó¨ ÏÇ¨Ïö©
                const exchangeUrl = `${API_BASE}/market/indices?type=exchange&itemCode=USD&startDate=${startDate}&endDate=${endDate}&cycle=D`;
                const response = await fetch(exchangeUrl);
                
                if (response.ok) {
                    const data = await response.json();
                    if (!data.error && data.StatisticSearch?.row) {
                        // ÌôòÏú® Îç∞Ïù¥ÌÑ∞Î•º ÎÇ†ÏßúÎ≥ÑÎ°ú Ï†ÄÏû• (YYYYMMDD ÌòïÏãù)
                        tradeExchangeRates = {};
                        data.StatisticSearch.row.forEach(row => {
                            const date = row.TIME; // YYYYMMDD ÌòïÏãù (ÏùºÎ≥Ñ)
                            const rate = parseFloat(row.DATA_VALUE);
                            if (!isNaN(rate) && rate > 0) {
                                tradeExchangeRates[date] = rate;
                            }
                        });
                        console.log(`ÌôòÏú® Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: ${Object.keys(tradeExchangeRates).length}Í∞ú ÏùºÎ≥Ñ Îç∞Ïù¥ÌÑ∞`);
                    } else {
                        console.warn('ÌôòÏú® API ÏùëÎãµÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§:', data);
                    }
                } else {
                    console.error('ÌôòÏú® API Ìò∏Ï∂ú Ïã§Ìå®:', response.status, response.statusText);
                }
            } catch (err) {
                console.error('ÌôòÏú® Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', err);
            }
        }

        /**
         * ÎÇ†ÏßúÏóê Ìï¥ÎãπÌïòÎäî ÌôòÏú® Í∞ÄÏ†∏Ïò§Í∏∞ (ÏõîÎ≥Ñ/Î∂ÑÍ∏∞Î≥Ñ Îß§Ïπ≠)
         * ÌôòÏú® APIÎäî ÏùºÎ≥Ñ(YYYYMMDD) Îç∞Ïù¥ÌÑ∞Îßå Ï†úÍ≥µÌïòÎØÄÎ°ú, ÏõîÎ≥Ñ/Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞Îäî ÏßëÍ≥ÑÌïòÏó¨ ÏÇ¨Ïö©
         */
        function getExchangeRateForDate(date) {
            if (tradeCycle === 'M') {
                // ÏõîÎ≥Ñ: YYYYMM ÌòïÏãù -> Ìï¥Îãπ ÏõîÏùò ÌèâÍ∑† ÌôòÏú® ÎòêÎäî ÎßêÏùº ÌôòÏú® ÏÇ¨Ïö©
                const year = date.substring(0, 4);
                const month = date.substring(4, 6);
                
                // Ìï¥Îãπ ÏõîÏùò Î™®Îì† ÏùºÎ≥Ñ ÌôòÏú® Îç∞Ïù¥ÌÑ∞ Ï∞æÍ∏∞
                const monthPrefix = `${year}${month}`;
                const monthRates = Object.keys(tradeExchangeRates)
                    .filter(key => key.startsWith(monthPrefix))
                    .map(key => tradeExchangeRates[key])
                    .filter(rate => rate > 0);
                
                if (monthRates.length > 0) {
                    // ÌèâÍ∑† ÌôòÏú® ÏÇ¨Ïö©
                    const avgRate = monthRates.reduce((sum, rate) => sum + rate, 0) / monthRates.length;
                    return avgRate;
                }
                
                // ÌèâÍ∑†ÏùÑ Íµ¨Ìï† Ïàò ÏóÜÏúºÎ©¥ Ìï¥Îãπ ÏõîÏùò ÎßàÏßÄÎßâ ÎÇ†Ïßú ÌôòÏú® ÏÇ¨Ïö©
                const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
                const dateKey = `${year}${month}${String(lastDay).padStart(2, '0')}`;
                return tradeExchangeRates[dateKey] || null;
                
            } else if (tradeCycle === 'Q') {
                // Î∂ÑÍ∏∞Î≥Ñ: Ìï¥Îãπ Î∂ÑÍ∏∞Ïùò ÌèâÍ∑† ÌôòÏú® ÏÇ¨Ïö©
                const year = date.substring(0, 4);
                const quarter = date.substring(4); // Q1, Q2, Q3, Q4
                
                // Î∂ÑÍ∏∞Î≥Ñ Ïõî Îß§Ìïë
                const monthMap = { 'Q1': ['01', '02', '03'], 'Q2': ['04', '05', '06'], 
                                 'Q3': ['07', '08', '09'], 'Q4': ['10', '11', '12'] };
                const months = monthMap[quarter] || ['01', '02', '03'];
                
                // Ìï¥Îãπ Î∂ÑÍ∏∞Ïùò Î™®Îì† ÏùºÎ≥Ñ ÌôòÏú® Îç∞Ïù¥ÌÑ∞ Ï∞æÍ∏∞
                const quarterRates = [];
                months.forEach(month => {
                    const monthPrefix = `${year}${month}`;
                    Object.keys(tradeExchangeRates)
                        .filter(key => key.startsWith(monthPrefix))
                        .forEach(key => {
                            const rate = tradeExchangeRates[key];
                            if (rate > 0) {
                                quarterRates.push(rate);
                            }
                        });
                });
                
                if (quarterRates.length > 0) {
                    // ÌèâÍ∑† ÌôòÏú® ÏÇ¨Ïö©
                    const avgRate = quarterRates.reduce((sum, rate) => sum + rate, 0) / quarterRates.length;
                    return avgRate;
                }
                
                // ÌèâÍ∑†ÏùÑ Íµ¨Ìï† Ïàò ÏóÜÏúºÎ©¥ Î∂ÑÍ∏∞ ÎßêÏõîÏùò ÎßàÏßÄÎßâ ÎÇ†Ïßú ÌôòÏú® ÏÇ¨Ïö©
                const lastMonth = months[months.length - 1];
                const lastDay = new Date(parseInt(year), parseInt(lastMonth), 0).getDate();
                const dateKey = `${year}${lastMonth}${String(lastDay).padStart(2, '0')}`;
                return tradeExchangeRates[dateKey] || null;
            }
            return null;
        }

        /**
         * ÌÜµÌôîÎ≥Ñ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
         */
        function calculateTradeStats(currency) {
            const data = currency === 'USD' ? tradeData : tradeDataKRW;
            
            // activeTradeIndicatorsÏóê Îî∞Îùº Îç∞Ïù¥ÌÑ∞ ÏÑ†ÌÉù
            const hasExport = activeTradeIndicators.includes('EXPORT') && data.EXPORT.length > 0;
            const hasImport = activeTradeIndicators.includes('IMPORT') && data.IMPORT.length > 0;
            
            let combinedData = [];
            
            if (hasExport && hasImport) {
                // Îëò Îã§ ÏÑ†ÌÉù Ïãú: ÏàòÏ∂ú + ÏàòÏûÖ Ìï©ÏÇ∞
                const exportMap = new Map();
                data.EXPORT.forEach(item => {
                    exportMap.set(item.date, item.value);
                });
                
                const importMap = new Map();
                data.IMPORT.forEach(item => {
                    importMap.set(item.date, item.value);
                });
                
                // Î™®Îì† ÎÇ†ÏßúÎ•º ÏàòÏßëÌïòÍ≥† Ìï©ÏÇ∞
                const allDates = new Set([...exportMap.keys(), ...importMap.keys()]);
                combinedData = Array.from(allDates).map(date => {
                    const exportValue = exportMap.get(date) || 0;
                    const importValue = importMap.get(date) || 0;
                    return {
                        date: date,
                        value: exportValue + importValue
                    };
                }).sort((a, b) => a.date.localeCompare(b.date));
                
            } else if (hasExport) {
                combinedData = data.EXPORT;
            } else if (hasImport) {
                combinedData = data.IMPORT;
            }
            
            if (combinedData.length === 0) {
                return { error: true };
            }
            
            const values = combinedData.map(item => item.value).filter(v => !isNaN(v) && v > 0);
            if (values.length === 0) {
                return { error: true };
            }
            
            const current = values[values.length - 1];
            const previous = values.length > 1 ? values[values.length - 2] : current;
            const change = current - previous;
            const changePercent = previous !== 0 ? (change / previous) * 100 : 0;
            const high = Math.max(...values);
            const low = Math.min(...values);
            const average = values.reduce((sum, v) => sum + v, 0) / values.length;
            
            return {
                current,
                previous,
                change,
                changePercent,
                high,
                low,
                average
            };
        }

        /**
         * Î¨¥Ïó≠ÏàòÏßÄ Í≥ÑÏÇ∞ (ÏàòÏ∂ú - ÏàòÏûÖ)
         * @returns {void} tradeData.BALANCE Î∞∞Ïó¥ÏùÑ Ï±ÑÏõÄ
         */
        function calculateTradeBalance() {
            const data = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            
            // BALANCE Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî
            if (!data.BALANCE) {
                data.BALANCE = [];
            } else {
                data.BALANCE = [];
            }
            
            // Î™®Îì† ÎÇ†Ïßú ÏàòÏßë
            const allDates = new Set([
                ...data.EXPORT.map(item => item.date),
                ...data.IMPORT.map(item => item.date)
            ]);
            const sortedDates = Array.from(allDates).sort();
            
            sortedDates.forEach(date => {
                const exportItem = data.EXPORT.find(item => item.date === date);
                const importItem = data.IMPORT.find(item => item.date === date);
                
                const exportValue = exportItem?.value || 0;
                const importValue = importItem?.value || 0;
                const balanceValue = exportValue - importValue;
                
                data.BALANCE.push({
                    date: date,
                    value: balanceValue,
                    status: balanceValue >= 0 ? 'SURPLUS' : 'DEFICIT'
                });
            });
            
            // ÎÇ†Ïßú ÏàúÏúºÎ°ú Ï†ïÎ†¨
            data.BALANCE.sort((a, b) => a.date.localeCompare(b.date));
        }

        /**
         * Ï†ÑÏõî ÎåÄÎπÑ Ï¶ùÍ∞êÎ•† Í≥ÑÏÇ∞
         * @returns {Array} [{ date, exportRate, importRate }, ...]
         */
        function calculateTradeGrowthRates() {
            const data = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            const result = [];
            
            // Î™®Îì† ÎÇ†Ïßú ÏàòÏßë
            const allDates = new Set([
                ...data.EXPORT.map(item => item.date),
                ...data.IMPORT.map(item => item.date)
            ]);
            const sortedDates = Array.from(allDates).sort();
            
            sortedDates.forEach((date, index) => {
                if (index === 0) {
                    // Ï≤´ Î≤àÏß∏ Îç∞Ïù¥ÌÑ∞Îäî Ï¶ùÍ∞êÎ•† 0
                    const exportValue = data.EXPORT.find(item => item.date === date)?.value || 0;
                    const importValue = data.IMPORT.find(item => item.date === date)?.value || 0;
                    result.push({
                        date,
                        exportRate: 0,
                        importRate: 0,
                        exportValue,
                        importValue
                    });
                } else {
                    // Ïù¥Ï†Ñ ÎÇ†Ïßú Ï∞æÍ∏∞
                    const prevDate = sortedDates[index - 1];
                    const prevExport = data.EXPORT.find(item => item.date === prevDate);
                    const prevImport = data.IMPORT.find(item => item.date === prevDate);
                    const currExport = data.EXPORT.find(item => item.date === date);
                    const currImport = data.IMPORT.find(item => item.date === date);
                    
                    let exportRate = 0;
                    let importRate = 0;
                    
                    if (prevExport && currExport && prevExport.value > 0) {
                        exportRate = ((currExport.value - prevExport.value) / prevExport.value) * 100;
                    }
                    
                    if (prevImport && currImport && prevImport.value > 0) {
                        importRate = ((currImport.value - prevImport.value) / prevImport.value) * 100;
                    }
                    
                    result.push({
                        date,
                        exportRate,
                        importRate,
                        exportValue: currExport?.value || 0,
                        importValue: currImport?.value || 0
                    });
                }
            });
            
            return result;
        }

        /**
         * Ï†ÑÎÖÑ ÎåÄÎπÑ Ï¶ùÍ∞êÎ•† Í≥ÑÏÇ∞ (YoY - Year over Year)
         * @returns {Array} [{ date, exportYoY, importYoY }, ...]
         */
        function calculateTradeYoYGrowthRates() {
            const data = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            const result = [];
            
            // Î™®Îì† ÎÇ†Ïßú ÏàòÏßë
            const allDates = new Set([
                ...data.EXPORT.map(item => item.date),
                ...data.IMPORT.map(item => item.date)
            ]);
            const sortedDates = Array.from(allDates).sort();
            
            sortedDates.forEach(date => {
                const exportItem = data.EXPORT.find(item => item.date === date);
                const importItem = data.IMPORT.find(item => item.date === date);
                
                let exportYoY = 0;
                let importYoY = 0;
                
                if (tradeCycle === 'M') {
                    // ÏõîÎ≥Ñ: Ï†ÑÎÖÑ ÎèôÏõî Ï∞æÍ∏∞ (YYYYMM ÌòïÏãù)
                    if (date.length === 6) {
                        const year = parseInt(date.substring(0, 4));
                        const month = date.substring(4, 6);
                        const prevYearDate = `${year - 1}${month}`;
                        
                        const prevExport = data.EXPORT.find(item => item.date === prevYearDate);
                        const prevImport = data.IMPORT.find(item => item.date === prevYearDate);
                        
                        if (exportItem && prevExport && prevExport.value > 0) {
                            exportYoY = ((exportItem.value - prevExport.value) / prevExport.value) * 100;
                        }
                        if (importItem && prevImport && prevImport.value > 0) {
                            importYoY = ((importItem.value - prevImport.value) / prevImport.value) * 100;
                        }
                    }
                } else if (tradeCycle === 'Q') {
                    // Î∂ÑÍ∏∞Î≥Ñ: Ï†ÑÎÖÑ ÎèôÎ∂ÑÍ∏∞ Ï∞æÍ∏∞ (YYYYQX ÌòïÏãù)
                    const match = date.match(/^(\d{4})Q([1-4])$/);
                    if (match) {
                        const year = parseInt(match[1]);
                        const quarter = match[2];
                        const prevYearDate = `${year - 1}Q${quarter}`;
                        
                        const prevExport = data.EXPORT.find(item => item.date === prevYearDate);
                        const prevImport = data.IMPORT.find(item => item.date === prevYearDate);
                        
                        if (exportItem && prevExport && prevExport.value > 0) {
                            exportYoY = ((exportItem.value - prevExport.value) / prevExport.value) * 100;
                        }
                        if (importItem && prevImport && prevImport.value > 0) {
                            importYoY = ((importItem.value - prevImport.value) / prevImport.value) * 100;
                        }
                    }
                }
                
                result.push({
                    date,
                    exportYoY,
                    importYoY
                });
            });
            
            return result;
        }

        function updateTradeChart() {
            const exportGrowthPath = document.getElementById('path-trade-export-growth');
            const importGrowthPath = document.getElementById('path-trade-import-growth');
            const barsGroup = document.getElementById('trade-bars-group');
            const pointsGroup = document.getElementById('trade-data-points');
            
            if (!exportGrowthPath || !importGrowthPath || !barsGroup || !pointsGroup) return;
            
            // Clear existing data
            exportGrowthPath.setAttribute('d', '');
            importGrowthPath.setAttribute('d', '');
            barsGroup.innerHTML = '';
            pointsGroup.innerHTML = '';
            
            // Íµ≠Í∞ÄÍ∞Ä ÏÑ†ÌÉùÎêú Í≤ΩÏö∞ Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©, ÏïÑÎãàÎ©¥ ÌïúÍµ≠ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            let displayData;
            if (activeTradeCountry && tradeCountryData.EXPORT.length > 0) {
                // Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
                displayData = {
                    EXPORT: tradeCountryData.EXPORT,
                    IMPORT: tradeCountryData.IMPORT,
                    BALANCE: tradeCountryData.BALANCE
                };
            } else {
                // ÌïúÍµ≠ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
                displayData = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            }
            
            const hasExport = activeTradeIndicators.includes('EXPORT') && displayData.EXPORT.length > 0;
            const hasImport = activeTradeIndicators.includes('IMPORT') && displayData.IMPORT.length > 0;
            const hasBalance = activeTradeIndicators.includes('BALANCE') && displayData.BALANCE && displayData.BALANCE.length > 0;
            
            if (!hasExport && !hasImport && !hasBalance) {
                renderTradeYAxisLabelsLeft();
                renderTradeYAxisLabelsRight();
                renderTradeXAxisLabels();
                return;
            }
            
            // YÏ∂ï Î≤îÏúÑ Í≥ÑÏÇ∞ (ÌëúÏãúÌï† Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)
            const allAmountValues = [];
            if (hasExport) displayData.EXPORT.forEach(item => allAmountValues.push(item.value));
            if (hasImport) displayData.IMPORT.forEach(item => allAmountValues.push(item.value));
            
            if (allAmountValues.length > 0) {
                const minValue = Math.min(...allAmountValues);
                const maxValue = Math.max(...allAmountValues);
                const range = maxValue - minValue || 1;
                const paddingPercent = range < 10 ? 0.1 : (range < 50 ? 0.05 : 0.03);
                tradeYAxisRange = {
                    min: Math.max(0, minValue - range * paddingPercent),
                    max: maxValue + range * paddingPercent
                };
            }
            
            // Render Y-axis labels (Ïù¥Ï§ë YÏ∂ï)
            renderTradeYAxisLabelsLeft();
            renderTradeYAxisLabelsRight();
            
            // Render bar charts (ÏàòÏ∂ú/ÏàòÏûÖ Í∏àÏï° - ÏôºÏ™Ω YÏ∂ï)
            renderTradeBarsForData(displayData);
            
            // Render line charts (Ï¶ùÍ∞êÎ•† - Ïò§Î•∏Ï™Ω YÏ∂ï) - ÌïúÍµ≠ Îç∞Ïù¥ÌÑ∞Îßå
            if (!activeTradeCountry) {
                const growthRates = calculateTradeGrowthRates();
                if (hasExport && growthRates.length >= 2) {
                    const exportGrowthPathData = generateTradeGrowthSVGPath(growthRates, 'export');
                    exportGrowthPath.setAttribute('d', exportGrowthPathData);
                    exportGrowthPath.classList.add('visible');
                } else {
                    exportGrowthPath.classList.remove('visible');
                }
                
                if (hasImport && growthRates.length >= 2) {
                    const importGrowthPathData = generateTradeGrowthSVGPath(growthRates, 'import');
                    importGrowthPath.setAttribute('d', importGrowthPathData);
                    importGrowthPath.classList.add('visible');
                } else {
                    importGrowthPath.classList.remove('visible');
                }
                
                // Render data points for line chart
                renderTradeGrowthDataPoints(growthRates);
            } else {
                exportGrowthPath.classList.remove('visible');
                importGrowthPath.classList.remove('visible');
            }
            
            // Render trade balance line
            renderTradeBalanceForData(displayData);
            
            // Render X-axis labels
            renderTradeXAxisLabelsForData(displayData);
            
            // Setup interactivity
            setupTradeChartInteractivity();
        }
        
        function renderTradeBarsForData(data) {
            const barsGroup = document.getElementById('trade-bars-group');
            if (!barsGroup) return;
            
            barsGroup.innerHTML = '';
            
            const hasExport = activeTradeIndicators.includes('EXPORT') && data.EXPORT.length > 0;
            const hasImport = activeTradeIndicators.includes('IMPORT') && data.IMPORT.length > 0;
            
            if (!hasExport && !hasImport) return;
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Î™®Îì† ÎÇ†Ïßú ÏàòÏßë
            const allDates = new Set([
                ...data.EXPORT.map(item => item.date),
                ...data.IMPORT.map(item => item.date)
            ]);
            const sortedDates = Array.from(allDates).sort();
            
            const valueRange = tradeYAxisRange.max - tradeYAxisRange.min || 1;
            const barWidth = Math.min(30, chartWidth / sortedDates.length * 0.3);
            const barSpacing = chartWidth / sortedDates.length;
            
            sortedDates.forEach((date, index) => {
                const x = padding.left + (index * barSpacing) + (barSpacing / 2) - (barWidth / 2);
                const exportItem = data.EXPORT.find(item => item.date === date);
                const importItem = data.IMPORT.find(item => item.date === date);
                
                if (hasExport && exportItem) {
                    const exportHeight = (exportItem.value / tradeYAxisRange.max) * chartHeight;
                    const exportY = padding.top + chartHeight - exportHeight;
                    
                    const exportBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    exportBar.setAttribute('x', x);
                    exportBar.setAttribute('y', exportY);
                    exportBar.setAttribute('width', barWidth);
                    exportBar.setAttribute('height', exportHeight);
                    exportBar.setAttribute('fill', 'var(--c-trade-export)');
                    exportBar.setAttribute('opacity', '0.8');
                    exportBar.setAttribute('data-date', date);
                    exportBar.setAttribute('data-value', exportItem.value);
                    exportBar.setAttribute('data-type', 'EXPORT');
                    barsGroup.appendChild(exportBar);
                }
                
                if (hasImport && importItem) {
                    const importX = hasExport ? x + barWidth : x;
                    const importHeight = (importItem.value / tradeYAxisRange.max) * chartHeight;
                    const importY = padding.top + chartHeight - importHeight;
                    
                    const importBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    importBar.setAttribute('x', importX);
                    importBar.setAttribute('y', importY);
                    importBar.setAttribute('width', barWidth);
                    importBar.setAttribute('height', importHeight);
                    importBar.setAttribute('fill', 'var(--c-trade-import)');
                    importBar.setAttribute('opacity', '0.8');
                    importBar.setAttribute('data-date', date);
                    importBar.setAttribute('data-value', importItem.value);
                    importBar.setAttribute('data-type', 'IMPORT');
                    barsGroup.appendChild(importBar);
                }
            });
        }
        
        function renderTradeBalanceForData(data) {
            const balancePath = document.getElementById('path-trade-balance');
            if (!balancePath || !activeTradeIndicators.includes('BALANCE') || !data.BALANCE || data.BALANCE.length === 0) {
                if (balancePath) balancePath.style.display = 'none';
                return;
            }
            
            balancePath.style.display = 'block';
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Î¨¥Ïó≠ÏàòÏßÄ Î≤îÏúÑ Í≥ÑÏÇ∞
            const balanceValues = data.BALANCE.map(item => item.value);
            const minBalance = Math.min(...balanceValues);
            const maxBalance = Math.max(...balanceValues);
            const balanceRange = maxBalance - minBalance || 1;
            
            let pathData = '';
            data.BALANCE.forEach((point, index) => {
                const x = padding.left + (index / (data.BALANCE.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minBalance) / balanceRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            balancePath.setAttribute('d', pathData);
            balancePath.setAttribute('stroke', 'var(--c-trade-balance-surplus)');
        }
        
        function renderTradeXAxisLabelsForData(data) {
            const xAxisGroup = document.getElementById('trade-x-axis-labels');
            if (!xAxisGroup) return;
            
            xAxisGroup.innerHTML = '';
            
            const allDates = new Set([
                ...data.EXPORT.map(item => item.date),
                ...data.IMPORT.map(item => item.date)
            ]);
            const sortedDates = Array.from(allDates).sort();
            
            if (sortedDates.length === 0) return;
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return;
            
            const { width } = getSvgViewBoxSize(svg);
            const padding = { left: 40, right: 60 };
            const chartWidth = width - padding.left - padding.right;
            
            const labelInterval = Math.max(1, Math.floor(sortedDates.length / 8));
            
            sortedDates.forEach((date, index) => {
                if (index % labelInterval !== 0 && index !== sortedDates.length - 1) return;
                
                const x = padding.left + (index / (sortedDates.length - 1 || 1)) * chartWidth;
                const y = 370;
                
                let labelText = '';
                if (tradeCycle === 'M' && date.length === 6) {
                    const year = date.substring(0, 4);
                    const month = date.substring(4, 6);
                    labelText = `${year.substring(2)}.${month}`;
                } else if (tradeCycle === 'Q' && date.includes('Q')) {
                    const year = date.substring(0, 4);
                    const quarter = date.substring(5);
                    labelText = `${year.substring(2)}Q${quarter}`;
                } else {
                    labelText = date;
                }
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', y);
                label.setAttribute('class', 'chart-xaxis-label');
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('dominant-baseline', 'middle');
                label.textContent = labelText;
                
                xAxisGroup.appendChild(label);
            });
        }

        function generateTradeSVGPath(data) {
            if (!data || data.length === 0) return '';
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return '';
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = tradeYAxisRange.min;
            const maxValue = tradeYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            let pathData = '';
            data.forEach((point, index) => {
                const x = padding.left + (index / (data.length - 1 || 1)) * chartWidth;
                const normalizedValue = (point.value - minValue) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            return pathData;
        }

        /**
         * Ïù¥Ï§ë YÏ∂ï Î≤îÏúÑ Í≥ÑÏÇ∞
         * @returns {Object} { left: {min, max}, right: {min, max} }
         */
        function calculateDualYAxisRanges() {
            const data = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            
            // ÏôºÏ™Ω YÏ∂ï: ÏàòÏ∂ú/ÏàòÏûÖ Í∏àÏï° Î≤îÏúÑ
            const allAmountValues = [];
            if (activeTradeIndicators.includes('EXPORT')) {
                data.EXPORT.forEach(item => allAmountValues.push(item.value));
            }
            if (activeTradeIndicators.includes('IMPORT')) {
                data.IMPORT.forEach(item => allAmountValues.push(item.value));
            }
            
            let leftRange = { min: 0, max: 100 };
            if (allAmountValues.length > 0) {
                const minValue = Math.min(...allAmountValues);
                const maxValue = Math.max(...allAmountValues);
                const range = maxValue - minValue || 1;
                const paddingPercent = range < 10 ? 0.1 : (range < 50 ? 0.05 : 0.03);
                leftRange = {
                    min: Math.max(0, minValue - range * paddingPercent),
                    max: maxValue + range * paddingPercent
                };
            }
            
            // Ïò§Î•∏Ï™Ω YÏ∂ï: Ï¶ùÍ∞êÎ•† Î≤îÏúÑ
            const growthRates = calculateTradeGrowthRates();
            const allGrowthValues = [];
            growthRates.forEach(item => {
                if (activeTradeIndicators.includes('EXPORT')) {
                    allGrowthValues.push(item.exportRate);
                }
                if (activeTradeIndicators.includes('IMPORT')) {
                    allGrowthValues.push(item.importRate);
                }
            });
            
            let rightRange = { min: -10, max: 10 };
            if (allGrowthValues.length > 0) {
                const minValue = Math.min(...allGrowthValues);
                const maxValue = Math.max(...allGrowthValues);
                const range = maxValue - minValue || 1;
                const paddingPercent = 0.1; // 10% padding
                rightRange = {
                    min: minValue - range * paddingPercent,
                    max: maxValue + range * paddingPercent
                };
            }
            
            return { left: leftRange, right: rightRange };
        }

        /**
         * ÏôºÏ™Ω YÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ (Í∏àÏï°, K Îã®ÏúÑ)
         */
        function renderTradeYAxisLabelsLeft() {
            const yAxisGroup = document.getElementById('trade-y-axis-labels');
            if (!yAxisGroup) return;
            
            yAxisGroup.innerHTML = '';
            
            // Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ tradeYAxisRange ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ calculateDualYAxisRanges ÏÇ¨Ïö©
            if (!activeTradeCountry || tradeCountryData.EXPORT.length === 0) {
                const ranges = calculateDualYAxisRanges();
                tradeYAxisRange = ranges.left;
            }
            
            const steps = 5;
            const { width, height } = getSvgViewBoxSize(document.getElementById('trade-chart-svg'));
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            
            for (let i = 0; i <= steps; i++) {
                const value = tradeYAxisRange.max - (i / steps) * (tradeYAxisRange.max - tradeYAxisRange.min);
                const y = padding.top + (i / steps) * (height - padding.top - padding.bottom);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', padding.left - 10);
                text.setAttribute('y', y);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('class', 'chart-yaxis-label');
                
                // Format value - K Îã®ÏúÑÎ°ú ÌëúÏãú (Ïòà: 67916 ‚Üí 67.9K)
                let formattedValue;
                if (value >= 1000) {
                    const kValue = value / 1000;
                    formattedValue = kValue.toFixed(1) + 'K';
                } else {
                    formattedValue = value.toFixed(0);
                }
                text.textContent = formattedValue;
                
                yAxisGroup.appendChild(text);
            }
        }

        /**
         * Ïò§Î•∏Ï™Ω YÏ∂ï ÎùºÎ≤® Î†åÎçîÎßÅ (Ï¶ùÍ∞êÎ•†, %)
         */
        function renderTradeYAxisLabelsRight() {
            const yAxisGroup = document.getElementById('trade-y-axis-labels-right');
            if (!yAxisGroup) return;
            
            yAxisGroup.innerHTML = '';
            
            const ranges = calculateDualYAxisRanges();
            const rightRange = ranges.right;
            
            const steps = 5;
            const { width, height } = getSvgViewBoxSize(document.getElementById('trade-chart-svg'));
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            
            for (let i = 0; i <= steps; i++) {
                const value = rightRange.max - (i / steps) * (rightRange.max - rightRange.min);
                const y = padding.top + (i / steps) * (height - padding.top - padding.bottom);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', width - padding.right + 10);
                text.setAttribute('y', y);
                text.setAttribute('text-anchor', 'start');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('class', 'chart-yaxis-label');
                
                // Format value - ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨Î°ú ÌëúÏãú
                const formattedValue = value.toFixed(1);
                text.textContent = formattedValue;
                
                yAxisGroup.appendChild(text);
            }
        }

        // Í∏∞Ï°¥ Ìï®ÏàòÎäî Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ Ïú†ÏßÄ (ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú renderTradeYAxisLabelsLeft Ìò∏Ï∂ú)
        function renderTradeYAxisLabels() {
            renderTradeYAxisLabelsLeft();
        }

        /**
         * ÎßâÎåÄ Í∑∏ÎûòÌîÑ Î†åÎçîÎßÅ (ÏàòÏ∂ú/ÏàòÏûÖ Í∏àÏï° - ÏôºÏ™Ω YÏ∂ï)
         */
        function renderTradeBars() {
            const barsGroup = document.getElementById('trade-bars-group');
            if (!barsGroup) return;
            
            barsGroup.innerHTML = '';
            
            const activeData = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            const hasExport = activeTradeIndicators.includes('EXPORT') && activeData.EXPORT.length > 0;
            const hasImport = activeTradeIndicators.includes('IMPORT') && activeData.IMPORT.length > 0;
            
            if (!hasExport && !hasImport) return;
            
            const ranges = calculateDualYAxisRanges();
            const leftRange = ranges.left;
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Î™®Îì† ÎÇ†Ïßú ÏàòÏßë
            const allDates = new Set([
                ...activeData.EXPORT.map(item => item.date),
                ...activeData.IMPORT.map(item => item.date)
            ]);
            const sortedDates = Array.from(allDates).sort();
            
            const valueRange = leftRange.max - leftRange.min || 1;
            const barWidth = Math.min(30, chartWidth / sortedDates.length * 0.3);
            const barSpacing = chartWidth / sortedDates.length;
            
            sortedDates.forEach((date, index) => {
                const x = padding.left + index * barSpacing + (barSpacing - barWidth * 2) / 2;
                
                if (hasExport) {
                    const exportItem = activeData.EXPORT.find(item => item.date === date);
                    if (exportItem && exportItem.value > 0) {
                        const normalizedValue = (exportItem.value - leftRange.min) / valueRange;
                        const barHeight = normalizedValue * chartHeight;
                        const y = padding.top + chartHeight - barHeight;
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x);
                        rect.setAttribute('y', y);
                        rect.setAttribute('width', barWidth);
                        rect.setAttribute('height', barHeight);
                        rect.setAttribute('rx', '4'); // Îë•Í∑º Î™®ÏÑúÎ¶¨
                        rect.setAttribute('fill', 'var(--c-trade-export)');
                        rect.setAttribute('class', 'trade-bar trade-bar-export');
                        rect.setAttribute('data-date', date);
                        rect.setAttribute('data-value', exportItem.value);
                        rect.setAttribute('data-type', 'EXPORT');
                        barsGroup.appendChild(rect);
                    }
                }
                
                if (hasImport) {
                    const importItem = activeData.IMPORT.find(item => item.date === date);
                    if (importItem && importItem.value > 0) {
                        const normalizedValue = (importItem.value - leftRange.min) / valueRange;
                        const barHeight = normalizedValue * chartHeight;
                        const y = padding.top + chartHeight - barHeight;
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x + barWidth);
                        rect.setAttribute('y', y);
                        rect.setAttribute('width', barWidth);
                        rect.setAttribute('height', barHeight);
                        rect.setAttribute('rx', '4'); // Îë•Í∑º Î™®ÏÑúÎ¶¨
                        rect.setAttribute('fill', 'var(--c-trade-import)');
                        rect.setAttribute('class', 'trade-bar trade-bar-import');
                        rect.setAttribute('data-date', date);
                        rect.setAttribute('data-value', importItem.value);
                        rect.setAttribute('data-type', 'IMPORT');
                        barsGroup.appendChild(rect);
                    }
                }
            });
        }

        /**
         * Ï¶ùÍ∞êÎ•† ÏÑ† Í∑∏ÎûòÌîÑ Í≤ΩÎ°ú ÏÉùÏÑ± (Ïò§Î•∏Ï™Ω YÏ∂ï)
         */
        function generateTradeGrowthSVGPath(growthRates, type) {
            if (!growthRates || growthRates.length === 0) return '';
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return '';
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const ranges = calculateDualYAxisRanges();
            const rightRange = ranges.right;
            const valueRange = rightRange.max - rightRange.min || 1;
            
            let pathData = '';
            growthRates.forEach((item, index) => {
                const value = type === 'export' ? item.exportRate : item.importRate;
                const x = padding.left + (index / (growthRates.length - 1 || 1)) * chartWidth;
                const normalizedValue = (value - rightRange.min) / valueRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            return pathData;
        }

        /**
         * Ï¶ùÍ∞êÎ•† ÏÑ† Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ Î†åÎçîÎßÅ
         */
        function renderTradeGrowthDataPoints(growthRates) {
            const pointsGroup = document.getElementById('trade-data-points');
            if (!pointsGroup) return;
            
            pointsGroup.innerHTML = '';
            
            const activeData = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            const hasExport = activeTradeIndicators.includes('EXPORT') && activeData.EXPORT.length > 0;
            const hasImport = activeTradeIndicators.includes('IMPORT') && activeData.IMPORT.length > 0;
            
            if (!hasExport && !hasImport) return;
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const ranges = calculateDualYAxisRanges();
            const rightRange = ranges.right;
            const valueRange = rightRange.max - rightRange.min || 1;
            
            growthRates.forEach((item, index) => {
                const x = padding.left + (index / (growthRates.length - 1 || 1)) * chartWidth;
                
                if (hasExport) {
                    const normalizedValue = (item.exportRate - rightRange.min) / valueRange;
                    const y = padding.top + (1 - normalizedValue) * chartHeight;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', 4);
                    circle.setAttribute('fill', 'var(--bg-card)');
                    circle.setAttribute('stroke', 'var(--c-trade-growth-export)');
                    circle.setAttribute('stroke-width', '2');
                    circle.setAttribute('class', 'chart-data-point trade-growth-point');
                    circle.setAttribute('data-date', item.date);
                    circle.setAttribute('data-type', 'EXPORT_GROWTH');
                    circle.setAttribute('data-value', item.exportRate);
                    pointsGroup.appendChild(circle);
                }
                
                if (hasImport) {
                    const normalizedValue = (item.importRate - rightRange.min) / valueRange;
                    const y = padding.top + (1 - normalizedValue) * chartHeight;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', 4);
                    circle.setAttribute('fill', 'var(--bg-card)');
                    circle.setAttribute('stroke', 'var(--c-trade-growth-import)');
                    circle.setAttribute('stroke-width', '2');
                    circle.setAttribute('class', 'chart-data-point trade-growth-point');
                    circle.setAttribute('data-date', item.date);
                    circle.setAttribute('data-type', 'IMPORT_GROWTH');
                    circle.setAttribute('data-value', item.importRate);
                    pointsGroup.appendChild(circle);
                }
            });
        }

        /**
         * Î¨¥Ïó≠ÏàòÏßÄ Î†åÎçîÎßÅ (ÎùºÏù∏ Ï∞®Ìä∏)
         */
        function renderTradeBalance() {
            const balancePath = document.getElementById('path-trade-balance');
            if (!balancePath) return;
            
            const activeData = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            const hasBalance = activeTradeIndicators.includes('BALANCE') && activeData.BALANCE && activeData.BALANCE.length > 0;
            
            if (!hasBalance) {
                balancePath.style.display = 'none';
                return;
            }
            
            balancePath.style.display = 'block';
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Î¨¥Ïó≠ÏàòÏßÄ Î≤îÏúÑ Í≥ÑÏÇ∞ (0 Í∏∞Ï§ÄÏÑ† Ìè¨Ìï®)
            const balanceValues = activeData.BALANCE.map(item => item.value);
            const minBalance = Math.min(0, ...balanceValues);
            const maxBalance = Math.max(0, ...balanceValues);
            const balanceRange = maxBalance - minBalance || 1;
            
            let pathData = '';
            activeData.BALANCE.forEach((item, index) => {
                const x = padding.left + (index / (activeData.BALANCE.length - 1 || 1)) * chartWidth;
                
                // 0 Í∏∞Ï§ÄÏÑ† Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÍ∑úÌôî
                const normalizedValue = (item.value - minBalance) / balanceRange;
                const y = padding.top + (1 - normalizedValue) * chartHeight;
                
                // ÏÉâÏÉÅ Í≤∞Ï†ï (ÌùëÏûê/Ï†ÅÏûê)
                const color = item.status === 'SURPLUS' ? 'var(--c-trade-balance-surplus)' : 'var(--c-trade-balance-deficit)';
                balancePath.setAttribute('stroke', color);
                
                if (index === 0) {
                    pathData = `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            balancePath.setAttribute('d', pathData);
            balancePath.classList.add('visible');
        }

        function renderTradeXAxisLabels() {
            const xAxisGroup = document.getElementById('trade-x-axis-labels');
            if (!xAxisGroup) return;
            
            xAxisGroup.innerHTML = '';
            
            // ÌÜµÌôîÏóê Îî∞Îùº Îã§Î•∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            const activeData = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            
            // Use export data for X-axis labels (or import if export is not available)
            const labelData = activeData.EXPORT.length > 0 ? activeData.EXPORT : activeData.IMPORT;
            
            if (labelData.length === 0) return;
            
            const { width, height } = getSvgViewBoxSize(document.getElementById('trade-chart-svg'));
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            
            // ÏõîÎ≥ÑÏù∏ Í≤ΩÏö∞ Î™®Îì† ÏõîÏùÑ YY.MM ÌòïÏãùÏúºÎ°ú ÌëúÏãú
            labelData.forEach((point, index) => {
                const x = padding.left + (index / (labelData.length - 1 || 1)) * (width - padding.left - padding.right);
                const y = height - padding.bottom + 20;
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('class', 'chart-xaxis-label');
                
                // Format date
                let formattedDate = point.date;
                if (tradeCycle === 'M' && point.date.length === 6) {
                    // YY.MM ÌòïÏãù
                    formattedDate = `${point.date.substring(2, 4)}.${point.date.substring(4, 6)}`;
                } else if (tradeCycle === 'Q' && point.date.includes('Q')) {
                    const match = point.date.match(/^(\d{4})Q([1-4])$/);
                    if (match) {
                        formattedDate = `${match[1].substring(2, 4)}.${match[2]}Q`;
                    }
                }
                
                text.textContent = formattedDate;
                xAxisGroup.appendChild(text);
            });
        }

        function renderTradeDataPoints() {
            const pointsGroup = document.getElementById('trade-data-points');
            if (!pointsGroup) return;
            
            pointsGroup.innerHTML = '';
            
            const svg = document.getElementById('trade-chart-svg');
            if (!svg) return;
            
            const { width, height } = getSvgViewBoxSize(svg);
            const padding = { top: 20, bottom: 30, left: 40, right: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minValue = tradeYAxisRange.min;
            const maxValue = tradeYAxisRange.max;
            const valueRange = maxValue - minValue || 1;
            
            // ÌÜµÌôîÏóê Îî∞Îùº Îã§Î•∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            const activeData = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
            
            // Export points
            if (activeTradeIndicators.includes('EXPORT') && activeData.EXPORT.length > 0) {
                activeData.EXPORT.forEach((point, index) => {
                    const x = padding.left + (index / (activeData.EXPORT.length - 1 || 1)) * chartWidth;
                    const normalizedValue = (point.value - minValue) / valueRange;
                    const y = padding.top + (1 - normalizedValue) * chartHeight;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', '4');
                    circle.setAttribute('fill', 'var(--c-trade-export)');
                    circle.setAttribute('class', 'chart-data-point');
                    
                    pointsGroup.appendChild(circle);
                });
            }
            
            // Import points
            if (activeTradeIndicators.includes('IMPORT') && activeData.IMPORT.length > 0) {
                activeData.IMPORT.forEach((point, index) => {
                    const x = padding.left + (index / (activeData.IMPORT.length - 1 || 1)) * chartWidth;
                    const normalizedValue = (point.value - minValue) / valueRange;
                    const y = padding.top + (1 - normalizedValue) * chartHeight;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', '4');
                    circle.setAttribute('fill', 'var(--c-trade-import)');
                    circle.setAttribute('class', 'chart-data-point');
                    
                    pointsGroup.appendChild(circle);
                });
            }
        }

        function updateTradeChartHeader(stats) {
            // Ìó§ÎçîÎäî Ï†úÎ™©Îßå ÌëúÏãú
            const titleEl = document.getElementById('trade-chart-main-title');
            if (titleEl) {
                if (activeTradeCountry) {
                    const countryInfo = tradeCountryMapping[activeTradeCountry];
                    const countryName = countryInfo ? countryInfo.name : activeTradeCountry;
                    titleEl.textContent = `${countryName} ÏàòÏ∂úÏûÖÏã§Ï†Å`;
                } else {
                    titleEl.textContent = 'ÏàòÏ∂úÏûÖÏã§Ï†Å';
                }
            }
        }

        let tradeMouseMoveHandler = null;
        let tradeMouseLeaveHandler = null;

        function setupTradeChartInteractivity() {
            const chartContainer = document.getElementById('trade-chart-container');
            const svg = document.getElementById('trade-chart-svg');
            
            if (!chartContainer || !svg) return;
            
            const tooltip = document.getElementById('trade-chart-tooltip');
            if (tooltip && tooltip.parentElement !== document.body) {
                document.body.appendChild(tooltip);
            }
            
            // Remove existing listeners
            if (tradeMouseMoveHandler) {
                chartContainer.removeEventListener('mousemove', tradeMouseMoveHandler);
            }
            if (tradeMouseLeaveHandler) {
                chartContainer.removeEventListener('mouseleave', tradeMouseLeaveHandler);
            }
            
            let rafId = null;
            
            tradeMouseMoveHandler = (e) => {
                if (rafId) return;
                rafId = requestAnimationFrame(() => {
                    rafId = null;
                    
                    // Íµ≠Í∞ÄÍ∞Ä ÏÑ†ÌÉùÎêú Í≤ΩÏö∞ Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©, ÏïÑÎãàÎ©¥ ÌïúÍµ≠ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
                    let displayData;
                    if (activeTradeCountry && tradeCountryData.EXPORT.length > 0) {
                        displayData = tradeCountryData;
                    } else {
                        displayData = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
                    }
                    
                    const allData = [];
                    if (activeTradeIndicators.includes('EXPORT') && displayData.EXPORT.length > 0) {
                        allData.push(...displayData.EXPORT.map(item => ({...item, type: 'EXPORT'})));
                    }
                    if (activeTradeIndicators.includes('IMPORT') && displayData.IMPORT.length > 0) {
                        allData.push(...displayData.IMPORT.map(item => ({...item, type: 'IMPORT'})));
                    }
                    
                    if (allData.length === 0) {
                        hideTradeTooltip();
                        return;
                    }
                    
                    const rect = chartContainer.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const svgX = (x / rect.width) * 1200;
                    
                    const padding = { left: 40, right: 60 };
                    const chartWidth = 1200 - padding.left - padding.right;
                    
                    // Î™®Îì† ÎÇ†Ïßú ÏàòÏßë
                    const allDates = new Set([
                        ...displayData.EXPORT.map(item => item.date),
                        ...displayData.IMPORT.map(item => item.date)
                    ]);
                    const sortedDates = Array.from(allDates).sort();
                    
                    if (sortedDates.length === 0) {
                        hideTradeTooltip();
                        return;
                    }
                    
                    const dataIndex = Math.round(((svgX - padding.left) / chartWidth) * (sortedDates.length - 1));
                    
                    if (dataIndex >= 0 && dataIndex < sortedDates.length) {
                        const date = sortedDates[dataIndex];
                        const exportPoint = displayData.EXPORT.find(p => p.date === date);
                        const importPoint = displayData.IMPORT.find(p => p.date === date);
                        const balancePoint = displayData.BALANCE?.find(p => p.date === date);
                        
                        showTradeTooltip(e, { date, exportPoint, importPoint, balancePoint, isCountry: !!activeTradeCountry });
                    } else {
                        hideTradeTooltip();
                    }
                });
            };
            
            tradeMouseLeaveHandler = () => {
                hideTradeTooltip();
            };
            
            chartContainer.addEventListener('mousemove', tradeMouseMoveHandler);
            chartContainer.addEventListener('mouseleave', tradeMouseLeaveHandler);
        }

        function showTradeTooltip(event, data) {
            const tooltip = document.getElementById('trade-chart-tooltip');
            const tooltipDate = document.getElementById('trade-tooltip-date');
            const tooltipContent = document.getElementById('trade-tooltip-content');
            
            if (!tooltip || !tooltipDate || !tooltipContent) return;
            
            // Format date
            let formattedDate = data.date;
            if (tradeCycle === 'M' && data.date.length === 6) {
                formattedDate = `${data.date.substring(0, 4)} ${data.date.substring(4, 6)}Ïõî`;
            } else if (tradeCycle === 'Q' && data.date.includes('Q')) {
                formattedDate = data.date;
            }
            
            tooltipDate.textContent = formattedDate;
            
            // Build content - ÎßâÎåÄ Í∑∏ÎûòÌîÑ(Í∏àÏï°) + ÏÑ† Í∑∏ÎûòÌîÑ(Ï¶ùÍ∞êÎ•†) + Î¨¥Ïó≠ÏàòÏßÄ
            let contentHtml = '';
            
            // Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞Ïù∏ Í≤ΩÏö∞ Ï¶ùÍ∞êÎ•† Í≥ÑÏÇ∞ ÏÉùÎûµ
            let growthData = null;
            let yoyData = null;
            if (!data.isCountry) {
                const activeData = tradeCurrency === 'USD' ? tradeData : tradeDataKRW;
                const growthRates = calculateTradeGrowthRates();
                growthData = growthRates.find(item => item.date === data.date);
                const yoyRates = calculateTradeYoYGrowthRates();
                yoyData = yoyRates.find(item => item.date === data.date);
            }
            
            // Î¨¥Ïó≠ÏàòÏßÄ Îç∞Ïù¥ÌÑ∞ (Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ ÎòêÎäî ÌïúÍµ≠ Îç∞Ïù¥ÌÑ∞)
            const balanceData = data.balancePoint || (tradeCurrency === 'USD' ? tradeData : tradeDataKRW).BALANCE?.find(item => item.date === data.date);
            
            // ÎßâÎåÄ Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞ (Í∏àÏï°) - Íµ¨Î∂ÑÏÑ† Ï∂îÍ∞Ä
            let hasAmountData = false;
            if (data.exportPoint && activeTradeIndicators.includes('EXPORT')) {
                hasAmountData = true;
                const formatted = formatTradeNumberWithEasyUnit(data.exportPoint.value, tradeCurrency);
                const valueText = formatted.easyUnit
                    ? `${formatted.formatted} ${formatted.easyUnit}`
                    : formatted.formatted;
                contentHtml += `
                    <div class="tooltip-row">
                        <span class="tooltip-label" style="color: var(--c-trade-export);">‚óè ÏàòÏ∂ú</span>
                        <span class="tooltip-value">${valueText}</span>
                    </div>
                `;
            }
            
            if (data.importPoint && activeTradeIndicators.includes('IMPORT')) {
                hasAmountData = true;
                const formatted = formatTradeNumberWithEasyUnit(data.importPoint.value, tradeCurrency);
                const valueText = formatted.easyUnit
                    ? `${formatted.formatted} ${formatted.easyUnit}`
                    : formatted.formatted;
                contentHtml += `
                    <div class="tooltip-row">
                        <span class="tooltip-label" style="color: var(--c-trade-import);">‚óè ÏàòÏûÖ</span>
                        <span class="tooltip-value">${valueText}</span>
                    </div>
                `;
            }
            
            // Î¨¥Ïó≠ÏàòÏßÄ ÌëúÏãú
            if (balanceData && (activeTradeIndicators.includes('BALANCE') || (data.exportPoint && data.importPoint))) {
                if (hasAmountData) {
                    contentHtml += `<div style="border-bottom: 1px solid rgba(255,255,255,0.1); margin: 8px 0 4px 0;"></div>`;
                }
                const balanceColor = (balanceData.status === 'SURPLUS' || balanceData.value >= 0) ? 'var(--c-trade-balance-surplus)' : 'var(--c-trade-balance-deficit)';
                const balanceSign = balanceData.value >= 0 ? '+' : '';
                const currency = data.isCountry ? 'USD' : tradeCurrency;
                const formattedBalance = formatTradeNumberWithEasyUnit(Math.abs(balanceData.value), currency);
                const balanceText = formattedBalance.easyUnit
                    ? `${balanceSign}${formattedBalance.formatted} ${formattedBalance.easyUnit}`
                    : `${balanceSign}${formattedBalance.formatted}`;
                contentHtml += `
                    <div class="tooltip-row">
                        <span class="tooltip-label">Î¨¥Ïó≠ÏàòÏßÄ</span>
                        <span class="tooltip-value" style="color: ${balanceColor};">${balanceText}</span>
                    </div>
                `;
            }
            
            // ÏÑ† Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞ (Ï¶ùÍ∞êÎ•†) - Ï†ÑÏõî ÎåÄÎπÑ Î∞è Ï†ÑÎÖÑ ÎåÄÎπÑ
            if (growthData || yoyData) {
                if (hasAmountData || balanceData) {
                    contentHtml += `<div style="border-bottom: 1px solid rgba(255,255,255,0.1); margin: 8px 0 4px 0;"></div>`;
                }
                
                // Ï†ÑÏõî ÎåÄÎπÑ Ï¶ùÍ∞êÎ•†
                if (growthData) {
                    if (activeTradeIndicators.includes('EXPORT') && growthData.exportRate !== undefined) {
                        const sign = growthData.exportRate >= 0 ? '+' : '';
                        const color = growthData.exportRate >= 0 ? '#ef4444' : '#3b82f6';
                        contentHtml += `
                            <div class="tooltip-row">
                                <span class="tooltip-label">ÏàòÏ∂ú Ï¶ùÍ∞êÎ•† (MoM)</span>
                                <span class="tooltip-value" style="color: ${color};">${sign}${growthData.exportRate.toFixed(1)}%</span>
                            </div>
                        `;
                    }
                    
                    if (activeTradeIndicators.includes('IMPORT') && growthData.importRate !== undefined) {
                        const sign = growthData.importRate >= 0 ? '+' : '';
                        const color = growthData.importRate >= 0 ? '#ef4444' : '#3b82f6';
                        contentHtml += `
                            <div class="tooltip-row">
                                <span class="tooltip-label">ÏàòÏûÖ Ï¶ùÍ∞êÎ•† (MoM)</span>
                                <span class="tooltip-value" style="color: ${color};">${sign}${growthData.importRate.toFixed(1)}%</span>
                            </div>
                        `;
                    }
                }
                
                // Ï†ÑÎÖÑ ÎåÄÎπÑ Ï¶ùÍ∞êÎ•†
                if (yoyData) {
                    if (activeTradeIndicators.includes('EXPORT') && yoyData.exportYoY !== undefined && yoyData.exportYoY !== 0) {
                        const sign = yoyData.exportYoY >= 0 ? '+' : '';
                        const color = yoyData.exportYoY >= 0 ? '#ef4444' : '#3b82f6';
                        contentHtml += `
                            <div class="tooltip-row">
                                <span class="tooltip-label">ÏàòÏ∂ú Ï¶ùÍ∞êÎ•† (YoY)</span>
                                <span class="tooltip-value" style="color: ${color};">${sign}${yoyData.exportYoY.toFixed(1)}%</span>
                            </div>
                        `;
                    }
                    
                    if (activeTradeIndicators.includes('IMPORT') && yoyData.importYoY !== undefined && yoyData.importYoY !== 0) {
                        const sign = yoyData.importYoY >= 0 ? '+' : '';
                        const color = yoyData.importYoY >= 0 ? '#ef4444' : '#3b82f6';
                        contentHtml += `
                            <div class="tooltip-row">
                                <span class="tooltip-label">ÏàòÏûÖ Ï¶ùÍ∞êÎ•† (YoY)</span>
                                <span class="tooltip-value" style="color: ${color};">${sign}${yoyData.importYoY.toFixed(1)}%</span>
                            </div>
                        `;
                    }
                }
            }
            
            tooltipContent.innerHTML = contentHtml;
            
            // Position tooltip
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
            tooltip.style.visibility = 'visible';
            tooltip.classList.add('visible');
        }

        function hideTradeTooltip() {
            const tooltip = document.getElementById('trade-chart-tooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
                tooltip.style.visibility = 'hidden';
            }
        }

        // Currency Í∏∞Îä• Ï†úÍ±∞Îê® - Ìï≠ÏÉÅ USD Î™®ÎìúÎ°ú ÎèôÏûëÌïòÎ©∞ ÏõêÌôî ÌôòÏÇ∞Í∞íÎèÑ Ìï®Íªò ÌëúÏãú

        function toggleTradeIndicator(indicator) {
            const chip = document.getElementById(`chip-trade-${indicator.toLowerCase()}`);
            if (!chip) return;
            
            if (activeTradeIndicators.includes(indicator)) {
                activeTradeIndicators = activeTradeIndicators.filter(i => i !== indicator);
                chip.classList.remove('active');
            } else {
                activeTradeIndicators.push(indicator);
                chip.classList.add('active');
            }
            
            // Ï∞®Ìä∏ Î∞è Ìó§Îçî ÏóÖÎç∞Ïù¥Ìä∏
            updateTradeChart();
            const statsData = calculateTradeStats(tradeCurrency);
            updateTradeChartHeader(statsData);
        }

        // Helper function to get SVG viewBox size
        function getSvgViewBoxSize(svg) {
            if (!svg) return { width: 1200, height: 400 };
            const viewBox = svg.getAttribute('viewBox');
            if (viewBox) {
                const parts = viewBox.split(' ');
                return { width: parseFloat(parts[2]) || 1200, height: parseFloat(parts[3]) || 400 };
            }
            return { width: 1200, height: 400 };
        }

        // Helper function to format date for API
        function formatDateForAPI(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}${month}${day}`;
        }

        // ============================================
        // War Room - Global Alarm Functions
        // ============================================
        let mapInstance = null;
        let currentMarkers = [];
        let heatmapLayer = null;
        let alertUpdateInterval = null;
        // isMapInitializedÏôÄ intersectionObserverÎäî head scriptÏóêÏÑú Ïù¥ÎØ∏ Ï†ÑÏó≠ÏúºÎ°ú ÏÑ†Ïñ∏Îê®
        // Ïó¨Í∏∞ÏÑúÎäî window Í∞ùÏ≤¥Î•º ÌÜµÌï¥ Ï†ëÍ∑º
        let allAlerts = []; // Ï†ÑÏ≤¥ ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
        let currentFilters = {
            severity: 'all',
            category: 'all',
            sort: 'severity'
        };

        // ============================================
        // GDELT Îç∞Ïù¥ÌÑ∞ ÌíàÏßà Í∞úÏÑ† Ìï®ÏàòÎì§
        // ============================================
        
        // CAMEO Event Code ÏÑ§Î™Ö Îß§Ìïë ÌÖåÏù¥Î∏î
        const CAMEO_EVENT_DESCRIPTIONS = {
            // Root Code 01: Make Public Statement
            '010': 'Í≥µÍ∞ú ÏÑ±Î™Ö',
            '011': 'Í≥µÏãù Î∞©Î¨∏ ÏäπÏù∏',
            '012': 'ÎÇôÍ¥ÄÏ†Å Î∞úÏñ∏',
            '013': 'ÎπÑÍ¥ÄÏ†Å Î∞úÏñ∏',
            
            // Root Code 10: Demand
            '100': 'ÏöîÍµ¨',
            '101': 'Ï†ïÎ≥¥ ÏöîÍµ¨',
            '102': 'Í≤ΩÏ†ú ÏßÄÏõê ÏöîÍµ¨',
            '103': 'Íµ∞ÏÇ¨ ÏßÄÏõê ÏöîÍµ¨',
            
            // Root Code 13: Protest
            '130': 'ÏãúÏúÑ',
            '131': 'ÌèâÌôî ÏãúÏúÑ',
            '138': 'Ìï≠Ïùò ÏãúÏúÑ',
            '139': 'Ìè≠Î†• ÏãúÏúÑ',
            
            // Root Code 14: Exhibit Force Posture
            '140': 'Î¨¥Î†• ÏãúÏúÑ',
            '141': 'Íµ∞ÏÇ¨Î†• Ï¶ùÍ∞ï',
            '142': 'Íµ∞ÏÇ¨Î†• ÎèôÏõê',
            '145': 'ÏúÑÌòë',
            
            // Root Code 16: Reduce Relations
            '160': 'Í¥ÄÍ≥Ñ Ï∂ïÏÜå',
            '161': 'Ïô∏Íµê Ï∂ïÏÜå',
            '162': 'Ïô∏Íµê Ï†úÏû¨',
            '163': 'Í≤ΩÏ†ú Ï†úÏû¨',
            '164': 'Í≤ΩÏ†ú Î¥âÏáÑ',
            '165': 'Íµ∞ÏÇ¨ Ï†úÏû¨',
            
            // Root Code 17: Coerce
            '170': 'Í∞ïÏïï',
            '171': 'Ïû¨ÏÇ∞ ÏïïÎ•ò',
            '172': 'ÌôúÎèô Ï†úÌïú',
            '173': 'Î¨ºÎ¶¨Î†• ÏÇ¨Ïö©',
            '174': 'Íµ∞ÏÇ¨Î†• ÏÇ¨Ïö©',
            '175': 'Î¨¥Î†• ÏÇ¨Ïö©',
            
            // Root Code 18: Assault
            '180': 'Ìè≠Ìñâ',
            '181': 'ÏßÅÏ†ë Ìè≠Ìñâ',
            '182': 'ÌôîÌïô/ÏÉùÎ¨ºÌïô Í≥µÍ≤©',
            '183': 'Ìè≠ÌÉÑ Í≥µÍ≤©',
            '185': 'Î¨¥Ï∞®Î≥Ñ Ìè≠Î†•',
            '186': 'Í≥†Î¨∏',
            
            // Root Code 19: Fight
            '190': 'Ï†ÑÌà¨/ÏÇ¥ÏÉÅ',
            '191': 'ÎåÄÍ∑úÎ™® Î¨¥Î†• Ï∂©Îèå',
            '192': 'Ï†ÑÎ©¥Ï†Ñ',
            '193': 'ÍµêÏ†Ñ',
            '194': 'Ìè¨Í≤©/Í≥µÏäµ',
            '195': 'Ï†êÎ†π',
            '196': 'Ïπ®Í≥µ',
            
            // Root Code 20: Mass Violence
            '200': 'ÎåÄÎüâ ÏÇ¥ÏÉÅ',
            '201': 'ÎØºÍ∞ÑÏù∏ ÌïôÏÇ¥',
            
            // 4ÏûêÎ¶¨ ÏÉÅÏÑ∏ ÏΩîÎìú
            '1711': 'Ïû¨ÏÇ∞ ÏïïÎ•ò',
            '1712': 'Ïû¨ÏÇ∞ ÏÜêÏÉÅ',
            '1713': 'Ïû¨ÏÇ∞ ÌååÍ¥¥'
        };
        
        /**
         * Event CodeÎ•º ÏÑ§Î™ÖÏúºÎ°ú Î≥ÄÌôò
         */
        function getEventDescription(eventCode) {
            if (!eventCode) return 'ÎØ∏Î∂ÑÎ•ò';
            
            const code = String(eventCode);
            
            // Ï†ïÌôïÌïú Îß§Ïπ≠ ÏãúÎèÑ
            if (CAMEO_EVENT_DESCRIPTIONS[code]) {
                return CAMEO_EVENT_DESCRIPTIONS[code];
            }
            
            // Root CodeÎ°ú Ìè¥Î∞± (Ïòà: 1712 ‚Üí 171 ‚Üí 17)
            if (code.length === 4) {
                const rootCode3 = code.substring(0, 3);
                if (CAMEO_EVENT_DESCRIPTIONS[rootCode3]) {
                    return CAMEO_EVENT_DESCRIPTIONS[rootCode3];
                }
            }
            
            if (code.length >= 2) {
                const rootCode2 = code.substring(0, 2);
                if (CAMEO_EVENT_DESCRIPTIONS[rootCode2]) {
                    return CAMEO_EVENT_DESCRIPTIONS[rootCode2];
                }
            }
            
            return `Ïù¥Î≤§Ìä∏ ${code}`;
        }
        
        /**
         * Ïã†Î¢∞ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞
         */
        function calculateConfidence(alert) {
            let score = 100;
            let flags = [];
            
            // 1. Tone-Scale Î™®Ïàú Í∞êÏßÄ (Í∞ÄÏû• Ï§ëÏöî)
            const avgTone = alert.avg_tone || 0;
            const goldstein = alert.goldstein_scale || alert.scale || 0;
            
            // AvgToneÏùÄ ÏñëÏàò(Í∏çÏ†ï)Ïù∏Îç∞ GoldsteinScaleÏùÄ Îß§Ïö∞ Î∂ÄÏ†ïÏ†Å
            if (avgTone > 0 && goldstein < -7.0) {
                score -= 50;
                flags.push('TONE_SCALE_MISMATCH');
            }
            
            // 2. Îã®Ïùº ÏÜåÏä§ (Ïã†Î¢∞ÎèÑ ÎÇÆÏùå)
            if ((alert.num_sources || 0) <= 1) {
                score -= 15;
                flags.push('SINGLE_SOURCE');
            }
            
            // 3. Í∑πÎã®Ï†Å Ï†êÏàò + ÎÇÆÏùÄ Ïñ∏Í∏â ÌöüÏàò
            if (goldstein < -8.0 && (alert.num_mentions || 0) < 3) {
                score -= 25;
                flags.push('EXTREME_LOW_MENTIONS');
            }
            
            // 4. Actor Ï†ïÎ≥¥ Î∂ÄÏ°±
            if (!alert.actor1 && !alert.actor2) {
                score -= 10;
                flags.push('MISSING_ACTORS');
            }
            
            return {
                score: Math.max(0, score),
                flags: flags,
                is_reliable: score >= 60
            };
        }
        
        /**
         * Actor Ïù¥Î¶Ñ Ï†ïÎ¶¨ (Îπà actor Ï†úÍ±∞)
         */
        function getCleanActorName(actor1, actor2) {
            const a1 = (actor1 || '').trim();
            const a2 = (actor2 || '').trim();
            
            if (a1 && a2) {
                return `${a1} - ${a2}`;
            } else if (a1) {
                return a1;
            } else if (a2) {
                return a2;
            } else {
                return 'ÎØ∏Î∂ÑÎ•ò';
            }
        }

        // ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨ (War Room ÏÑπÏÖòÏúºÎ°ú Ïä§ÌÅ¨Î°§)
        document.addEventListener('DOMContentLoaded', function() {
            const warRoomLink = document.querySelector('nav a[href="#war-room"]');
            if (warRoomLink) {
                warRoomLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    const warRoomSection = document.getElementById('war-room');
                    if (warRoomSection) {
                        warRoomSection.scrollIntoView({ behavior: 'smooth' });
                        // ÏßÄÎèÑÍ∞Ä ÏïÑÏßÅ Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÎã§Î©¥ Ï¥àÍ∏∞Ìôî
                        if (!window.isMapInitialized && typeof google !== 'undefined' && google.maps && typeof google.maps.Map === 'function') {
                            initGlobalAlarmMap();
                        } else if (!window.isMapInitialized) {
                            // APIÍ∞Ä ÏïÑÏßÅ Î°úÎìúÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ checkAndInitMap Ìò∏Ï∂ú
                            checkAndInitMap();
                        }
                    }
                });
            }

            // Google Maps API Î°úÎìú ÌôïÏù∏ Î∞è Ï¥àÍ∏∞Ìôî
            if (typeof google !== 'undefined' && google.maps) {
                // APIÍ∞Ä Ïù¥ÎØ∏ Î°úÎìúÎêú Í≤ΩÏö∞
                checkAndInitMap();
            } else {
                // API Î°úÎìúÎ•º Í∏∞Îã§Î¶º
                window.addEventListener('load', function() {
                    setTimeout(checkAndInitMap, 1000);
                });
            }
        });

        // checkAndInitMap Ìï®Ïàò Ï†ïÏùò (head scriptÏóêÏÑú Ìò∏Ï∂úÎê®)
        // window Í∞ùÏ≤¥ÏóêÎèÑ Î∞îÏù∏Îî©ÌïòÏó¨ head scriptÏóêÏÑú Ï†ëÍ∑º Í∞ÄÎä•ÌïòÎèÑÎ°ù Ìï®
        function checkAndInitMap() {
            // Google Maps APIÍ∞Ä ÏôÑÏ†ÑÌûà Î°úÎìúÎêòÏóàÎäîÏßÄ ÌôïÏù∏
            if (typeof google === 'undefined' || !google.maps || typeof google.maps.Map !== 'function') {
                // APIÍ∞Ä ÏïÑÏßÅ Î°úÎìúÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ Ïû†Ïãú ÌõÑ Ïû¨ÏãúÎèÑ
                setTimeout(checkAndInitMap, 500);
                return;
            }
            
            // head scriptÏóêÏÑú ÏÑ†Ïñ∏Ìïú Ï†ÑÏó≠ Î≥ÄÏàò ÏÇ¨Ïö©
            if (!window.isMapInitialized) {
                // War Room ÏÑπÏÖòÏù¥ Î≥¥Ïù¥ÎäîÏßÄ ÌôïÏù∏
                const warRoomSection = document.getElementById('war-room');
                if (warRoomSection) {
                    // Í∏∞Ï°¥ observerÍ∞Ä ÏûàÏúºÎ©¥ Ï†ïÎ¶¨
                    if (window.intersectionObserver) {
                        window.intersectionObserver.disconnect();
                    }
                    
                    window.intersectionObserver = new IntersectionObserver(function(entries) {
                        entries.forEach(entry => {
                            if (entry.isIntersecting && !window.isMapInitialized) {
                                // APIÍ∞Ä ÏôÑÏ†ÑÌûà Î°úÎìúÎêòÏóàÎäîÏßÄ Îã§Ïãú ÌôïÏù∏
                                if (typeof google !== 'undefined' && google.maps && typeof google.maps.Map === 'function') {
                                    initGlobalAlarmMap();
                                    // Ï¥àÍ∏∞Ìôî ÌõÑ observer Ï†ïÎ¶¨
                                    if (window.intersectionObserver) {
                                        window.intersectionObserver.disconnect();
                                        window.intersectionObserver = null;
                                    }
                                }
                            }
                        });
                    }, { threshold: 0.1 });
                    window.intersectionObserver.observe(warRoomSection);
                }
            }
        }
        
        // window Í∞ùÏ≤¥Ïóê Î∞îÏù∏Îî©ÌïòÏó¨ head scriptÏóêÏÑú Ï†ëÍ∑º Í∞ÄÎä•ÌïòÎèÑÎ°ù Ìï®
        window.checkAndInitMap = checkAndInitMap;

        // ÏßÄÎèÑ Ï¥àÍ∏∞Ìôî Ìï®Ïàò (Singleton Ìå®ÌÑ¥)
        function initGlobalAlarmMap() {
            if (window.isMapInitialized) {
                return;
            }

            // Google Maps API Î°úÎìú ÏÉÅÌÉú ÌôïÏù∏
            if (typeof google === 'undefined' || !google.maps) {
                console.warn('Google Maps API not loaded yet');
                const loadingEl = document.getElementById('map-loading');
                if (loadingEl) {
                    loadingEl.innerHTML = '<div style="text-align: center;"><div style="font-size: 1.2rem; margin-bottom: 10px; color: var(--c-alert-warning);">Loading Google Maps API...</div><div style="font-size: 0.9rem;">Please wait</div></div>';
                }
                return;
            }

            // google.maps.Map ÏÉùÏÑ±Ïûê ÌôïÏù∏
            if (typeof google.maps.Map !== 'function') {
                console.error('google.maps.Map is not a constructor. API may not be fully loaded or activated.');
                const loadingEl = document.getElementById('map-loading');
                if (loadingEl) {
                    loadingEl.innerHTML = '<div style="text-align: center;"><div style="font-size: 1.2rem; margin-bottom: 10px; color: var(--c-alert-critical);">Maps API Error</div><div style="font-size: 0.9rem;">Maps JavaScript API is not activated. Please enable it in Google Cloud Console.</div></div>';
                }
                return;
            }

            const mapContainer = document.getElementById('google-map-container');
            if (!mapContainer) return;

            // Dark Mode ÏßÄÎèÑ Ïä§ÌÉÄÏùº
            const darkStyle = [
                { "elementType": "geometry", "stylers": [{ "color": "#212121" }] },
                { "elementType": "labels.icon", "stylers": [{ "visibility": "off" }] },
                { "elementType": "labels.text.fill", "stylers": [{ "color": "#757575" }] },
                { "elementType": "labels.text.stroke", "stylers": [{ "color": "#212121" }] },
                {
                    "featureType": "administrative",
                    "elementType": "geometry",
                    "stylers": [{ "color": "#757575" }]
                },
                {
                    "featureType": "poi",
                    "elementType": "labels.text.fill",
                    "stylers": [{ "color": "#757575" }]
                },
                {
                    "featureType": "poi.park",
                    "elementType": "geometry",
                    "stylers": [{ "color": "#181818" }]
                },
                {
                    "featureType": "poi.park",
                    "elementType": "labels.text.fill",
                    "stylers": [{ "color": "#616161" }]
                },
                {
                    "featureType": "poi.park",
                    "elementType": "labels.text.stroke",
                    "stylers": [{ "color": "#1b1b1b" }]
                },
                {
                    "featureType": "road",
                    "elementType": "geometry.fill",
                    "stylers": [{ "color": "#2c2c2c" }]
                },
                {
                    "featureType": "road",
                    "elementType": "labels.text.fill",
                    "stylers": [{ "color": "#9a9a9a" }]
                },
                {
                    "featureType": "road.arterial",
                    "elementType": "geometry",
                    "stylers": [{ "color": "#373737" }]
                },
                {
                    "featureType": "road.highway",
                    "elementType": "geometry",
                    "stylers": [{ "color": "#3c3c3c" }]
                },
                {
                    "featureType": "road.highway.controlled_access",
                    "elementType": "geometry",
                    "stylers": [{ "color": "#4e4e4e" }]
                },
                {
                    "featureType": "road.local",
                    "elementType": "labels.text.fill",
                    "stylers": [{ "color": "#616161" }]
                },
                {
                    "featureType": "transit",
                    "elementType": "labels.text.fill",
                    "stylers": [{ "color": "#757575" }]
                },
                {
                    "featureType": "water",
                    "elementType": "geometry",
                    "stylers": [{ "color": "#000000" }]
                },
                {
                    "featureType": "water",
                    "elementType": "labels.text.fill",
                    "stylers": [{ "color": "#3d3d3d" }]
                }
            ];

            try {
                mapInstance = new google.maps.Map(mapContainer, {
                    center: { lat: 20, lng: 0 },
                    zoom: 2.5,
                    styles: darkStyle,
                    disableDefaultUI: false,
                    zoomControl: true,
                    mapTypeControl: false,
                    scaleControl: true,
                    streetViewControl: false,
                    rotateControl: false,
                    fullscreenControl: true
                });

                // Î°úÎî© Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïà®Í∏∞Í∏∞
                const loadingEl = document.getElementById('map-loading');
                if (loadingEl) {
                    loadingEl.classList.add('hidden');
                }

                window.isMapInitialized = true;

                // Ï≤´ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
                fetchAndApplyData();

                // 15Î∂Ñ Í∞ÑÍ≤©ÏúºÎ°ú ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏
                // Í∏∞Ï°¥ Ïù∏ÌÑ∞Î≤åÏù¥ ÏûàÏúºÎ©¥ Ï†ïÎ¶¨
                if (alertUpdateInterval) {
                    clearInterval(alertUpdateInterval);
                }
                alertUpdateInterval = setInterval(fetchAndApplyData, 15 * 60 * 1000);
                
                // ÌéòÏù¥ÏßÄ Ïù¥ÌÉà Ïãú Ï†ïÎ¶¨
                window.addEventListener('beforeunload', function() {
                    if (alertUpdateInterval) {
                        clearInterval(alertUpdateInterval);
                    }
                    if (window.intersectionObserver) {
                        window.intersectionObserver.disconnect();
                    }
                });

            } catch (error) {
                console.error('Error initializing map:', error);
                const loadingEl = document.getElementById('map-loading');
                if (loadingEl) {
                    let errorMessage = 'Please check Google Maps API key';
                    const errorMsg = error.message || error.toString() || '';
                    
                    if (errorMsg.includes('BillingNotEnabled') || errorMsg.includes('billing')) {
                        errorMessage = 'Google Maps API billing is not enabled. Please enable billing in Google Cloud Console.';
                    } else if (errorMsg.includes('ApiNotActivated') || errorMsg.includes('not activated')) {
                        errorMessage = 'Maps JavaScript API is not activated. Please enable "Maps JavaScript API" in Google Cloud Console ‚Üí APIs & Services ‚Üí Enabled APIs.';
                    } else if (errorMsg.includes('InvalidKey') || errorMsg.includes('invalid')) {
                        errorMessage = 'Invalid Google Maps API key. Please check your API key in Google Cloud Console.';
                    } else if (errorMsg.includes('Map is not a constructor')) {
                        errorMessage = 'Maps JavaScript API is not fully loaded. Please refresh the page.';
                    }
                    
                    loadingEl.innerHTML = `<div style="text-align: center;"><div style="font-size: 1.2rem; margin-bottom: 10px; color: var(--c-alert-critical);">Map Loading Error</div><div style="font-size: 0.9rem;">${errorMessage}</div><div style="font-size: 0.75rem; color: var(--text-sub); margin-top: 8px;">Error: ${errorMsg}</div></div>`;
                }
            }
        }

        // Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Î∞è ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        async function fetchAndApplyData() {
            // Î°úÎî© ÏÉÅÌÉú ÌëúÏãú
            const listEl = document.getElementById('alert-items-list');
            if (listEl) {
                listEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-sub); padding: 40px 20px;">
                        <div style="font-size: 0.9rem;">Loading alerts...</div>
                    </div>
                `;
            }
            
            try {
                const response = await fetch('/api/global-alerts?threshold=-5.0&max_alerts=1000');
                
                // HTTP ÏÉÅÌÉú ÏΩîÎìú ÌôïÏù∏
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();

                if (data.error) {
                    console.error('Error fetching alerts:', data.error);
                    updateAlertList([], null, `Error: ${data.error}`);
                    return;
                }

                // Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
                if (!Array.isArray(data.alerts)) {
                    throw new Error('Invalid data format: alerts is not an array');
                }

                const rawAlerts = data.alerts || [];
                
                // ‚úÖ Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞ Î∞è ÌíàÏßà ÌïÑÌÑ∞ÎßÅ
                const alertsWithConfidence = rawAlerts.map(alert => ({
                    ...alert,
                    confidence: calculateConfidence(alert)
                }));
                
                // ‚úÖ Ï†ÄÏã†Î¢∞ÎèÑ Îç∞Ïù¥ÌÑ∞ ÏûêÎèô ÌïÑÌÑ∞ÎßÅ
                const filteredAlerts = alertsWithConfidence.filter(alert => {
                    // Tone-Scale Î™®Ïàú Ï†úÍ±∞ (Í∞ÄÏû• Î™ÖÌôïÌïú Ïò§Î∂ÑÎ•ò)
                    if (alert.avg_tone > 0 && alert.scale < -7.0) {
                        console.log(`ÌïÑÌÑ∞ÎßÅÎê® (Tone-Scale Î™®Ïàú): ${alert.name} [Tone: ${alert.avg_tone.toFixed(2)}, Scale: ${alert.scale.toFixed(2)}]`);
                        return false;
                    }
                    
                    // Ïã†Î¢∞ÎèÑ 60% ÎØ∏Îßå Ï†úÍ±∞
                    if (alert.confidence.score < 60) {
                        console.log(`ÌïÑÌÑ∞ÎßÅÎê® (ÎÇÆÏùÄ Ïã†Î¢∞ÎèÑ ${alert.confidence.score}%): ${alert.name}`);
                        return false;
                    }
                    
                    return true;
                });
                
                console.log(`‚úÖ Îç∞Ïù¥ÌÑ∞ ÌíàÏßà ÌïÑÌÑ∞ÎßÅ: ${rawAlerts.length}Í∞ú ‚Üí ${filteredAlerts.length}Í∞ú (${rawAlerts.length - filteredAlerts.length}Í∞ú Ï†úÍ±∞)`);
                
                allAlerts = filteredAlerts; // ÌïÑÌÑ∞ÎßÅÎêú Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
                applyFilters(); // Ï∂îÍ∞Ä ÌïÑÌÑ∞ Ï†ÅÏö©ÌïòÏó¨ ÌëúÏãú

            } catch (error) {
                console.error('Error fetching global alerts:', error);
                const errorMsg = error.message || 'Failed to load alerts. Please check your connection.';
                updateAlertList([], null, errorMsg);
            }
        }

        // ÏßÄÎèÑ ÎßàÏª§ ÏóÖÎç∞Ïù¥Ìä∏
        function updateMapMarkers(alerts) {
            if (!mapInstance) {
                console.warn('Map instance not initialized');
                return;
            }

            // Í∏∞Ï°¥ ÎßàÏª§ Ï†úÍ±∞
            currentMarkers.forEach(marker => marker.setMap(null));
            currentMarkers = [];
            
            // Í∏∞Ï°¥ ÌûàÌä∏Îßµ Ï†úÍ±∞
            if (heatmapLayer) {
                heatmapLayer.setMap(null);
                heatmapLayer = null;
            }

            // Îπà Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
            if (!alerts || alerts.length === 0) {
                return;
            }
            
            // ÌûàÌä∏Îßµ Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            const heatmapData = [];
            const validAlerts = [];

            alerts.forEach(alert => {
                // Ï¢åÌëú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
                if (!alert.lat || !alert.lng || isNaN(alert.lat) || isNaN(alert.lng)) {
                    console.warn('Invalid coordinates for alert:', alert);
                    return;
                }

                validAlerts.push(alert);
                
                const pos = { lat: alert.lat, lng: alert.lng };
                
                // ÌûàÌä∏Îßµ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä (GoldsteinScale Ï†àÎåìÍ∞íÏùÑ Í∞ÄÏ§ëÏπòÎ°ú ÏÇ¨Ïö©)
                const weight = Math.abs(alert.scale) || 1;
                heatmapData.push({
                    location: new google.maps.LatLng(alert.lat, alert.lng),
                    weight: weight
                });
            });
            
            // ÌûàÌä∏Îßµ Î†àÏù¥Ïñ¥ ÏÉùÏÑ±
            if (heatmapData.length > 0 && google.maps.visualization) {
                heatmapLayer = new google.maps.visualization.HeatmapLayer({
                    data: heatmapData,
                    map: mapInstance,
                    radius: 50,
                    opacity: 0.6,
                    gradient: [
                        'rgba(0, 255, 255, 0)',
                        'rgba(0, 191, 255, 0.3)',
                        'rgba(0, 127, 255, 0.5)',
                        'rgba(255, 165, 0, 0.7)',
                        'rgba(255, 69, 0, 0.85)',
                        'rgba(255, 0, 0, 1)'
                    ]
                });
            }
            
            // ÎßàÏª§ ÏÉùÏÑ±
            validAlerts.forEach(alert => {
                const pos = { lat: alert.lat, lng: alert.lng };
                
                // ‚úÖ Actor Ïù¥Î¶Ñ Ï†ïÎ¶¨
                const cleanName = getCleanActorName(alert.actor1, alert.actor2);
                const alertName = escapeHtml(cleanName);
                
                // ‚úÖ Event Description Í∞ÄÏ†∏Ïò§Í∏∞
                const eventDesc = getEventDescription(alert.event_code);
                
                const alertScale = (alert.scale !== undefined && alert.scale !== null) ? alert.scale.toFixed(1) : '0.0';
                const alertUrl = alert.url ? escapeHtml(alert.url) : '';
                const severityConfig = getSeverityConfig(alert.scale);

                // ÎßàÏª§ ÏÉùÏÑ± (ÌÅ¨Í∏∞ÏôÄ ÏÉâÏÉÅ Í∞úÏÑ†)
                const marker = new google.maps.Marker({
                    position: pos,
                    map: mapInstance,
                    title: alertName,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: severityConfig.size,
                        fillColor: severityConfig.color,
                        fillOpacity: 0.85,
                        strokeColor: '#ffffff',
                        strokeWeight: 2
                    },
                    animation: severityConfig.pulse ? google.maps.Animation.DROP : null
                });

                // Ïù∏Ìè¨ÏúàÎèÑÏö∞ ÏÉùÏÑ± (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
                const infoWindowContent = document.createElement('div');
                infoWindowContent.style.cssText = 'color: #1e293b; font-family: var(--font-main); padding: 12px; min-width: 200px;';
                
                // ÏúÑÌóòÎèÑ Î∞∞ÏßÄ
                const severityBadge = document.createElement('div');
                severityBadge.style.cssText = `
                    display: inline-flex;
                    align-items: center;
                    gap: 4px;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-weight: 700;
                    font-size: 0.7rem;
                    margin-bottom: 8px;
                    background: ${severityConfig.color};
                    color: white;
                `;
                severityBadge.textContent = `${severityConfig.icon} ${severityConfig.label} [${alertScale}]`;
                infoWindowContent.appendChild(severityBadge);
                
                // Ïù¥Î≤§Ìä∏ Ïù¥Î¶Ñ
                const nameDiv = document.createElement('div');
                nameDiv.style.cssText = 'font-size: 0.9rem; font-weight: 600; margin-bottom: 8px; color: #1e293b;';
                nameDiv.textContent = alertName;
                infoWindowContent.appendChild(nameDiv);
                
                // Ïã§Ï†ú Î∞úÏÉùÏßÄ
                if (alert.location) {
                    const locationDiv = document.createElement('div');
                    locationDiv.style.cssText = 'font-size: 0.75rem; color: #64748b; margin-bottom: 4px;';
                    locationDiv.innerHTML = `üìç <strong>Î∞úÏÉùÏßÄ:</strong> ${escapeHtml(alert.location)}`;
                    infoWindowContent.appendChild(locationDiv);
                }
                
                // Í¥ÄÎ†® Íµ≠Í∞Ä (Actor)
                if (alert.actor2 && alert.actor2_country) {
                    const actorDiv = document.createElement('div');
                    actorDiv.style.cssText = 'font-size: 0.75rem; color: #64748b; margin-bottom: 4px;';
                    actorDiv.textContent = `üë§ Í¥ÄÎ†®: ${escapeHtml(alert.actor2)} ${getCountryFlag(alert.actor2_country)}`;
                    infoWindowContent.appendChild(actorDiv);
                }
                
                // ‚úÖ Event Description
                if (eventDesc && eventDesc !== 'ÎØ∏Î∂ÑÎ•ò') {
                    const eventDiv = document.createElement('div');
                    eventDiv.style.cssText = 'font-size: 0.75rem; color: #3b82f6; margin-bottom: 4px; font-weight: 600;';
                    eventDiv.textContent = `‚ö° ${eventDesc}`;
                    infoWindowContent.appendChild(eventDiv);
                }
                
                // Ïπ¥ÌÖåÍ≥†Î¶¨
                if (alert.category) {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.style.cssText = 'font-size: 0.75rem; color: #64748b; margin-bottom: 8px;';
                    categoryDiv.textContent = `${getCategoryIcon(alert.category)} ${escapeHtml(alert.category)}`;
                    infoWindowContent.appendChild(categoryDiv);
                }
                
                // ÎÇ†Ïßú
                if (alert.event_date) {
                    const dateDiv = document.createElement('div');
                    dateDiv.style.cssText = 'font-size: 0.75rem; color: #64748b; margin-bottom: 8px;';
                    dateDiv.textContent = `üìÖ ${formatEventDate(alert.event_date)}`;
                    infoWindowContent.appendChild(dateDiv);
                }
                
                // ÏÜåÏä§ ÎßÅÌÅ¨
                if (alertUrl) {
                    const link = document.createElement('a');
                    link.href = alertUrl;
                    link.target = '_blank';
                    link.style.cssText = 'color: #3b82f6; font-size: 0.8rem; text-decoration: none; font-weight: 600;';
                    link.textContent = 'ÏõêÎ¨∏ Î≥¥Í∏∞ ‚Üó';
                    infoWindowContent.appendChild(link);
                }

                const infoWindow = new google.maps.InfoWindow({
                    content: infoWindowContent
                });

                // ÎßàÏª§ ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏
                marker.addListener('click', function() {
                    infoWindow.open(mapInstance, marker);
                    if (alertUrl) {
                        window.open(alertUrl, '_blank');
                    }
                });

                currentMarkers.push(marker);
            });
        }
        
        // XSS Î∞©ÏßÄÎ•º ÏúÑÌïú HTML Ïù¥Ïä§ÏºÄÏù¥ÌîÑ Ìï®Ïàò
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ÏúÑÌóòÎèÑ Î∂ÑÎ•ò Ìï®Ïàò (5Îã®Í≥Ñ)
        function getSeverityLevel(scale) {
            if (scale <= -8) return 'extreme';
            if (scale <= -6) return 'severe';
            if (scale <= -4) return 'high';
            if (scale <= -2) return 'moderate';
            return 'low';
        }
        
        // ÏúÑÌóòÎèÑÎ≥Ñ ÏÑ§Ï†ï
        function getSeverityConfig(scale) {
            const level = getSeverityLevel(scale);
            const configs = {
                extreme: {
                    color: '#991b1b',
                    size: 12,
                    icon: '‚ö†Ô∏è',
                    label: 'EXTREME',
                    pulse: true
                },
                severe: {
                    color: '#dc2626',
                    size: 10,
                    icon: 'üî¥',
                    label: 'SEVERE',
                    pulse: true
                },
                high: {
                    color: '#ea580c',
                    size: 9,
                    icon: 'üü†',
                    label: 'HIGH',
                    pulse: false
                },
                moderate: {
                    color: '#f59e0b',
                    size: 8,
                    icon: 'üü°',
                    label: 'MODERATE',
                    pulse: false
                },
                low: {
                    color: '#3b82f6',
                    size: 7,
                    icon: '‚ÑπÔ∏è',
                    label: 'LOW',
                    pulse: false
                }
            };
            return configs[level];
        }
        
        // ÎßàÏª§ ÏÉâÏÉÅ Í≤∞Ï†ï (ÌïòÏúÑ Ìò∏Ìôò)
        function getMarkerColor(scale) {
            return getSeverityConfig(scale).color;
        }
        
        // ÎÇ†Ïßú Ìè¨Îß∑ÌåÖ Ìï®Ïàò
        function formatEventDate(dateStr) {
            if (!dateStr || dateStr.length !== 8) return '';
            const year = dateStr.substring(0, 4);
            const month = dateStr.substring(4, 6);
            const day = dateStr.substring(6, 8);
            return `${year}-${month}-${day}`;
        }
        
        // Ïπ¥ÌÖåÍ≥†Î¶¨ ÏïÑÏù¥ÏΩò Í∞ÄÏ†∏Ïò§Í∏∞
        function getCategoryIcon(category) {
            const icons = {
                'Material Conflict': '‚öîÔ∏è',
                'Verbal Conflict': 'üí¨',
                'Material Cooperation': 'ü§ù',
                'Verbal Cooperation': 'üó£Ô∏è'
            };
            return icons[category] || 'üìå';
        }
        
        // Íµ≠Í∞Ä ÏΩîÎìúÏóêÏÑú ÌîåÎûòÍ∑∏ Ïù¥Î™®ÏßÄ Í∞ÄÏ†∏Ïò§Í∏∞
        function getCountryFlag(countryCode) {
            if (!countryCode || countryCode.length !== 2) return 'üåê';
            const codePoints = countryCode
                .toUpperCase()
                .split('')
                .map(char => 127397 + char.charCodeAt());
            return String.fromCodePoint(...codePoints);
        }
        
        // ÏúÑÌóòÎèÑ ÏùòÎØ∏ ÏÑ§Î™Ö
        function getSeverityMeaning(scale) {
            if (scale <= -8) return 'Ï†ÑÏüÅ, ÎåÄÎüâÏÇ¥ÏÉÅ Îì± Í∑πÎèÑÎ°ú Ïã¨Í∞ÅÌïú ÏÇ¨Í±¥';
            if (scale <= -6) return 'Íµ∞ÏÇ¨ Í≥µÍ≤©, Ìè≠Î†• ÏãúÏúÑ Îì± Îß§Ïö∞ Ïã¨Í∞ÅÌïú Í∞àÎì±';
            if (scale <= -4) return 'Ï§ëÍ∞Ñ ÏàòÏ§ÄÏùò Í∞àÎì± Î∞è Ï∂©Îèå';
            if (scale <= -2) return 'Í≤ΩÎØ∏Ìïú Í∞àÎì± Î∞è Ïô∏ÍµêÏ†Å Ìï≠Ïùò';
            return 'Ï†ïÎ≥¥ÏÑ± Ïù¥Î≤§Ìä∏';
        }
        
        // Î™®Îã¨ Ïó¥Í∏∞
        function openAlertModal(alert) {
            const modal = document.getElementById('alert-detail-modal');
            if (!modal) return;
            
            const severityConfig = getSeverityConfig(alert.scale);
            const severityLevel = getSeverityLevel(alert.scale);
            
            // ÏúÑÌóòÎèÑ Î∞∞ÏßÄ
            const badge = document.getElementById('modal-severity-badge');
            badge.className = `modal-severity-badge ${severityLevel}`;
            badge.innerHTML = `<span>${severityConfig.icon}</span> <span>${severityConfig.label}</span> <span>GoldsteinScale: ${alert.scale.toFixed(1)}</span>`;
            
            // ÏúÑÌóòÎèÑ ÏùòÎØ∏
            document.getElementById('modal-severity-meaning').textContent = getSeverityMeaning(alert.scale);
            
            // ‚úÖ Ïù¥Î≤§Ìä∏ Ï†úÎ™© (Actor Ïù¥Î¶Ñ Ï†ïÎ¶¨)
            const cleanName = getCleanActorName(alert.actor1, alert.actor2);
            document.getElementById('modal-event-title').textContent = cleanName;
            
            // Î©îÌÉÄ Ï†ïÎ≥¥
            document.getElementById('modal-event-date').textContent = formatEventDate(alert.event_date) || 'Unknown';
            
            // Ïã§Ï†ú Î∞úÏÉùÏßÄÏôÄ Í¥ÄÎ†® Íµ≠Í∞Ä Íµ¨Î∂Ñ
            const locationText = alert.location ? `Î∞úÏÉùÏßÄ: ${alert.location}` : 'Unknown';
            if (alert.actor2_country && alert.country_code && alert.actor2_country !== alert.country_code) {
                document.getElementById('modal-event-location').innerHTML = `${locationText}<br><small style="color: var(--text-sub);">Í¥ÄÎ†® Íµ≠Í∞Ä: ${alert.actor2} ${getCountryFlag(alert.actor2_country)}</small>`;
            } else {
                document.getElementById('modal-event-location').textContent = locationText;
            }
            
            document.getElementById('modal-event-category').textContent = `${getCategoryIcon(alert.category)} ${alert.category || 'Unknown'}`;
            
            // ‚úÖ Event Code ÏÑ§Î™ÖÏúºÎ°ú Î≥ÄÍ≤Ω
            const eventDesc = getEventDescription(alert.event_code);
            document.getElementById('modal-event-code').textContent = `Ïù¥Î≤§Ìä∏ Ïú†Ìòï: ${eventDesc}`;
            
            // ÌñâÏúÑÏûê
            document.getElementById('modal-actor1-flag').textContent = getCountryFlag(alert.actor1_country);
            document.getElementById('modal-actor1-name').textContent = alert.actor1 || 'Unknown';
            document.getElementById('modal-actor2-flag').textContent = getCountryFlag(alert.actor2_country);
            document.getElementById('modal-actor2-name').textContent = alert.actor2 || 'Unknown';
            document.getElementById('modal-relationship-type').textContent = alert.category || 'Unknown';
            
            // ÌÜµÍ≥Ñ
            document.getElementById('modal-num-mentions').textContent = alert.num_mentions || '0';
            document.getElementById('modal-num-sources').textContent = alert.num_sources || '0';
            document.getElementById('modal-num-articles').textContent = alert.num_articles || '0';
            
            const avgTone = alert.avg_tone || 0;
            const toneText = avgTone > 0 ? `+${avgTone.toFixed(1)} (Í∏çÏ†ïÏ†Å)` : `${avgTone.toFixed(1)} (Î∂ÄÏ†ïÏ†Å)`;
            document.getElementById('modal-avg-tone').textContent = toneText;
            
            // ÏÜåÏä§ ÎßÅÌÅ¨
            const sourceLink = document.getElementById('modal-source-link');
            if (alert.url) {
                sourceLink.href = alert.url;
                sourceLink.style.display = 'inline-flex';
            } else {
                sourceLink.style.display = 'none';
            }
            
            // Î™®Îã¨ ÌëúÏãú
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        // Î™®Îã¨ Îã´Í∏∞
        function closeAlertModal() {
            const modal = document.getElementById('alert-detail-modal');
            if (!modal) return;
            
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
        
        // Î™®Îã¨ Ïô∏Î∂Ä ÌÅ¥Î¶≠ Ïãú Îã´Í∏∞
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('alert-detail-modal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeAlertModal();
                    }
                });
            }
        });
        
        // ÏúÑÌóòÎèÑ ÌïÑÌÑ∞
        function filterBySeverity(severity) {
            currentFilters.severity = severity;
            
            // Î≤ÑÌäº ÌôúÏÑ±Ìôî ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            document.querySelectorAll('.filter-btn[data-severity]').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.severity === severity) {
                    btn.classList.add('active');
                }
            });
            
            applyFilters();
        }
        
        // ÌïÑÌÑ∞ Î∞è Ï†ïÎ†¨ Ï†ÅÏö©
        function applyFilters() {
            // ÌòÑÏû¨ ÌïÑÌÑ∞ ÏÉÅÌÉú Í∞ÄÏ†∏Ïò§Í∏∞
            const categoryFilter = document.getElementById('category-filter');
            const sortSelect = document.getElementById('sort-select');
            
            if (categoryFilter) currentFilters.category = categoryFilter.value;
            if (sortSelect) currentFilters.sort = sortSelect.value;
            
            // ÌïÑÌÑ∞ÎßÅ
            let filteredAlerts = allAlerts.filter(alert => {
                // ÏúÑÌóòÎèÑ ÌïÑÌÑ∞
                if (currentFilters.severity !== 'all') {
                    const alertSeverity = getSeverityLevel(alert.scale);
                    if (alertSeverity !== currentFilters.severity) {
                        return false;
                    }
                }
                
                // Ïπ¥ÌÖåÍ≥†Î¶¨ ÌïÑÌÑ∞
                if (currentFilters.category !== 'all') {
                    if (alert.category !== currentFilters.category) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Ï†ïÎ†¨
            filteredAlerts.sort((a, b) => {
                switch (currentFilters.sort) {
                    case 'severity':
                        return a.scale - b.scale; // ÎÇÆÏùÄ Í∞í(Îçî ÏúÑÌóò)Ïù¥ Î®ºÏ†Ä
                    case 'recent':
                        return (b.event_date || '').localeCompare(a.event_date || '');
                    case 'mentions':
                        return (b.num_mentions || 0) - (a.num_mentions || 0);
                    default:
                        return 0;
                }
            });
            
            // ÏßÄÎèÑ Î∞è Î¶¨Ïä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
            updateMapMarkers(filteredAlerts);
            updateAlertList(filteredAlerts, new Date().toISOString());
            updateTimelineView(filteredAlerts);
            updateCountryDashboard(filteredAlerts);
        }
        
        // Î∑∞ Ï†ÑÌôò
        function switchView(view) {
            const listView = document.getElementById('alert-items-list');
            const timelineView = document.getElementById('alert-timeline-view');
            const countryView = document.getElementById('alert-country-dashboard');
            const viewBtns = document.querySelectorAll('.view-btn');
            
            viewBtns.forEach(btn => btn.classList.remove('active'));
            
            listView.style.display = 'none';
            timelineView.classList.remove('active');
            countryView.classList.remove('active');
            
            if (view === 'list') {
                listView.style.display = 'flex';
                viewBtns[0].classList.add('active');
            } else if (view === 'timeline') {
                timelineView.classList.add('active');
                viewBtns[1].classList.add('active');
            } else if (view === 'country') {
                countryView.classList.add('active');
                viewBtns[2].classList.add('active');
            }
        }
        
        // ÌÉÄÏûÑÎùºÏù∏ Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
        function updateTimelineView(alerts) {
            const timelineEl = document.getElementById('alert-timeline-view');
            if (!timelineEl) return;
            
            if (alerts.length === 0) {
                timelineEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-sub); padding: 40px 20px;">
                        <div style="font-size: 0.9rem;">No alerts found</div>
                    </div>
                `;
                return;
            }
            
            // ÎÇ†ÏßúÎ≥ÑÎ°ú Í∑∏Î£πÌôî
            const groupedByDate = {};
            alerts.forEach(alert => {
                const date = formatEventDate(alert.event_date) || 'Unknown';
                if (!groupedByDate[date]) {
                    groupedByDate[date] = [];
                }
                groupedByDate[date].push(alert);
            });
            
            // ÎÇ†Ïßú Ï†ïÎ†¨ (ÏµúÏã†Ïàú)
            const sortedDates = Object.keys(groupedByDate).sort().reverse();
            
            // HTML ÏÉùÏÑ±
            timelineEl.innerHTML = '';
            sortedDates.forEach(date => {
                const dateGroup = document.createElement('div');
                dateGroup.className = 'timeline-date-group';
                
                const dateHeader = document.createElement('div');
                dateHeader.className = 'timeline-date-header';
                dateHeader.innerHTML = `
                    <span>üìÖ ${date}</span>
                    <span class="timeline-date-count">${groupedByDate[date].length}</span>
                `;
                dateGroup.appendChild(dateHeader);
                
                const eventsContainer = document.createElement('div');
                eventsContainer.className = 'timeline-events';
                
                groupedByDate[date].forEach(alert => {
                    const severityLevel = getSeverityLevel(alert.scale);
                    const severityConfig = getSeverityConfig(alert.scale);
                    
                    const eventEl = document.createElement('div');
                    eventEl.className = `timeline-event ${severityLevel}`;
                    eventEl.addEventListener('click', () => openAlertModal(alert));
                    
                    // ‚úÖ Actor Ïù¥Î¶Ñ Ï†ïÎ¶¨
                    const cleanName = getCleanActorName(alert.actor1, alert.actor2);
                    
                    // ‚úÖ Event Description Í∞ÄÏ†∏Ïò§Í∏∞
                    const eventDesc = getEventDescription(alert.event_code);
                    
                    const locationInfo = [];
                    if (alert.location) {
                        locationInfo.push(`üìç ${escapeHtml(alert.location)}`);
                    }
                    if (eventDesc && eventDesc !== 'ÎØ∏Î∂ÑÎ•ò') {
                        locationInfo.push(`‚ö° ${escapeHtml(eventDesc)}`);
                    }
                    if (alert.category) {
                        locationInfo.push(`${getCategoryIcon(alert.category)} ${escapeHtml(alert.category)}`);
                    }
                    
                    eventEl.innerHTML = `
                        <div class="timeline-event-header">
                            <span class="severity-badge ${severityLevel}" style="font-size: 0.65rem; padding: 2px 6px;">
                                ${severityConfig.icon} ${severityConfig.label}
                            </span>
                            <span class="timeline-event-time">${alert.scale.toFixed(1)}</span>
                        </div>
                        <div class="timeline-event-title">${escapeHtml(cleanName)}</div>
                        <div class="timeline-event-location">
                            ${locationInfo.join(' ‚Ä¢ ')}
                        </div>
                    `;
                    
                    eventsContainer.appendChild(eventEl);
                });
                
                dateGroup.appendChild(eventsContainer);
                timelineEl.appendChild(dateGroup);
            });
        }
        
        // Íµ≠Í∞ÄÎ≥Ñ ÎåÄÏãúÎ≥¥Îìú ÏóÖÎç∞Ïù¥Ìä∏
        function updateCountryDashboard(alerts) {
            const dashboardEl = document.getElementById('alert-country-dashboard');
            if (!dashboardEl) return;
            
            if (alerts.length === 0) {
                dashboardEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-sub); padding: 40px 20px;">
                        <div style="font-size: 0.9rem;">No country data available</div>
                    </div>
                `;
                return;
            }
            
            // Íµ≠Í∞ÄÎ≥ÑÎ°ú Í∑∏Î£πÌôî
            const groupedByCountry = {};
            alerts.forEach(alert => {
                const country = alert.country_code || 'Unknown';
                if (!groupedByCountry[country]) {
                    groupedByCountry[country] = {
                        alerts: [],
                        extreme: 0,
                        severe: 0,
                        high: 0,
                        avgScale: 0
                    };
                }
                groupedByCountry[country].alerts.push(alert);
                
                const severity = getSeverityLevel(alert.scale);
                if (severity === 'extreme') groupedByCountry[country].extreme++;
                else if (severity === 'severe') groupedByCountry[country].severe++;
                else if (severity === 'high') groupedByCountry[country].high++;
            });
            
            // ÌèâÍ∑† Ïä§ÏºÄÏùº Í≥ÑÏÇ∞ Î∞è Ï†ïÎ†¨
            const countries = Object.keys(groupedByCountry).map(country => {
                const data = groupedByCountry[country];
                const avgScale = data.alerts.reduce((sum, a) => sum + a.scale, 0) / data.alerts.length;
                return {
                    code: country,
                    ...data,
                    avgScale: avgScale
                };
            }).sort((a, b) => a.avgScale - b.avgScale); // ÎÇÆÏùÄ Í∞í(Îçî ÏúÑÌóò)Ïù¥ Î®ºÏ†Ä
            
            // HTML ÏÉùÏÑ±
            dashboardEl.innerHTML = '';
            countries.forEach(country => {
                const countryCard = document.createElement('div');
                countryCard.className = 'country-card';
                countryCard.addEventListener('click', () => {
                    // Ìï¥Îãπ Íµ≠Í∞Ä ÌïÑÌÑ∞ÎßÅ
                    currentFilters.country = country.code;
                    applyFilters();
                    switchView('list');
                });
                
                countryCard.innerHTML = `
                    <div class="country-header">
                        <div class="country-name">
                            <span class="country-flag">${getCountryFlag(country.code)}</span>
                            <span>${country.code}</span>
                        </div>
                        <span class="country-count">${country.alerts.length}</span>
                    </div>
                    <div class="country-stats">
                        <div class="country-stat">
                            <div class="country-stat-label">EXTREME</div>
                            <div class="country-stat-value extreme">${country.extreme}</div>
                        </div>
                        <div class="country-stat">
                            <div class="country-stat-label">SEVERE</div>
                            <div class="country-stat-value severe">${country.severe}</div>
                        </div>
                        <div class="country-stat">
                            <div class="country-stat-label">HIGH</div>
                            <div class="country-stat-value high">${country.high}</div>
                        </div>
                    </div>
                `;
                
                dashboardEl.appendChild(countryCard);
            });
        }

        // ÏïåÎ¶º Î¶¨Ïä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        function updateAlertList(alerts, lastUpdated, errorMessage = null) {
            const listEl = document.getElementById('alert-items-list');
            const countEl = document.getElementById('alert-count');
            const updatedEl = document.getElementById('last-updated');

            if (!listEl) return;

            // Ïπ¥Ïö¥Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
            if (countEl) {
                countEl.textContent = alerts.length;
            }

            // ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ
            if (updatedEl) {
                if (errorMessage) {
                    updatedEl.textContent = errorMessage;
                    updatedEl.style.color = 'var(--c-alert-critical)';
                } else if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    const timeStr = date.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    updatedEl.textContent = `Last Updated: ${timeStr}`;
                    updatedEl.style.color = 'var(--text-sub)';
                } else {
                    updatedEl.textContent = 'Last Updated: --';
                    updatedEl.style.color = 'var(--text-sub)';
                }
            }

            // Î¶¨Ïä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
            if (errorMessage) {
                listEl.innerHTML = `
                    <div style="text-align: center; color: var(--c-alert-critical); padding: 40px 20px;">
                        <div style="font-size: 0.9rem;">${errorMessage}</div>
                    </div>
                `;
                return;
            }

            if (alerts.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-sub); padding: 40px 20px;">
                        <div style="font-size: 0.9rem;">No critical alerts found</div>
                    </div>
                `;
                return;
            }

            // XSS Î∞©ÏßÄÎ•º ÏúÑÌï¥ DOM Ï°∞Ïûë Î∞©ÏãùÏúºÎ°ú Î≥ÄÍ≤Ω
            listEl.innerHTML = '';
            alerts.forEach(alert => {
                const severityConfig = getSeverityConfig(alert.scale);
                const alertScale = (alert.scale !== undefined && alert.scale !== null) ? alert.scale.toFixed(1) : '0.0';
                
                // ‚úÖ Actor Ïù¥Î¶Ñ Ï†ïÎ¶¨ (Îπà actor Ï†úÍ±∞)
                const cleanActorName = getCleanActorName(alert.actor1, alert.actor2);
                const alertName = escapeHtml(cleanActorName);
                
                const alertUrl = alert.url ? escapeHtml(alert.url) : '';
                const actor1 = alert.actor1 ? escapeHtml(alert.actor1) : '';
                const actor2 = alert.actor2 ? escapeHtml(alert.actor2) : '';
                const location = alert.location ? escapeHtml(alert.location) : '';
                const category = alert.category ? escapeHtml(alert.category) : '';
                const eventDate = alert.event_date ? formatEventDate(alert.event_date) : '';
                
                // ‚úÖ Event Code ÏÑ§Î™Ö Í∞ÄÏ†∏Ïò§Í∏∞
                const eventDescription = getEventDescription(alert.event_code);
                
                const card = document.createElement('div');
                card.className = `alert-card ${getSeverityLevel(alert.scale)}`;
                    card.style.cursor = 'pointer';
                card.addEventListener('click', function(e) {
                    e.preventDefault();
                    openAlertModal(alert);
                });
                
                // Ìó§Îçî: ÏúÑÌóòÎèÑ + ÎÇ†Ïßú + Ïπ¥ÌÖåÍ≥†Î¶¨
                const header = document.createElement('div');
                header.className = 'alert-header';
                
                const severityBadge = document.createElement('div');
                severityBadge.className = `severity-badge ${getSeverityLevel(alert.scale)}`;
                severityBadge.innerHTML = `<span>${severityConfig.icon}</span> <span>${severityConfig.label}</span> <span>[${alertScale}]</span>`;
                header.appendChild(severityBadge);
                
                const meta = document.createElement('div');
                meta.className = 'alert-meta';
                if (eventDate) {
                    const dateSpan = document.createElement('span');
                    dateSpan.textContent = eventDate;
                    meta.appendChild(dateSpan);
                }
                // ‚úÖ Event Description ÌëúÏãú (Event Code ÎåÄÏã†)
                if (eventDescription && eventDescription !== 'ÎØ∏Î∂ÑÎ•ò') {
                    const eventSpan = document.createElement('span');
                    eventSpan.className = 'alert-event-type';
                    eventSpan.textContent = `‚ö° ${eventDescription}`;
                    eventSpan.style.color = 'var(--accent-color)';
                    eventSpan.style.fontWeight = '500';
                    meta.appendChild(eventSpan);
                }
                if (category) {
                    const categorySpan = document.createElement('span');
                    categorySpan.className = 'alert-category';
                    categorySpan.textContent = `${getCategoryIcon(category)} ${category}`;
                    meta.appendChild(categorySpan);
                }
                header.appendChild(meta);
                card.appendChild(header);
                
                // Î≥∏Î¨∏: Ïù¥Î≤§Ìä∏ Ïù¥Î¶Ñ
                const content = document.createElement('div');
                content.className = 'alert-content';
                const title = document.createElement('div');
                title.className = 'alert-card-title';
                title.textContent = alertName;
                content.appendChild(title);
                card.appendChild(content);
                
                // Ìë∏ÌÑ∞: ÏúÑÏπò + ÌñâÏúÑÏûê
                const footer = document.createElement('div');
                footer.className = 'alert-footer';
                
                // Ïã§Ï†ú Î∞úÏÉùÏßÄ (ActionGeo)
                if (location) {
                    const locationDiv = document.createElement('div');
                    locationDiv.className = 'alert-location';
                    locationDiv.innerHTML = `üìç <strong>Î∞úÏÉùÏßÄ:</strong> ${location}`;
                    footer.appendChild(locationDiv);
                }
                
                // Í¥ÄÎ†® Íµ≠Í∞Ä (Actor Ï†ïÎ≥¥)
                if (actor1 || actor2) {
                    const actorsDiv = document.createElement('div');
                    actorsDiv.className = 'alert-actors';
                    actorsDiv.innerHTML = `üë§ <strong>Í¥ÄÎ†®:</strong> `;
                    
                    if (actor1) {
                        const actor1Span = document.createElement('span');
                        actor1Span.textContent = actor1;
                        actorsDiv.appendChild(actor1Span);
                    }
                    if (actor1 && actor2) {
                        const arrow = document.createElement('span');
                        arrow.textContent = ' ‚Üí ';
                        actorsDiv.appendChild(arrow);
                    }
                    if (actor2) {
                        const actor2Span = document.createElement('span');
                        actor2Span.textContent = actor2;
                        actorsDiv.appendChild(actor2Span);
                    }
                    
                    // Actor2Ïùò Íµ≠Í∞Ä ÌëúÏãú (ÏûàÎäî Í≤ΩÏö∞)
                    if (alert.actor2_country) {
                        const countryFlag = getCountryFlag(alert.actor2_country);
                        const countrySpan = document.createElement('span');
                        countrySpan.textContent = ` ${countryFlag}`;
                        countrySpan.title = alert.actor2_country;
                        actorsDiv.appendChild(countrySpan);
                    }
                    
                    footer.appendChild(actorsDiv);
                }
                
                card.appendChild(footer);
                listEl.appendChild(card);
            });
        }
        
        // ============================================================
        // Ìï®ÏàòÎì§ÏùÑ window Í∞ùÏ≤¥Ïóê ÎÖ∏Ï∂ú
        // Ï£ºÏùò: Ìï®Ïàò Î∞îÏù∏Îî©ÏùÄ DOMContentLoaded Ìï∏Îì§Îü¨ÏóêÏÑúÎßå ÏàòÌñâÎê®
        // Ïä§ÌÅ¨Î¶ΩÌä∏ ÎÅùÏóêÏÑú Î∞îÏù∏Îî©ÌïòÏßÄ ÏïäÎäî Ïù¥Ïú†:
        // - Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä Îß§Ïö∞ Í∏∏Ïñ¥ÏÑú Ìï®ÏàòÎì§Ïù¥ ÏïÑÏßÅ Ï†ïÏùòÎêòÏßÄ ÏïäÏïòÏùÑ Ïàò ÏûàÏùå
        // - DOMContentLoaded Ìï∏Îì§Îü¨ÏóêÏÑú Î∞îÏù∏Îî©ÌïòÎ©¥ Î™®Îì† Ìï®ÏàòÍ∞Ä Ï†ïÏùòÎêú ÌõÑ Ïã§ÌñâÎê®
        // ============================================================
        // loadGoogleMapsAPIÎäî head scriptÏóêÏÑú Ïù¥ÎØ∏ Ï†ÑÏó≠ÏúºÎ°ú Ï†ïÏùòÎê®
    </script>
</body>
</html>